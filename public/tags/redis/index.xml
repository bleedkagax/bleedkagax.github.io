<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Redis on Kaga Blog</title><link>https://bleedkagax.github.io/tags/redis/</link><description>Recent content in Redis on Kaga Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 02 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://bleedkagax.github.io/tags/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>Eval and Evalsha</title><link>https://bleedkagax.github.io/post/3_eval_and_evalsha/</link><pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate><guid>https://bleedkagax.github.io/post/3_eval_and_evalsha/</guid><description>&lt;h1 id="overview">Overview&lt;/h1>
&lt;p>&lt;code>EVAL&lt;/code> and &lt;code>EVALSHA&lt;/code> are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>&lt;code>EVAL&lt;/code>:&lt;/strong> This command takes the Lua script as an argument. Redis parses and hashes the script every time &lt;code>EVAL&lt;/code> is called. This adds overhead, especially for frequently executed scripts.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>EVALSHA&lt;/code>:&lt;/strong> This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it&amp;rsquo;s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts.&lt;/p></description></item><item><title>Redlock Algorithm</title><link>https://bleedkagax.github.io/post/4_redlock_algorithm/</link><pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate><guid>https://bleedkagax.github.io/post/4_redlock_algorithm/</guid><description>&lt;h1 id="redlock-algorithm-distributed-lock-management">Redlock Algorithm: Distributed Lock Management&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.&lt;/p>
&lt;h2 id="purpose">Purpose&lt;/h2>
&lt;p>The main purpose of the Redlock algorithm is to ensure that:&lt;/p>
&lt;ol>
&lt;li>Mutual exclusion is guaranteed&lt;/li>
&lt;li>Deadlock free operation is possible&lt;/li>
&lt;li>Fault tolerance is achieved up to a certain degree&lt;/li>
&lt;/ol>
&lt;h2 id="algorithm-overview">Algorithm Overview&lt;/h2>
&lt;p>The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition.&lt;/p></description></item><item><title>Redis, Pika, and Codis</title><link>https://bleedkagax.github.io/post/1_redis_pika_codis/</link><pubDate>Mon, 09 Sep 2024 00:00:00 +0000</pubDate><guid>https://bleedkagax.github.io/post/1_redis_pika_codis/</guid><description>&lt;h1 id="comprehensive-technical-analysis-redis-pika-and-codis">Comprehensive Technical Analysis: Redis, Pika, and Codis&lt;/h1>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.&lt;/p>
&lt;h2 id="redis">Redis&lt;/h2>
&lt;p>Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue.&lt;/p></description></item><item><title>Redis Performance Issues</title><link>https://bleedkagax.github.io/post/2_redis_performance_issues/</link><pubDate>Sat, 07 Sep 2024 00:00:00 +0000</pubDate><guid>https://bleedkagax.github.io/post/2_redis_performance_issues/</guid><description>&lt;h1 id="a-comprehensive-guide-to-troubleshooting-redis-performance-issues">A comprehensive guide to troubleshooting Redis performance issues&lt;/h1>
&lt;h2 id="1-introduction">1. Introduction&lt;/h2>
&lt;p>Redis is renowned for its high performance, capable of handling 100,000 operations per second. However, users may encounter unexpected latency issues in various scenarios:&lt;/p>
&lt;ul>
&lt;li>Same commands sometimes fast, sometimes slow&lt;/li>
&lt;li>Simple operations like SET and DEL taking unexpectedly long&lt;/li>
&lt;li>Temporary slowdowns that resolve themselves&lt;/li>
&lt;li>Sudden performance degradation after long periods of stability&lt;/li>
&lt;/ul>
&lt;p>This comprehensive guide (approximately 20,000 words) aims to provide a thorough troubleshooting approach for Redis performance issues.&lt;/p></description></item><item><title>Redis Interview</title><link>https://bleedkagax.github.io/post/0_redis_interview/</link><pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate><guid>https://bleedkagax.github.io/post/0_redis_interview/</guid><description>&lt;h2 id="what-is-redis-pipelining">What is Redis pipelining?&lt;/h2>
&lt;p>Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.&lt;/p>
&lt;h2 id="explain-redis-transactions">Explain Redis transactions.&lt;/h2>
&lt;p>Redis transactions allow the execution of a group of commands in a single step. Key properties:&lt;/p>
&lt;ul>
&lt;li>All commands in a transaction are serialized and executed sequentially&lt;/li>
&lt;li>Either all or none of the commands are processed&lt;/li>
&lt;li>Redis transactions are atomic&lt;/li>
&lt;/ul>
&lt;h2 id="how-does-redis-implement-master-slave-replication">How does Redis implement master-slave replication?&lt;/h2>
&lt;p>Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure.&lt;/p></description></item></channel></rss>