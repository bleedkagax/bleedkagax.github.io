<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Design | Kaga Blog</title>
<meta name=keywords content="SystemDesign"><meta name=description content="How to Solve Cache Penetration?
Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:

Caching Empty Results: Store empty results for non-existent keys with a short expiration time.
Bloom Filters: Use a Bloom filter to check if a key exists before querying the database.
Rate Limiting: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data.

How to Solve Cache Avalanche?
Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_system_design/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_system_design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="System Design"><meta property="og:description" content="How to Solve Cache Penetration?
Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:

Caching Empty Results: Store empty results for non-existent keys with a short expiration time.
Bloom Filters: Use a Bloom filter to check if a key exists before querying the database.
Rate Limiting: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data.

How to Solve Cache Avalanche?
Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_system_design/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-13T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="System Design"><meta name=twitter:description content="How to Solve Cache Penetration?
Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:

Caching Empty Results: Store empty results for non-existent keys with a short expiration time.
Bloom Filters: Use a Bloom filter to check if a key exists before querying the database.
Rate Limiting: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data.

How to Solve Cache Avalanche?
Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://bleedkagax.github.io/post/0_system_design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"System Design","name":"System Design","description":"How to Solve Cache Penetration? Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:\nCaching Empty Results: Store empty results for non-existent keys with a short expiration time. Bloom Filters: Use a Bloom filter to check if a key exists before querying the database. Rate Limiting: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data. How to Solve Cache Avalanche? Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure.\n","keywords":["SystemDesign"],"articleBody":"How to Solve Cache Penetration? Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:\nCaching Empty Results: Store empty results for non-existent keys with a short expiration time. Bloom Filters: Use a Bloom filter to check if a key exists before querying the database. Rate Limiting: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data. How to Solve Cache Avalanche? Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure.\nWhile rate limiting (a solution for cache penetration) can help mitigate the impact of a cache avalanche by reducing the load on the database, it doesn’t prevent the avalanche itself. The core of solving a cache avalanche lies in different strategies:\nStaggered Expiration: Instead of setting the same expiration time for all cache entries, vary the expiration times slightly to prevent mass simultaneous expirations. Cache Clustering/Redundancy: Use multiple cache servers to distribute the load and provide redundancy. If one server fails, others can continue serving requests. Cache Pre-warming: For frequently accessed data, proactively load it into the cache before it’s requested. Circuit Breakers: Implement circuit breakers to prevent cascading failures. If the database becomes overloaded, the circuit breaker can temporarily stop sending requests to it, preventing further overload. What Are the Communication Methods Between Different Services? Different services can communicate through various methods:\nHTTP/REST APIs: Synchronous communication using standard HTTP methods. gRPC: High-performance RPC framework using HTTP/2. Message Queues: Asynchronous communication via message brokers like RabbitMQ or Kafka. WebSockets: For real-time bidirectional communication between clients and servers. What Are the Steps Involved in an RPC Call? An RPC call typically involves these steps:\nThe client sends an RPC request to the server. The client stub serializes the request into a suitable format (e.g., JSON or Protobuf). The request is sent over the network to the server. The server receives and deserializes the request. The server processes the request and prepares a response. The response is serialized and sent back to the client. The client stub deserializes the response for use. How Can Performance Tuning Be Done in RPC Frameworks? To optimize performance in RPC frameworks:\nUse efficient serialization formats (e.g., Protobuf). Implement connection pooling to reuse connections. Use asynchronous calls where possible to avoid blocking. Optimize network latency through compression or batching requests. Which RPC Frameworks Have You Used? Commonly used RPC frameworks include:\ngRPC: A modern high-performance framework developed by Google. Apache Thrift: A cross-language framework developed by Facebook. Dubbo: A Java-based RPC framework from Alibaba. JSON-RPC: A remote procedure call protocol encoded in JSON. Describe Circuit Breaker, Rate Limiting, Downgrading, and Avalanche Effects Circuit Breaker: Prevents repeated calls to failing services by temporarily blocking requests until they recover. Rate Limiting: Controls how often users can access resources within a specified timeframe to prevent abuse or overload. Downgrading: Provides fallback mechanisms when certain features are unavailable or degraded due to failures. Avalanche Effect: Occurs when multiple dependent services fail simultaneously due to cascading failures from one service’s downtime. What Open Source Frameworks Do You Know for Circuit Breaking and Downgrading? Notable open-source frameworks include:\nHystrix: A circuit breaker library from Netflix designed for fault tolerance in distributed systems. Resilience4j: A lightweight alternative for Java applications providing circuit breaking capabilities. Sentinel: An open-source project from Alibaba that provides circuit breaking and rate limiting features. What Are the Differences Between Docker and Virtual Machines? Feature Docker Virtual Machine Operating System Shares host OS kernel Requires separate OS per VM Performance Lightweight with faster startup times Heavier due to full OS overhead Portability Highly portable across environments Less portable due to size Resource Usage More efficient resource utilization Consumes more resources What Problems Does Service Mesh Solve? Service mesh addresses challenges in microservices architectures such as:\nService discovery Load balancing Traffic management Security (e.g., authentication) Observability (e.g., monitoring and tracing) By abstracting these concerns away from application code, service mesh allows developers to focus on business logic while ensuring robust inter-service communication.\nHow does a service mesh work? A service mesh simplifies inter-service communication in a microservices architecture by abstracting it into a dedicated infrastructure layer. This layer uses network proxies, often called sidecars, deployed alongside each service. All traffic flows through these proxies.\nThe mesh comprises two key components:\nData Plane: This consists of the sidecar proxies. They intercept requests, establish secure connections, and handle low-level messaging, including features like circuit breaking and retries. Core functionality such as load balancing, service discovery, and routing resides here.\nControl Plane: This acts as the central management layer. Administrators use it to define and configure services, including endpoints, routing rules, load balancing, and security settings. The control plane distributes this configuration to the data plane proxies, allowing for dynamic adjustments without service restarts. It typically includes a service registry, automatic service discovery, and telemetry data collection.\nWhat Technologies Are Related to DevOps? Key technologies related to DevOps include:\nVersion Control Systems: Git, SVN Continuous Integration/Continuous Deployment (CI/CD): Jenkins, GitLab CI Containerization: Docker, Kubernetes Configuration Management Tools: Ansible, Puppet Monitoring Tools: Prometheus, Grafana Infrastructure as Code (IaC): Terraform What is microservices architecture? Microservices architecture is an approach to developing a single application as a suite of small, independently deployable services. Each service runs in its own process and communicates with lightweight mechanisms, often HTTP-based APIs.\nWhat is serverless computing? Serverless computing is a cloud computing model where the cloud provider manages the infrastructure, automatically provisioning and scaling servers as needed. Developers focus on writing code in the form of functions, which are executed in response to events.\nWhat are the main HTTP methods used in RESTful APIs? GET: Retrieve a resource POST: Create a new resource PUT: Update an existing resource DELETE: Remove a resource PATCH: Partially modify a resource What is OAuth and how does it work? OAuth is an open standard for access delegation. It allows users to grant third-party applications access to their resources without sharing their credentials. It works by issuing access tokens to third-party clients with the approval of the resource owner.\nWhat is CORS and why is it important? CORS (Cross-Origin Resource Sharing) is a security mechanism that allows a web page from one domain to request resources from another domain. It’s important for enabling secure cross-origin data transfers in web applications.\nWhat is SQL injection and how can it be prevented? SQL injection is a code injection technique used to attack data-driven applications. It can be prevented by using parameterized queries, prepared statements, and input validation.\nWhat is horizontal scaling vs vertical scaling? Horizontal scaling (scaling out): Adding more machines to a system Vertical scaling (scaling up): Adding more power (CPU, RAM) to an existing machine Explain the concept of Infrastructure as Code (IaC). Infrastructure as Code is the practice of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.\nExample: Configuring a Network using Ansible\nAnsible is another popular IaC tool, often used for configuration management. This example shows how Ansible can configure a network device (e.g., a router) using a playbook.\nExplain the CAP theorem. The CAP theorem states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:\nConsistency Availability Partition tolerance What is Blue/Green Deployments Blue/Green Deployment is a way to update software with almost no downtime:\nYou have two identical environments: Blue and Green. Blue is currently live and serving users. You update the Green environment with the new version. You test Green to make sure it works correctly. You quickly switch all user traffic from Blue to Green. Green is now live, and Blue becomes idle. If something goes wrong, you can easily switch back to Blue.\nThis method reduces risks and makes it easy to roll back if needed, but it does require more server resources.\nWhat tools can be used for data collection? ELK Stack (Elasticsearch, Logstash, Kibana):\nLogstash is a powerful data collection component. It can collect data from various sources and send it to Elasticsearch for search and analysis. Filebeat:\nA lightweight tool for reading data from log files. Particularly suitable for collecting log data already written to files. Can send data to Logstash or Elasticsearch for processing. Fluentd:\nAn open-source data collector. Supports functionality extension through plugins. Can collect data from multiple sources and forward it. Apache Kafka:\nWhile primarily used for stream data processing, its Producer API can be used for data collection. Suitable for high-throughput data processing. Combined with Kafka Streams or other consumer applications, it can implement powerful real-time data processing systems. What are the key principles of BI (Business Intelligence) data reporting? Data Collection:\nFrontend, backend, Database transactions Data Transmission:\nReal-time transmission: Using WebSocket or HTTP requests to send data immediately. Batch transmission: Sending collected data periodically to reduce network overhead. Data Reception:\nAPI endpoints: Providing interfaces to receive reported data. Message queues: Using middleware like Kafka to receive data. Data Processing:\nData cleansing: Removing invalid or duplicate data. Data transformation: Converting raw data into formats suitable for analysis. Data aggregation: Summarizing data to generate statistical information. Data Storage:\nData warehouses: Using systems like Hive or Snowflake to store large volumes of structured data. Time-series databases: Employing databases like InfluxDB for time-series data. Data Analysis:\nOLAP analysis: Using tools like Druid for multi-dimensional data analysis. Machine learning: Applying algorithms to discover patterns and trends in data. Data Visualization:\nDashboards: Creating intuitive data presentation interfaces using tools like Tableau or PowerBI. Report generation: Automatically generating periodic reports. Data Security:\nEncryption: Protecting sensitive data in transit and at rest. Access control: Ensuring only authorized personnel can access the data. Data Governance:\nMetadata management: Maintaining descriptive information about the data. Data quality control: Ensuring data accuracy and consistency. Certainly! I’ll organize the information into an English markdown table format and include the question at the top.\nWhat are the differences between Cookies, Sessions, and Tokens? Feature Cookie Session Token Storage Location Client-side (browser) Server-side Client-side (usually localStorage or sessionStorage) Main Purpose Store small amounts of data on client, remember user preferences or login status Store user session-related information Authentication and authorization, especially in stateless APIs Security Relatively low, can be modified or stolen by client Higher, data stored on server, client only keeps session ID Higher, can contain encrypted information, not easily tampered with Expiration Can set expiration time, supports long-term storage Usually short-lived, expires on user logout or inactivity Flexible, can be set for short-term or long-term validity Cross-domain Support Not supported by default Not supported Supported Scalability Limited in distributed systems Challenges in distributed systems Well-suited for distributed systems and microservices State Stateful Stateful Stateless Size Limit Limited (usually 4KB) Depends on server configuration Can be larger, but should be kept small for efficiency Vulnerability to XSS Vulnerable if not secured properly Less vulnerable (if cookie-based sessions are properly secured) Less vulnerable, but still needs proper handling Implementation Complexity Simple Moderate Can be complex, especially with refresh tokens What are the main differences between single token and double token authentication? Feature Single Token Double Token Structure Uses one token for authentication Uses two tokens: access token and refresh token Token Types Typically just an access token Access token (short-lived) and refresh token (long-lived) Lifespan Usually longer-lived to reduce frequent logins Access token is short-lived, refresh token is long-lived Security Potentially less secure if compromised More secure, access tokens expire quickly, refresh tokens can be invalidated User Experience May require more frequent logins if kept short-lived Provides seamless re-authentication without user intervention Revocation Requires blacklisting or waiting for expiration Can revoke refresh tokens to log out users across all devices Implementation Complexity Simpler to implement More complex, requires managing two types of tokens API Calls Every API call uses the same token Uses access token for API calls, refresh token only for getting new access tokens Storage Typically stored in local storage or session storage Access token in memory, refresh token in secure HTTP-only cookie or secure storage ","wordCount":"2011","inLanguage":"en","datePublished":"2024-09-13T00:00:00Z","dateModified":"2024-09-13T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_system_design/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">System Design</h1><div class=post-meta><span title='2024-09-13 00:00:00 +0000 UTC'>September 13, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-to-solve-cache-penetration aria-label="How to Solve Cache Penetration?">How to Solve Cache Penetration?</a></li><li><a href=#how-to-solve-cache-avalanche aria-label="How to Solve Cache Avalanche?">How to Solve Cache Avalanche?</a></li><li><a href=#what-are-the-communication-methods-between-different-services aria-label="What Are the Communication Methods Between Different Services?">What Are the Communication Methods Between Different Services?</a></li><li><a href=#what-are-the-steps-involved-in-an-rpc-call aria-label="What Are the Steps Involved in an RPC Call?">What Are the Steps Involved in an RPC Call?</a></li><li><a href=#how-can-performance-tuning-be-done-in-rpc-frameworks aria-label="How Can Performance Tuning Be Done in RPC Frameworks?">How Can Performance Tuning Be Done in RPC Frameworks?</a></li><li><a href=#which-rpc-frameworks-have-you-used aria-label="Which RPC Frameworks Have You Used?">Which RPC Frameworks Have You Used?</a></li><li><a href=#describe-circuit-breaker-rate-limiting-downgrading-and-avalanche-effects aria-label="Describe Circuit Breaker, Rate Limiting, Downgrading, and Avalanche Effects">Describe Circuit Breaker, Rate Limiting, Downgrading, and Avalanche Effects</a></li><li><a href=#what-open-source-frameworks-do-you-know-for-circuit-breaking-and-downgrading aria-label="What Open Source Frameworks Do You Know for Circuit Breaking and Downgrading?">What Open Source Frameworks Do You Know for Circuit Breaking and Downgrading?</a></li><li><a href=#what-are-the-differences-between-docker-and-virtual-machines aria-label="What Are the Differences Between Docker and Virtual Machines?">What Are the Differences Between Docker and Virtual Machines?</a></li><li><a href=#what-problems-does-service-mesh-solve aria-label="What Problems Does Service Mesh Solve?">What Problems Does Service Mesh Solve?</a></li><li><a href=#how-does-a-service-mesh-work aria-label="How does a service mesh work?">How does a service mesh work?</a></li><li><a href=#what-technologies-are-related-to-devops aria-label="What Technologies Are Related to DevOps?">What Technologies Are Related to DevOps?</a></li><li><a href=#what-is-microservices-architecture aria-label="What is microservices architecture?">What is microservices architecture?</a></li><li><a href=#what-is-serverless-computing aria-label="What is serverless computing?">What is serverless computing?</a></li><li><a href=#what-are-the-main-http-methods-used-in-restful-apis aria-label="What are the main HTTP methods used in RESTful APIs?">What are the main HTTP methods used in RESTful APIs?</a></li><li><a href=#what-is-oauth-and-how-does-it-work aria-label="What is OAuth and how does it work?">What is OAuth and how does it work?</a></li><li><a href=#what-is-cors-and-why-is-it-important aria-label="What is CORS and why is it important?">What is CORS and why is it important?</a></li><li><a href=#what-is-sql-injection-and-how-can-it-be-prevented aria-label="What is SQL injection and how can it be prevented?">What is SQL injection and how can it be prevented?</a></li><li><a href=#what-is-horizontal-scaling-vs-vertical-scaling aria-label="What is horizontal scaling vs vertical scaling?">What is horizontal scaling vs vertical scaling?</a></li><li><a href=#explain-the-concept-of-infrastructure-as-code-iac aria-label="Explain the concept of Infrastructure as Code (IaC).">Explain the concept of Infrastructure as Code (IaC).</a></li><li><a href=#explain-the-cap-theorem aria-label="Explain the CAP theorem.">Explain the CAP theorem.</a></li><li><a href=#what-is-bluegreen-deployments aria-label="What is Blue/Green Deployments">What is Blue/Green Deployments</a></li><li><a href=#what-tools-can-be-used-for-data-collection aria-label="What tools can be used for data collection?">What tools can be used for data collection?</a></li><li><a href=#what-are-the-key-principles-of-bi-business-intelligence-data-reporting aria-label="What are the key principles of BI (Business Intelligence) data reporting?">What are the key principles of BI (Business Intelligence) data reporting?</a></li><li><a href=#what-are-the-differences-between-cookies-sessions-and-tokens aria-label="What are the differences between Cookies, Sessions, and Tokens?">What are the differences between Cookies, Sessions, and Tokens?</a></li><li><a href=#what-are-the-main-differences-between-single-token-and-double-token-authentication aria-label="What are the main differences between single token and double token authentication?">What are the main differences between single token and double token authentication?</a></li></ul></div></details></div><div class=post-content><h2 id=how-to-solve-cache-penetration>How to Solve Cache Penetration?<a hidden class=anchor aria-hidden=true href=#how-to-solve-cache-penetration>#</a></h2><p>Cache penetration occurs when requests for non-existent data bypass the cache and hit the database repeatedly. Solutions include:</p><ul><li><strong>Caching Empty Results</strong>: Store empty results for non-existent keys with a short expiration time.</li><li><strong>Bloom Filters</strong>: Use a Bloom filter to check if a key exists before querying the database.</li><li><strong>Rate Limiting</strong>: Limit requests for certain keys to prevent overwhelming the database with requests for non-existent data.</li></ul><h2 id=how-to-solve-cache-avalanche>How to Solve Cache Avalanche?<a hidden class=anchor aria-hidden=true href=#how-to-solve-cache-avalanche>#</a></h2><p>Cache avalanche involves a massive number of database hits due to the simultaneous expiration of many cache entries or a cache server failure.</p><p>While rate limiting (a solution for cache penetration) can help <em>mitigate</em> the impact of a cache avalanche by reducing the load on the database, it doesn&rsquo;t prevent the avalanche itself. The core of solving a cache avalanche lies in different strategies:</p><ul><li><strong>Staggered Expiration:</strong> Instead of setting the same expiration time for all cache entries, vary the expiration times slightly to prevent mass simultaneous expirations.</li><li><strong>Cache Clustering/Redundancy:</strong> Use multiple cache servers to distribute the load and provide redundancy. If one server fails, others can continue serving requests.</li><li><strong>Cache Pre-warming:</strong> For frequently accessed data, proactively load it into the cache before it&rsquo;s requested.</li><li><strong>Circuit Breakers:</strong> Implement circuit breakers to prevent cascading failures. If the database becomes overloaded, the circuit breaker can temporarily stop sending requests to it, preventing further overload.</li></ul><h2 id=what-are-the-communication-methods-between-different-services>What Are the Communication Methods Between Different Services?<a hidden class=anchor aria-hidden=true href=#what-are-the-communication-methods-between-different-services>#</a></h2><p>Different services can communicate through various methods:</p><ul><li><strong>HTTP/REST APIs</strong>: Synchronous communication using standard HTTP methods.</li></ul><p><img loading=lazy src=/img/0_system_design.png alt></p><ul><li><strong>gRPC</strong>: High-performance RPC framework using HTTP/2.</li></ul><p><img loading=lazy src=/img/0_system_design-1.png alt></p><ul><li><strong>Message Queues</strong>: Asynchronous communication via message brokers like RabbitMQ or Kafka.</li></ul><p><img loading=lazy src=/img/0_system_design-2.png alt></p><ul><li><strong>WebSockets</strong>: For real-time bidirectional communication between clients and servers.</li></ul><p><img loading=lazy src=/img/0_system_design-3.png alt></p><h2 id=what-are-the-steps-involved-in-an-rpc-call>What Are the Steps Involved in an RPC Call?<a hidden class=anchor aria-hidden=true href=#what-are-the-steps-involved-in-an-rpc-call>#</a></h2><p>An RPC call typically involves these steps:</p><ol><li>The client sends an RPC request to the server.</li><li>The client stub serializes the request into a suitable format (e.g., JSON or Protobuf).</li><li>The request is sent over the network to the server.</li><li>The server receives and deserializes the request.</li><li>The server processes the request and prepares a response.</li><li>The response is serialized and sent back to the client.</li><li>The client stub deserializes the response for use.</li></ol><h2 id=how-can-performance-tuning-be-done-in-rpc-frameworks>How Can Performance Tuning Be Done in RPC Frameworks?<a hidden class=anchor aria-hidden=true href=#how-can-performance-tuning-be-done-in-rpc-frameworks>#</a></h2><p>To optimize performance in RPC frameworks:</p><ul><li>Use efficient serialization formats (e.g., Protobuf).</li><li>Implement connection pooling to reuse connections.</li><li>Use asynchronous calls where possible to avoid blocking.</li><li>Optimize network latency through compression or batching requests.</li></ul><h2 id=which-rpc-frameworks-have-you-used>Which RPC Frameworks Have You Used?<a hidden class=anchor aria-hidden=true href=#which-rpc-frameworks-have-you-used>#</a></h2><p>Commonly used RPC frameworks include:</p><ul><li><strong>gRPC</strong>: A modern high-performance framework developed by Google.</li><li><strong>Apache Thrift</strong>: A cross-language framework developed by Facebook.</li><li><strong>Dubbo</strong>: A Java-based RPC framework from Alibaba.</li><li><strong>JSON-RPC</strong>: A remote procedure call protocol encoded in JSON.</li></ul><h2 id=describe-circuit-breaker-rate-limiting-downgrading-and-avalanche-effects>Describe Circuit Breaker, Rate Limiting, Downgrading, and Avalanche Effects<a hidden class=anchor aria-hidden=true href=#describe-circuit-breaker-rate-limiting-downgrading-and-avalanche-effects>#</a></h2><ol><li><strong>Circuit Breaker</strong>: Prevents repeated calls to failing services by temporarily blocking requests until they recover.</li><li><strong>Rate Limiting</strong>: Controls how often users can access resources within a specified timeframe to prevent abuse or overload.</li><li><strong>Downgrading</strong>: Provides fallback mechanisms when certain features are unavailable or degraded due to failures.</li><li><strong>Avalanche Effect</strong>: Occurs when multiple dependent services fail simultaneously due to cascading failures from one service&rsquo;s downtime.</li></ol><h2 id=what-open-source-frameworks-do-you-know-for-circuit-breaking-and-downgrading>What Open Source Frameworks Do You Know for Circuit Breaking and Downgrading?<a hidden class=anchor aria-hidden=true href=#what-open-source-frameworks-do-you-know-for-circuit-breaking-and-downgrading>#</a></h2><p>Notable open-source frameworks include:</p><ul><li><strong>Hystrix</strong>: A circuit breaker library from Netflix designed for fault tolerance in distributed systems.</li><li><strong>Resilience4j</strong>: A lightweight alternative for Java applications providing circuit breaking capabilities.</li><li><strong>Sentinel</strong>: An open-source project from Alibaba that provides circuit breaking and rate limiting features.</li></ul><h2 id=what-are-the-differences-between-docker-and-virtual-machines>What Are the Differences Between Docker and Virtual Machines?<a hidden class=anchor aria-hidden=true href=#what-are-the-differences-between-docker-and-virtual-machines>#</a></h2><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>Docker</th><th style=text-align:left>Virtual Machine</th></tr></thead><tbody><tr><td style=text-align:left>Operating System</td><td style=text-align:left>Shares host OS kernel</td><td style=text-align:left>Requires separate OS per VM</td></tr><tr><td style=text-align:left>Performance</td><td style=text-align:left>Lightweight with faster startup times</td><td style=text-align:left>Heavier due to full OS overhead</td></tr><tr><td style=text-align:left>Portability</td><td style=text-align:left>Highly portable across environments</td><td style=text-align:left>Less portable due to size</td></tr><tr><td style=text-align:left>Resource Usage</td><td style=text-align:left>More efficient resource utilization</td><td style=text-align:left>Consumes more resources</td></tr></tbody></table><h2 id=what-problems-does-service-mesh-solve>What Problems Does Service Mesh Solve?<a hidden class=anchor aria-hidden=true href=#what-problems-does-service-mesh-solve>#</a></h2><p>Service mesh addresses challenges in microservices architectures such as:</p><ul><li>Service discovery</li><li>Load balancing</li><li>Traffic management</li><li>Security (e.g., authentication)</li><li>Observability (e.g., monitoring and tracing)</li></ul><p>By abstracting these concerns away from application code, service mesh allows developers to focus on business logic while ensuring robust inter-service communication.</p><p><img loading=lazy src=/img/0_system_design-4.png alt></p><h2 id=how-does-a-service-mesh-work>How does a service mesh work?<a hidden class=anchor aria-hidden=true href=#how-does-a-service-mesh-work>#</a></h2><p>A service mesh simplifies inter-service communication in a microservices architecture by abstracting it into a dedicated infrastructure layer. This layer uses network proxies, often called sidecars, deployed alongside each service. All traffic flows through these proxies.</p><p><img loading=lazy src=/img/0_system_design-5.png alt></p><p>The mesh comprises two key components:</p><ul><li><p><strong>Data Plane:</strong> This consists of the sidecar proxies. They intercept requests, establish secure connections, and handle low-level messaging, including features like circuit breaking and retries. Core functionality such as load balancing, service discovery, and routing resides here.</p></li><li><p><strong>Control Plane:</strong> This acts as the central management layer. Administrators use it to define and configure services, including endpoints, routing rules, load balancing, and security settings. The control plane distributes this configuration to the data plane proxies, allowing for dynamic adjustments without service restarts. It typically includes a service registry, automatic service discovery, and telemetry data collection.</p></li></ul><p><img loading=lazy src=/img/0_system_design-6.png alt></p><h2 id=what-technologies-are-related-to-devops>What Technologies Are Related to DevOps?<a hidden class=anchor aria-hidden=true href=#what-technologies-are-related-to-devops>#</a></h2><p>Key technologies related to DevOps include:</p><ol><li><strong>Version Control Systems</strong>: Git, SVN</li><li><strong>Continuous Integration/Continuous Deployment (CI/CD)</strong>: Jenkins, GitLab CI</li><li><strong>Containerization</strong>: Docker, Kubernetes</li><li><strong>Configuration Management Tools</strong>: Ansible, Puppet</li><li><strong>Monitoring Tools</strong>: Prometheus, Grafana</li><li><strong>Infrastructure as Code (IaC)</strong>: Terraform</li></ol><h2 id=what-is-microservices-architecture>What is microservices architecture?<a hidden class=anchor aria-hidden=true href=#what-is-microservices-architecture>#</a></h2><p>Microservices architecture is an approach to developing a single application as a suite of small, independently deployable services. Each service runs in its own process and communicates with lightweight mechanisms, often HTTP-based APIs.</p><h2 id=what-is-serverless-computing>What is serverless computing?<a hidden class=anchor aria-hidden=true href=#what-is-serverless-computing>#</a></h2><p>Serverless computing is a cloud computing model where the cloud provider manages the infrastructure, automatically provisioning and scaling servers as needed. Developers focus on writing code in the form of functions, which are executed in response to events.</p><h2 id=what-are-the-main-http-methods-used-in-restful-apis>What are the main HTTP methods used in RESTful APIs?<a hidden class=anchor aria-hidden=true href=#what-are-the-main-http-methods-used-in-restful-apis>#</a></h2><ul><li>GET: Retrieve a resource</li><li>POST: Create a new resource</li><li>PUT: Update an existing resource</li><li>DELETE: Remove a resource</li><li>PATCH: Partially modify a resource</li></ul><h2 id=what-is-oauth-and-how-does-it-work>What is OAuth and how does it work?<a hidden class=anchor aria-hidden=true href=#what-is-oauth-and-how-does-it-work>#</a></h2><p>OAuth is an open standard for access delegation. It allows users to grant third-party applications access to their resources without sharing their credentials. It works by issuing access tokens to third-party clients with the approval of the resource owner.</p><h2 id=what-is-cors-and-why-is-it-important>What is CORS and why is it important?<a hidden class=anchor aria-hidden=true href=#what-is-cors-and-why-is-it-important>#</a></h2><p>CORS (Cross-Origin Resource Sharing) is a security mechanism that allows a web page from one domain to request resources from another domain. It&rsquo;s important for enabling secure cross-origin data transfers in web applications.</p><h2 id=what-is-sql-injection-and-how-can-it-be-prevented>What is SQL injection and how can it be prevented?<a hidden class=anchor aria-hidden=true href=#what-is-sql-injection-and-how-can-it-be-prevented>#</a></h2><p>SQL injection is a code injection technique used to attack data-driven applications. It can be prevented by using parameterized queries, prepared statements, and input validation.</p><h2 id=what-is-horizontal-scaling-vs-vertical-scaling>What is horizontal scaling vs vertical scaling?<a hidden class=anchor aria-hidden=true href=#what-is-horizontal-scaling-vs-vertical-scaling>#</a></h2><ul><li>Horizontal scaling (scaling out): Adding more machines to a system</li><li>Vertical scaling (scaling up): Adding more power (CPU, RAM) to an existing machine</li></ul><h2 id=explain-the-concept-of-infrastructure-as-code-iac>Explain the concept of Infrastructure as Code (IaC).<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-infrastructure-as-code-iac>#</a></h2><p>Infrastructure as Code is the practice of managing and provisioning computing infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.</p><p>Example: Configuring a Network using Ansible</p><p>Ansible is another popular IaC tool, often used for configuration management. This example shows how Ansible can configure a network device (e.g., a router) using a playbook.</p><h2 id=explain-the-cap-theorem>Explain the CAP theorem.<a hidden class=anchor aria-hidden=true href=#explain-the-cap-theorem>#</a></h2><p>The CAP theorem states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three guarantees:</p><ul><li>Consistency</li><li>Availability</li><li>Partition tolerance</li></ul><h2 id=what-is-bluegreen-deployments>What is Blue/Green Deployments<a hidden class=anchor aria-hidden=true href=#what-is-bluegreen-deployments>#</a></h2><p>Blue/Green Deployment is a way to update software with almost no downtime:</p><ol><li>You have two identical environments: Blue and Green.</li><li>Blue is currently live and serving users.</li><li>You update the Green environment with the new version.</li><li>You test Green to make sure it works correctly.</li><li>You quickly switch all user traffic from Blue to Green.</li><li>Green is now live, and Blue becomes idle.</li></ol><p>If something goes wrong, you can easily switch back to Blue.</p><p>This method reduces risks and makes it easy to roll back if needed, but it does require more server resources.</p><h2 id=what-tools-can-be-used-for-data-collection>What tools can be used for data collection?<a hidden class=anchor aria-hidden=true href=#what-tools-can-be-used-for-data-collection>#</a></h2><ol><li><p>ELK Stack (Elasticsearch, Logstash, Kibana):</p><ul><li>Logstash is a powerful data collection component.</li><li>It can collect data from various sources and send it to Elasticsearch for search and analysis.</li></ul></li><li><p>Filebeat:</p><ul><li>A lightweight tool for reading data from log files.</li><li>Particularly suitable for collecting log data already written to files.</li><li>Can send data to Logstash or Elasticsearch for processing.</li></ul></li><li><p>Fluentd:</p><ul><li>An open-source data collector.</li><li>Supports functionality extension through plugins.</li><li>Can collect data from multiple sources and forward it.</li></ul></li><li><p>Apache Kafka:</p><ul><li>While primarily used for stream data processing, its Producer API can be used for data collection.</li><li>Suitable for high-throughput data processing.</li><li>Combined with Kafka Streams or other consumer applications, it can implement powerful real-time data processing systems.</li></ul></li></ol><h2 id=what-are-the-key-principles-of-bi-business-intelligence-data-reporting>What are the key principles of BI (Business Intelligence) data reporting?<a hidden class=anchor aria-hidden=true href=#what-are-the-key-principles-of-bi-business-intelligence-data-reporting>#</a></h2><ol><li><p>Data Collection:</p><ul><li>Frontend, backend, Database transactions</li></ul></li><li><p>Data Transmission:</p><ul><li>Real-time transmission: Using WebSocket or HTTP requests to send data immediately.</li><li>Batch transmission: Sending collected data periodically to reduce network overhead.</li></ul></li><li><p>Data Reception:</p><ul><li>API endpoints: Providing interfaces to receive reported data.</li><li>Message queues: Using middleware like Kafka to receive data.</li></ul></li><li><p>Data Processing:</p><ul><li>Data cleansing: Removing invalid or duplicate data.</li><li>Data transformation: Converting raw data into formats suitable for analysis.</li><li>Data aggregation: Summarizing data to generate statistical information.</li></ul></li><li><p>Data Storage:</p><ul><li>Data warehouses: Using systems like Hive or Snowflake to store large volumes of structured data.</li><li>Time-series databases: Employing databases like InfluxDB for time-series data.</li></ul></li><li><p>Data Analysis:</p><ul><li>OLAP analysis: Using tools like Druid for multi-dimensional data analysis.</li><li>Machine learning: Applying algorithms to discover patterns and trends in data.</li></ul></li><li><p>Data Visualization:</p><ul><li>Dashboards: Creating intuitive data presentation interfaces using tools like Tableau or PowerBI.</li><li>Report generation: Automatically generating periodic reports.</li></ul></li><li><p>Data Security:</p><ul><li>Encryption: Protecting sensitive data in transit and at rest.</li><li>Access control: Ensuring only authorized personnel can access the data.</li></ul></li><li><p>Data Governance:</p></li></ol><ul><li>Metadata management: Maintaining descriptive information about the data.</li><li>Data quality control: Ensuring data accuracy and consistency.</li></ul><p>Certainly! I&rsquo;ll organize the information into an English markdown table format and include the question at the top.</p><h2 id=what-are-the-differences-between-cookies-sessions-and-tokens>What are the differences between Cookies, Sessions, and Tokens?<a hidden class=anchor aria-hidden=true href=#what-are-the-differences-between-cookies-sessions-and-tokens>#</a></h2><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>Cookie</th><th style=text-align:left>Session</th><th style=text-align:left>Token</th></tr></thead><tbody><tr><td style=text-align:left>Storage Location</td><td style=text-align:left>Client-side (browser)</td><td style=text-align:left>Server-side</td><td style=text-align:left>Client-side (usually localStorage or sessionStorage)</td></tr><tr><td style=text-align:left>Main Purpose</td><td style=text-align:left>Store small amounts of data on client, remember user preferences or login status</td><td style=text-align:left>Store user session-related information</td><td style=text-align:left>Authentication and authorization, especially in stateless APIs</td></tr><tr><td style=text-align:left>Security</td><td style=text-align:left>Relatively low, can be modified or stolen by client</td><td style=text-align:left>Higher, data stored on server, client only keeps session ID</td><td style=text-align:left>Higher, can contain encrypted information, not easily tampered with</td></tr><tr><td style=text-align:left>Expiration</td><td style=text-align:left>Can set expiration time, supports long-term storage</td><td style=text-align:left>Usually short-lived, expires on user logout or inactivity</td><td style=text-align:left>Flexible, can be set for short-term or long-term validity</td></tr><tr><td style=text-align:left>Cross-domain Support</td><td style=text-align:left>Not supported by default</td><td style=text-align:left>Not supported</td><td style=text-align:left>Supported</td></tr><tr><td style=text-align:left>Scalability</td><td style=text-align:left>Limited in distributed systems</td><td style=text-align:left>Challenges in distributed systems</td><td style=text-align:left>Well-suited for distributed systems and microservices</td></tr><tr><td style=text-align:left>State</td><td style=text-align:left>Stateful</td><td style=text-align:left>Stateful</td><td style=text-align:left>Stateless</td></tr><tr><td style=text-align:left>Size Limit</td><td style=text-align:left>Limited (usually 4KB)</td><td style=text-align:left>Depends on server configuration</td><td style=text-align:left>Can be larger, but should be kept small for efficiency</td></tr><tr><td style=text-align:left>Vulnerability to XSS</td><td style=text-align:left>Vulnerable if not secured properly</td><td style=text-align:left>Less vulnerable (if cookie-based sessions are properly secured)</td><td style=text-align:left>Less vulnerable, but still needs proper handling</td></tr><tr><td style=text-align:left>Implementation Complexity</td><td style=text-align:left>Simple</td><td style=text-align:left>Moderate</td><td style=text-align:left>Can be complex, especially with refresh tokens</td></tr></tbody></table><h2 id=what-are-the-main-differences-between-single-token-and-double-token-authentication>What are the main differences between single token and double token authentication?<a hidden class=anchor aria-hidden=true href=#what-are-the-main-differences-between-single-token-and-double-token-authentication>#</a></h2><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>Single Token</th><th style=text-align:left>Double Token</th></tr></thead><tbody><tr><td style=text-align:left>Structure</td><td style=text-align:left>Uses one token for authentication</td><td style=text-align:left>Uses two tokens: access token and refresh token</td></tr><tr><td style=text-align:left>Token Types</td><td style=text-align:left>Typically just an access token</td><td style=text-align:left>Access token (short-lived) and refresh token (long-lived)</td></tr><tr><td style=text-align:left>Lifespan</td><td style=text-align:left>Usually longer-lived to reduce frequent logins</td><td style=text-align:left>Access token is short-lived, refresh token is long-lived</td></tr><tr><td style=text-align:left>Security</td><td style=text-align:left>Potentially less secure if compromised</td><td style=text-align:left>More secure, access tokens expire quickly, refresh tokens can be invalidated</td></tr><tr><td style=text-align:left>User Experience</td><td style=text-align:left>May require more frequent logins if kept short-lived</td><td style=text-align:left>Provides seamless re-authentication without user intervention</td></tr><tr><td style=text-align:left>Revocation</td><td style=text-align:left>Requires blacklisting or waiting for expiration</td><td style=text-align:left>Can revoke refresh tokens to log out users across all devices</td></tr><tr><td style=text-align:left>Implementation Complexity</td><td style=text-align:left>Simpler to implement</td><td style=text-align:left>More complex, requires managing two types of tokens</td></tr><tr><td style=text-align:left>API Calls</td><td style=text-align:left>Every API call uses the same token</td><td style=text-align:left>Uses access token for API calls, refresh token only for getting new access tokens</td></tr><tr><td style=text-align:left>Storage</td><td style=text-align:left>Typically stored in local storage or session storage</td><td style=text-align:left>Access token in memory, refresh token in secure HTTP-only cookie or secure storage</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/systemdesign/>SystemDesign</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>