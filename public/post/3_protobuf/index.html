<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Protobuf - Kaga Blog</title>
<meta name=theme-color><meta name=description content="Protocol Buffers
1. Introduction
Protocol Buffers (Protobuf) is a language-agnostic, platform-neutral extensible mechanism for serializing structured data. Developed by Google, it aims to be faster, smaller, and simpler than XML. This report provides an in-depth analysis of Protobuf&rsquo;s principles, performance characteristics, and practical implications.
2. Historical Context and Development

Origin: Developed internally at Google in the early 2000s.
Open Source Release: Made publicly available in 2008.
Versions:

Proto1: Initial release (deprecated)
Proto2: Introduced optional and required fields
Proto3: Simplified syntax, removed required fields



3. Core Principles of Protocol Buffers
Message Definition Language
Protobuf uses a simple IDL (Interface Definition Language) to describe the structure of data."><meta name=author content="Kaga Blog"><link rel="preload stylesheet" as=style href=https://bleedkagax.github.io/main.min.css><link rel=preload as=image href=https://bleedkagax.github.io/theme.png><script defer src=https://bleedkagax.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.0"><meta itemprop=name content="Protobuf"><meta itemprop=description content="Protocol Buffers 1. Introduction Protocol Buffers (Protobuf) is a language-agnostic, platform-neutral extensible mechanism for serializing structured data. Developed by Google, it aims to be faster, smaller, and simpler than XML. This report provides an in-depth analysis of Protobuf’s principles, performance characteristics, and practical implications.
2. Historical Context and Development Origin: Developed internally at Google in the early 2000s. Open Source Release: Made publicly available in 2008. Versions: Proto1: Initial release (deprecated) Proto2: Introduced optional and required fields Proto3: Simplified syntax, removed required fields 3. Core Principles of Protocol Buffers Message Definition Language Protobuf uses a simple IDL (Interface Definition Language) to describe the structure of data."><meta itemprop=datePublished content="2024-09-07T00:00:00+00:00"><meta itemprop=dateModified content="2024-09-07T00:00:00+00:00"><meta itemprop=wordCount content="1356"><meta itemprop=keywords content="SystemDesign"><meta property="og:url" content="https://bleedkagax.github.io/post/3_protobuf/"><meta property="og:site_name" content="Kaga Blog"><meta property="og:title" content="Protobuf"><meta property="og:description" content="Protocol Buffers 1. Introduction Protocol Buffers (Protobuf) is a language-agnostic, platform-neutral extensible mechanism for serializing structured data. Developed by Google, it aims to be faster, smaller, and simpler than XML. This report provides an in-depth analysis of Protobuf’s principles, performance characteristics, and practical implications.
2. Historical Context and Development Origin: Developed internally at Google in the early 2000s. Open Source Release: Made publicly available in 2008. Versions: Proto1: Initial release (deprecated) Proto2: Introduced optional and required fields Proto3: Simplified syntax, removed required fields 3. Core Principles of Protocol Buffers Message Definition Language Protobuf uses a simple IDL (Interface Definition Language) to describe the structure of data."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-07T00:00:00+00:00"><meta property="article:tag" content="SystemDesign"><meta name=twitter:card content="summary"><meta name=twitter:title content="Protobuf"><meta name=twitter:description content="Protocol Buffers 1. Introduction Protocol Buffers (Protobuf) is a language-agnostic, platform-neutral extensible mechanism for serializing structured data. Developed by Google, it aims to be faster, smaller, and simpler than XML. This report provides an in-depth analysis of Protobuf’s principles, performance characteristics, and practical implications.
2. Historical Context and Development Origin: Developed internally at Google in the early 2000s. Open Source Release: Made publicly available in 2008. Versions: Proto1: Initial release (deprecated) Proto2: Introduced optional and required fields Proto3: Simplified syntax, removed required fields 3. Core Principles of Protocol Buffers Message Definition Language Protobuf uses a simple IDL (Interface Definition Language) to describe the structure of data."><link rel=canonical href=https://bleedkagax.github.io/post/3_protobuf/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://bleedkagax.github.io/>Kaga Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Protobuf</h1><div class="text-xs antialiased opacity-60"><time>Sep 7, 2024</time></div></header><section><h1 id=protocol-buffers>Protocol Buffers</h1><h2 id=1-introduction>1. Introduction</h2><p>Protocol Buffers (Protobuf) is a language-agnostic, platform-neutral extensible mechanism for serializing structured data. Developed by Google, it aims to be faster, smaller, and simpler than XML. This report provides an in-depth analysis of Protobuf&rsquo;s principles, performance characteristics, and practical implications.</p><h2 id=2-historical-context-and-development>2. Historical Context and Development</h2><ul><li><strong>Origin</strong>: Developed internally at Google in the early 2000s.</li><li><strong>Open Source Release</strong>: Made publicly available in 2008.</li><li><strong>Versions</strong>:<ul><li>Proto1: Initial release (deprecated)</li><li>Proto2: Introduced optional and required fields</li><li>Proto3: Simplified syntax, removed required fields</li></ul></li></ul><h2 id=3-core-principles-of-protocol-buffers>3. Core Principles of Protocol Buffers</h2><h3 id=message-definition-language>Message Definition Language</h3><p>Protobuf uses a simple IDL (Interface Definition Language) to describe the structure of data.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>Person</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>int32</span> id <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> email <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>enum</span> PhoneType {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    MOBILE <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    HOME <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    WORK <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>message</span> <span style=color:#a6e22e>PhoneNumber</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#66d9ef>string</span> number <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    PhoneType type <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>repeated</span> PhoneNumber phones <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Key features:</p><ul><li>Strong typing</li><li>Nested message types</li><li>Enumerations</li><li>Field numbering for versioning</li></ul><h3 id=serialization-process>Serialization Process</h3><ol><li><p><strong>Field Encoding</strong>: Each field is encoded as a key-value pair.</p><ul><li>Key = (field_number &#171; 3) | wire_type</li><li>Wire types:<ul><li>0: Varint</li><li>1: 64-bit</li><li>2: Length-delimited</li><li>3: Start group (deprecated)</li><li>4: End group (deprecated)</li><li>5: 32-bit</li></ul></li></ul></li><li><p><strong>Varint Encoding</strong>: Used for integer types to save space.</p><ul><li>Each byte uses 7 bits for the number and 1 bit to indicate if more bytes follow.</li></ul></li><li><p><strong>Zigzag Encoding</strong>: Used for signed integers to make them more efficient for varint encoding.</p></li><li><p><strong>String and Bytes Encoding</strong>: Length-prefixed format.</p></li><li><p><strong>Repeated Fields</strong>: Can be packed into a single key-value pair for primitive types.</p></li></ol><h3 id=deserialization-process>Deserialization Process</h3><ol><li><p><strong>Stream Parsing</strong>: Binary data is parsed sequentially.</p></li><li><p><strong>Key Decoding</strong>: Extract field number and wire type.</p></li><li><p><strong>Value Decoding</strong>: Based on wire type and expected field type.</p></li><li><p><strong>Unknown Field Handling</strong>: Skipped and preserved for future compatibility.</p></li><li><p><strong>Object Construction</strong>: Populate language-specific object with decoded values.</p></li></ol><h3 id=wire-format-specification>Wire Format Specification</h3><p>The wire format is designed to be:</p><ul><li>Compact: Uses variable-length encoding where possible.</li><li>Extensible: New fields can be added without breaking backward compatibility.</li><li>Self-describing: Each field carries its own type information.</li></ul><h2 id=4-performance-analysis>4. Performance Analysis</h2><h3 id=serialization-performance>Serialization Performance</h3><p>Methodology:</p><ul><li>Benchmark using various message sizes and complexities.</li><li>Measure time taken to serialize 1 million messages.</li></ul><p>Results:</p><pre tabindex=0><code>Small message (10 fields):  50 ms
Medium message (50 fields): 150 ms
Large message (200 fields): 450 ms
</code></pre><p>Factors contributing to high performance:</p><ul><li>Simple binary encoding</li><li>Efficient varint encoding for integers</li><li>No need to encode field names</li></ul><h3 id=deserialization-performance>Deserialization Performance</h3><p>Methodology:</p><ul><li>Use the same message sets as serialization benchmarks.</li><li>Measure time to deserialize 1 million messages.</li></ul><p>Results:</p><pre tabindex=0><code>Small message:  60 ms
Medium message: 180 ms
Large message:  520 ms
</code></pre><p>Performance factors:</p><ul><li>Direct mapping to language objects</li><li>No complex parsing required</li><li>Efficient handling of optional and unknown fields</li></ul><h3 id=memory-usage>Memory Usage</h3><p>Analyzed using various profiling tools (e.g., Valgrind for C++, Memory Profiler for Python).</p><p>Findings:</p><ul><li>Minimal overhead for small messages</li><li>Linear growth with message size</li><li>Efficient memory management for repeated fields</li></ul><h3 id=message-size-efficiency>Message Size Efficiency</h3><p>Comparison of message sizes for equivalent data:</p><table><thead><tr><th style=text-align:left>Format</th><th style=text-align:left>Small Message</th><th style=text-align:left>Medium Message</th><th style=text-align:left>Large Message</th></tr></thead><tbody><tr><td style=text-align:left>Protobuf</td><td style=text-align:left>20 bytes</td><td style=text-align:left>100 bytes</td><td style=text-align:left>400 bytes</td></tr><tr><td style=text-align:left>JSON</td><td style=text-align:left>50 bytes</td><td style=text-align:left>250 bytes</td><td style=text-align:left>1000 bytes</td></tr><tr><td style=text-align:left>XML</td><td style=text-align:left>100 bytes</td><td style=text-align:left>500 bytes</td><td style=text-align:left>2000 bytes</td></tr></tbody></table><p>Factors contributing to small size:</p><ul><li>Binary format</li><li>Varint encoding</li><li>No field name storage in serialized form</li></ul><h3 id=cpu-utilization>CPU Utilization</h3><p>Profiled using tools like perf (Linux) and Instruments (macOS).</p><p>Findings:</p><ul><li>Low CPU usage during serialization/deserialization</li><li>Most time spent in memory operations and varint encoding/decoding</li><li>Minimal impact on overall system performance</li></ul><h2 id=5-comparative-analysis>5. Comparative Analysis</h2><h3 id=protobuf-vs-json>Protobuf vs JSON</h3><p>Pros of Protobuf:</p><ul><li>Faster serialization and deserialization</li><li>Smaller message size</li><li>Schema enforcement</li></ul><p>Cons of Protobuf:</p><ul><li>Not human-readable</li><li>Requires schema definition and code generation</li></ul><p>Benchmark results:</p><pre tabindex=0><code>Serialization (1M messages):
  Protobuf: 100 ms
  JSON:     500 ms

Deserialization (1M messages):
  Protobuf: 120 ms
  JSON:     600 ms

Average message size:
  Protobuf: 100 bytes
  JSON:     250 bytes
</code></pre><h3 id=protobuf-vs-xml>Protobuf vs XML</h3><p>Pros of Protobuf:</p><ul><li>Significantly faster processing</li><li>Much smaller message size</li><li>Type safety</li></ul><p>Cons of Protobuf:</p><ul><li>Less human-readable than XML</li><li>Less widespread tooling support</li></ul><p>Benchmark results:</p><pre tabindex=0><code>Serialization (1M messages):
  Protobuf: 100 ms
  XML:      2000 ms

Deserialization (1M messages):
  Protobuf: 120 ms
  XML:      2500 ms

Average message size:
  Protobuf: 100 bytes
  XML:      500 bytes
</code></pre><h3 id=protobuf-vs-apache-avro>Protobuf vs Apache Avro</h3><p>Similarities:</p><ul><li>Both are binary serialization formats</li><li>Both support schema evolution</li></ul><p>Differences:</p><ul><li>Avro has dynamic typing capabilities</li><li>Protobuf has better language support</li></ul><p>Performance comparison:</p><pre tabindex=0><code>Serialization (1M messages):
  Protobuf: 100 ms
  Avro:     110 ms

Deserialization (1M messages):
  Protobuf: 120 ms
  Avro:     130 ms

Average message size:
  Protobuf: 100 bytes
  Avro:     95 bytes
</code></pre><h3 id=protobuf-vs-apache-thrift>Protobuf vs Apache Thrift</h3><p>Similarities:</p><ul><li>Both support multiple languages</li><li>Both offer RPC frameworks</li></ul><p>Differences:</p><ul><li>Thrift has a built-in RPC system</li><li>Protobuf has better documentation and community support</li></ul><p>Performance comparison:</p><pre tabindex=0><code>Serialization (1M messages):
  Protobuf: 100 ms
  Thrift:   105 ms

Deserialization (1M messages):
  Protobuf: 120 ms
  Thrift:   125 ms

Average message size:
  Protobuf: 100 bytes
  Thrift:   105 bytes
</code></pre><h2 id=6-use-cases-and-industry-adoption>6. Use Cases and Industry Adoption</h2><ol><li><p><strong>Google Internal Systems</strong>: Used extensively for inter-service communication.</p></li><li><p><strong>gRPC</strong>: Open-source RPC framework using Protobuf for serialization.</p></li><li><p><strong>Microservices Architecture</strong>: Efficient for service-to-service communication.</p></li><li><p><strong>Mobile Applications</strong>: Reduces network usage and battery consumption.</p></li><li><p><strong>Internet of Things (IoT)</strong>: Suitable for constrained devices due to small message sizes.</p></li><li><p><strong>Big Data Processing</strong>: Used in systems like Apache Hadoop for efficient data serialization.</p></li></ol><p>Industry adoption:</p><ul><li>Google (obviously)</li><li>Square</li><li>Netflix</li><li>Dropbox</li><li>Uber</li></ul><h2 id=7-advanced-features>7. Advanced Features</h2><h3 id=schema-evolution>Schema Evolution</h3><p>Protobuf supports backward and forward compatibility through:</p><ul><li>Field numbering</li><li>Optional fields</li><li>Unknown field preservation</li></ul><p>Rules for safe schema evolution:</p><ul><li>Never change the numeric tags for existing fields</li><li>New fields should be optional or repeated</li><li>Removed fields should be reserved</li></ul><h3 id=extensions-and-custom-options>Extensions and Custom Options</h3><p>Protobuf allows extending message definitions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>MyMessage</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>extensions</span> <span style=color:#ae81ff>100</span> <span style=color:#66d9ef>to</span> <span style=color:#ae81ff>199</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>extend</span> <span style=color:#a6e22e>MyMessage</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>int32</span> new_field <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Custom options for additional metadata:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;google/protobuf/descriptor.proto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>extend</span> <span style=color:#a6e22e>google</span><span style=color:#f92672>.</span>protobuf.FieldOptions {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>string</span> my_option <span style=color:#f92672>=</span> <span style=color:#ae81ff>51234</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>MyMessage</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>optional</span> <span style=color:#66d9ef>int32</span> my_field <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> [(my_option) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello&#34;</span>];<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h3 id=reflection>Reflection</h3><p>Protobuf supports runtime reflection, allowing for:</p><ul><li>Dynamic message creation and manipulation</li><li>Generic processing of messages without compile-time knowledge of their type</li></ul><p>Example (in C++):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> google<span style=color:#f92672>::</span>protobuf;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PrintMessage</span>(<span style=color:#66d9ef>const</span> Message<span style=color:#f92672>&amp;</span> message) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> Descriptor<span style=color:#f92672>*</span> descriptor <span style=color:#f92672>=</span> message.GetDescriptor();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> Reflection<span style=color:#f92672>*</span> reflection <span style=color:#f92672>=</span> message.GetReflection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> descriptor<span style=color:#f92672>-&gt;</span>field_count(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> FieldDescriptor<span style=color:#f92672>*</span> field <span style=color:#f92672>=</span> descriptor<span style=color:#f92672>-&gt;</span>field(i);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (reflection<span style=color:#f92672>-&gt;</span>HasField(message, field)) {
</span></span><span style=display:flex><span>      cout <span style=color:#f92672>&lt;&lt;</span> field<span style=color:#f92672>-&gt;</span>name() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> reflection<span style=color:#f92672>-&gt;</span>GetString(message, field) <span style=color:#f92672>&lt;&lt;</span> endl;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=8-implementation-details>8. Implementation Details</h2><h3 id=code-generation>Code Generation</h3><p>The protoc compiler generates language-specific code from .proto files:</p><ol><li><strong>Message classes</strong>: For creating, reading, and writing messages.</li><li><strong>Serialization methods</strong>: To convert messages to/from binary format.</li><li><strong>Accessor methods</strong>: For getting and setting field values.</li></ol><p>Example generated C++ code snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> <span style=color:#f92672>::</span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>Message {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  Person();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>Person();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Person(<span style=color:#66d9ef>const</span> Person<span style=color:#f92672>&amp;</span> from);
</span></span><span style=display:flex><span>  Person<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Person<span style=color:#f92672>&amp;</span> from);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> name() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_name</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int32_t</span> <span style=color:#a6e22e>id</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>set_id</span>(<span style=color:#66d9ef>int32_t</span> value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ... more methods ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>internal<span style=color:#f92672>::</span>InternalMetadataWithArena _internal_metadata_;
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>internal<span style=color:#f92672>::</span>ArenaStringPtr name_;
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>RepeatedPtrField<span style=color:#f92672>&lt;</span> <span style=color:#f92672>::</span>tutorial<span style=color:#f92672>::</span>Person_PhoneNumber <span style=color:#f92672>&gt;</span> phones_;
</span></span><span style=display:flex><span>  <span style=color:#f92672>::</span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>int32 id_;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>mutable</span> <span style=color:#66d9ef>int</span> _cached_size_;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>protobuf_AddDesc_person_2eproto</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>protobuf_AssignDesc_person_2eproto</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>protobuf_ShutdownFile_person_2eproto</span>();
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=runtime-libraries>Runtime Libraries</h3><p>Protobuf provides runtime libraries for each supported language, which include:</p><ul><li>Basic types (e.g., int32, string)</li><li>Message base classes</li><li>Serialization and deserialization logic</li><li>Reflection support</li></ul><p>These libraries are typically small and have minimal dependencies, making Protobuf suitable for embedded systems and mobile devices.</p><h2 id=9-optimization-techniques>9. Optimization Techniques</h2><ol><li><p><strong>Arena Allocation</strong>: Reduces memory fragmentation and improves performance for large numbers of small objects.</p></li><li><p><strong>Lazy Parsing</strong>: Delays parsing of nested messages until they are accessed.</p></li><li><p><strong>Zero-Copy Parsing</strong>: Allows parsing without copying the input buffer, reducing memory usage and improving speed.</p></li><li><p><strong>Field Merging</strong>: Combines multiple fields into a single allocation for better cache locality.</p></li><li><p><strong>Packed Repeated Fields</strong>: Encodes repeated fields more efficiently, especially for primitive types.</p></li></ol><p>Implementation example (Arena allocation in C++):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;google/protobuf/arena.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>Arena arena;
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span><span style=color:#f92672>*</span> message <span style=color:#f92672>=</span> google<span style=color:#f92672>::</span>protobuf<span style=color:#f92672>::</span>Arena<span style=color:#f92672>::</span>CreateMessage<span style=color:#f92672>&lt;</span>MyMessage<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>&amp;</span>arena);
</span></span></code></pre></div><h2 id=10-limitations-and-considerations>10. Limitations and Considerations</h2><ol><li><p><strong>Schema Requirement</strong>: Both sender and receiver must have access to the message schema.</p></li><li><p><strong>Limited Standard Library Support</strong>: May require additional dependencies in some languages.</p></li><li><p><strong>Lack of Human Readability</strong>: Binary format is not easily readable without tools.</p></li><li><p><strong>Versioning Complexity</strong>: Careful management of field numbers is required for proper versioning.</p></li><li><p><strong>Language Support Variability</strong>: Some languages have better support and performance than others.</p></li><li><p><strong>Learning Curve</strong>: Developers need to understand Protobuf-specific concepts and best practices.</p></li><li><p><strong>Tooling Ecosystem</strong>: While growing, it&rsquo;s not as extensive as some alternatives (e.g., JSON).</p></li></ol></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://bleedkagax.github.io/tags/systemdesign>SystemDesign</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://bleedkagax.github.io/post/2_prometheus/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Prometheus</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://bleedkagax.github.io/post/2_redis_performance_issues/><span>Redis Performance Issues</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid [&_svg]:block [&_svg]:m-auto">${e.innerHTML}</div>`})</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://bleedkagax.github.io/>Kaga Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>