<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Refactor | Kaga Blog</title>
<meta name=keywords content="Snippet"><meta name=description content="Essentially, refactoring is improving the design of code after it&rsquo;s been written.
If you want to add a feature to a program, but find that the code isn&rsquo;t easy to change due to a lack of good structure, refactor that program first so that it&rsquo;s easier to add the feature, and then add the feature.
It is the change in requirements that makes refactoring necessary.
The refactoring technique is to modify the program at a tiny pace. If you make a mistake, it&rsquo;s easy to spot it."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_refactor/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_refactor/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Refactor"><meta property="og:description" content="Essentially, refactoring is improving the design of code after it&rsquo;s been written.
If you want to add a feature to a program, but find that the code isn&rsquo;t easy to change due to a lack of good structure, refactor that program first so that it&rsquo;s easier to add the feature, and then add the feature.
It is the change in requirements that makes refactoring necessary.
The refactoring technique is to modify the program at a tiny pace. If you make a mistake, it&rsquo;s easy to spot it."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_refactor/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Refactor"><meta name=twitter:description content="Essentially, refactoring is improving the design of code after it&rsquo;s been written.
If you want to add a feature to a program, but find that the code isn&rsquo;t easy to change due to a lack of good structure, refactor that program first so that it&rsquo;s easier to add the feature, and then add the feature.
It is the change in requirements that makes refactoring necessary.
The refactoring technique is to modify the program at a tiny pace. If you make a mistake, it&rsquo;s easy to spot it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Refactor","item":"https://bleedkagax.github.io/post/0_refactor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Refactor","name":"Refactor","description":"Essentially, refactoring is improving the design of code after it\u0026rsquo;s been written.\nIf you want to add a feature to a program, but find that the code isn\u0026rsquo;t easy to change due to a lack of good structure, refactor that program first so that it\u0026rsquo;s easier to add the feature, and then add the feature.\nIt is the change in requirements that makes refactoring necessary.\nThe refactoring technique is to modify the program at a tiny pace. If you make a mistake, it\u0026rsquo;s easy to spot it.\n","keywords":["Snippet"],"articleBody":"Essentially, refactoring is improving the design of code after it’s been written.\nIf you want to add a feature to a program, but find that the code isn’t easy to change due to a lack of good structure, refactor that program first so that it’s easier to add the feature, and then add the feature.\nIt is the change in requirements that makes refactoring necessary.\nThe refactoring technique is to modify the program at a tiny pace. If you make a mistake, it’s easy to spot it.\nThe test of good code is how easily one can modify it.\nTo summarize:\nThe key takeaways for efficient and organized refactoring are: Smaller steps lead to faster progress, keep your code in a working state forever, and small changes add up to a much better system design. Refactoring is not a “silver bullet”, but it can be considered a “silver tongs”, which can help you always have good control over your code. Refactoring is a tool.\n1. Bad taste in code 1. Mysterious Name There are only two hard things in Computer Science: cache invalidation and naming things-- Phil Karlt\nNaming is one of the two hardest things in programming. Because of this, renaming is probably the most commonly used refactoring technique, including changing function declarations (for renaming functions), variable renaming, and field renaming.\n2. Global Data Wrapped Variables. It may not hurt to have a small amount of global data, but the larger the number, the exponentially more difficult it is to deal with.\n3. Mutable Data Encapsulated variables can be used to ensure that all data update operations are performed through very few functions, making them easier to monitor and evolve.\nIf a variable is used to store different things at different times, split variables can be used to split it into variables for their own different purposes, thus avoiding dangerous update operations.\nUse move statements and refine functions to try to move logic out of the code that handles update operations, separating code that has no side effects from code that performs data update operations.\nWhen designing APIs, you can use ** to separate query functions from modification functions**.\nUse Remove set-value functions as early as possible to narrow the variable scope.\n4. Long Functions Actively Decompose Functions.\nPrinciple: Whenever we feel that we need to explain something in a comment, we write what we need to explain in a separate function and name it after its purpose (not how it was implemented).\nWhat kind of function is too long? More than 50 lines? More than 70 lines? It’s not the length of the function that matters, it’s the semantic distance between the “what” and “how” of the function.\nHow do you determine which piece of code to refine? A good tip is to look for comments. They usually indicate the semantic distance between what the code does and how it does it.\nConditional expressions and loops often signal refinement as well. Conditional expressions can be handled using decomposition conditional expressions.\nFor huge switch statements, each branch should be turned into a separate function call by refining the function. If there are multiple switch statements that branch selection based on the same condition, you should use replace conditional expressions with polymorphism.\nLoops and code within loops should be refined into a separate function. If you find the distilled loop hard to name, it may be because it does several different things in it. If this is the case, be brave and use a split loop to break it up into its own separate tasks.\n5. Long Parameter List If it is possible to launch a query on one parameter to get the value of another parameter, then this second parameter can be removed by replacing the parameter with a query.\nIf you find yourself pulling a lot of data items out of an existing data structure, consider Using the Keep Objects Intact technique to pass directly into the original data structure. If there are several parameters that always appear at the same time, you can combine them into a single object by introducing a parameter object.\nIf a parameter is used as a flag to distinguish the behavior of a function, remove the flag parameter.\nUsing classes can effectively shorten the argument list. Introducing a class makes particular sense if multiple functions have the same few parameters. You can use functions combined into classes to make these common parameters into fields of this class.\n6. Shotgun Surgery If you have to make many small modifications within many different classes every time you encounter some kind of change, the bad taste you’re facing is Shotgun Surgery.\nMoving functions and moving fields puts all the code that needs to be modified into the same module. If there are a lot of functions that operate on similar data, you can use a combination of functions into a class. If some functions function to transform or enrich data structures, you can use functions to combine into transformations. If the output of some functions can be combined and made available to a piece of logic that specializes in using the results of those computations, this is often useful Split Stage (e.g., parsing an order before calculating the price of an order)**.\nA common strategy is to use refactoring related to inlining —— such as inline functions (or inline classes) —— to yank logic that shouldn’t be scattered back into one place**. After you’ve finished inlining, you may smell an overly long function or overly large class, and then use refactoring techniques related to refinement to break it up into more sensible chunks.\n7. Comments. If you need comments to explain what a piece of code does, try refining the function; If the function has been refined but still needs comments to explain its behavior, try renaming it with a change to the function declaration; **If you need comments to explain the specification of some system requirement, try introducing an assertion.\nWhen you feel the need to write comments, try refactoring first and try making all comments redundant.\n8. Data Clumps. Data that always appears tied together really should have objects of their own.\n9. Repeated Switches Polymorphism.\n10. **Lazy Element As the refactoring progresses it gets smaller and smaller and the class ends up with only one function. Remove this class in time to use inline functions or inline classes.\n11. Refused Bequest. Subclasses should inherit functions and data from the superclass.\nIf you do not want to support the interface of the superclass, you should not be false to the inheritance system, and you should use delegates (using combinations instead of inheritance) instead of subclasses or delegates instead of superclasses to draw a line in the sand.\n2. First set of reconstructions 1. Extract Function Separate Intent from Implementation: If you need to spend time browsing through a piece of code to figure out what it’s actually doing, then you should distill it down to a function and name it according to what it does. Because most of the time you don’t need to care about how the function accomplishes its purpose (that’s what the function does inside)\nGood names: in a big function, a piece of code puts a comment that distills it into a function, and the comment often suggests a good name.\nPractice*\nCreate a new function: name it after “what it does”, not “how it does it”.\nWithout local variables, refine directly into a function;\nwith local variables but read-only, passed as arguments to the target function\nLocal variables are assigned values: declared directly in the refining function if they are used only within the refining function; used outside the refining function as the return value of the refining function; multiple variables are modified by considering returning an object or using other refactoring techniques (querying instead of temporary variables, splitting variables)\n2. Inline Function Indirectness may help, but non-essential indirectness is always uncomfortable.\nSome functions have their contents and names clear and easy to read\nA group of functions is not well organized, inline to one big function first, then refine.\n3. Extract Variable Variables provide the right context: they help us break up expressions into more manageable forms, and also make it easier to understand what a portion of the code is doing.\nAccording to The Tao of Tidy Code, “Use explanatory variables to break up the computation into a series of well-named intermediate values”.\n4. Inline Variable Sometimes, variable names are no more expressive than the expression itself. There are also times when variables may get in the way of refactoring nearby code.\n5. Rename Variable Explain what a piece of program is doing, and be more careful naming fields whose scope extends beyond a single function call.\n6. Change Function Declaration A good name gives an immediate indication of what the function is used for;\nThe argument list of a function describes how the function coexists with the outside world, and modifying the argument list not only increases the scope of the function’s application, but also removes unnecessary coupling by changing the conditions required to connect a module.\n“A good way to improve the name of a function: write a comment describing what the function is used for, then turn that comment into the name of the function.”\n7. Introduce Parameter Object Organize data into structures that make the relationships between data items clearer;\nshorter parameter list;\nCode consistency: all functions that use this data structure can access elements of it by the same name.\nChanging the conceptual picture of the code elevates these data structures to new abstractions\n8. Combine Functions into Class If you find a group of functions that manipulate the same piece of data (usually by passing that piece of data as a parameter to the function), it’s time to form a class. Classes explicitly provide a common environment for these functions, and calling them from within an object simplifies function calls by passing many fewer arguments.\n9. Split Phase A piece of code that handles two different things at simultaneously can be considered to be split into its own separate modules, because then each topic can be handled separately when it comes time to make changes.\n3. Encapsulate 1. Encapsulate Record Objects can hide details of the structure, help with renaming of fields, and are easy to expand to cope with changes.\n2. Encapsulate Variable For all mutable data, as long as its scope extends beyond a single function, I encapsulate it and only allow access through the function. The larger the scope of the data, the more important encapsulation becomes.\n3. Encapsulate Collection One mistake people often make when encapsulating collections is that ** only encapsulates access to the collection variables, but still lets the fetch function return the collection itself. This allows the collection’s member variables to be modified directly, while the class encapsulating it is completely unaware and unable to intervene**.\nPractice:\nProvide methods to modify the collection on the class ——Usually “add” and “remove” methods to unify the management.\n4. Substitute Algorithm 3. Move Characteristics Another type of refactoring that is also important is moving elements between contexts.\n1. 搬移函数（Move Function） 任何函数都需要具备上下文环境才能存活。\n搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少，将函数移动到联系更紧密的上下文那么系统别处就可以减少对当前模块的依赖，获得更好的封装效果。\n整理代码时，发现需要频繁调用一个别处的函数；或者函数内部定义了一个帮助函数，而该帮助函数可能在别的地方也有用处，此时就可以将它搬移到某些更通用的地方。\n是否需要搬移函数常常不易抉择，但决定越难做，通常说明\"搬移这个函数与否\"的重要性也越低。\n范例：搬移内嵌函数至顶层\nbefore：\n计算两点之间距离的函数在别处也有调用\nafter：\n2. 搬移语句到函数（Move Statements into Function） “消除重复”：如果发现调用某个函数时，总有一些相同的代码也需要每次执行，则考虑将此段代码合并到函数里头。\n如果某些语句与一个函数放在一起更像一个整体，并且更有助于理解，则将语句搬移到函数里去。如果它们与函数不像一个整体，但仍应与函数一起执行，可以用提炼函数将语句和函数一并提炼出去。\n五. 重新组织数据\n1. 拆分变量（Split Variable）\n除\"循环变量\"和\"结果收集变量\"外，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种**变量应该只被赋值一次。**如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，保持职责单一。\n范例：对输入参数赋值\nbefore：\nafter：\n六. 简化条件逻辑\n1. 分解条件表达式（Decompose Conditional）\n程序之中，复杂的条件逻辑是最常导致复杂度上升的因素之一。\n对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。\n注：实际上为提炼函数的一个应用场景。\n2. 合并条件表达式（Consolidate Conditional Expression）\n3. 以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）\n如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为\"卫语句”（guard clauses）。\n如果使用if-then-else结构，则对if分支和else分支的重视是同等的；以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。\n“每个函数只能有一个入口和一个出口\"的观念未必有用，保持代码清晰才是最关键的。\n范例\nbefore\nafter\n范例：将条件反转\n初始\n反转\n合并条件表达式\n删除可变变量\n4. 以多态取代条件表达式（Replace Conditional with Polymorphism）\n七. 重构API\n以查询取代参数（Replace Parameter with Query）\n函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。\n使用场景：调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易\n什么是\"同样容易”：函数可以承担这份原本由调用方所承担的\"获得正确的参数值\"的责任。\n什么时候不适用：移除参数可能会给函数体增加不必要的依赖关系。\n以参数取代查询（Replace Query with Parameter）\n好处：改变依赖关系，去掉令人不快的引用。\n注意：要考虑责任分配问题，会增加函数调用者的复杂度，而设计接口时又需要考虑易用性。\n八. 处理继承关系\n以委托取代超类（Replace Superclass with Delegate）\n继承：子类继承父类的特征和行为 （车-交通工具）\n组合：通过对现有对象进行拼装即组合产生新的具有更复杂的功能 （车-轮胎）\n以组合取代继承。\n一个经典的误用继承的例子：\n让栈（stack）继承列表（list）。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了。\nJava\npublic class Stack extends Vector {\npublic E push(E item) {\naddElement(item);\nreturn item;\n}\npublic synchronized E pop() {\nE obj;\nint len = size();\nobj = peek();\nremoveElementAt(len - 1);\nreturn obj;\n}\n}\nStack真正需要的只有四个方法，push/pop/size/isEmpty， Stack只用到了 Vector的两个方法 isEmpty 和 size，而 push 和 pop 是 Stack 自有的实现， Vector 有大量的方法， 不适用于stack。\n所以，如果父类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。\n同时也要避免走弯路：完全避免使用继承，如果符合继承关系的语义条件（超类的所有方法都适用于子类，子类的所有实例都是超类的实例），那么继承是一种简洁又高效的复用机制。\n建议：首先（尽量）使用继承，如果发现继承有问题，再使用以委托取代超类。\n范例\n背景：\n给一个古城里存放上古卷轴（scroll）的图书馆做了咨询。他们给卷轴的信息编制了一份目录（catalog），每份卷轴都有一个ID号，并记录了卷轴的标题（title）和一系列标签（tag），这些古老的卷轴需要日常清扫，因此代表卷轴的Scroll类继承了代表目录项的CatalogItem类，并扩展出与\"需要清扫\"相关的数据。\n这就是一个常见的建模错误。真实存在的卷轴和只存在于纸面上的目录项，是完全不同的两种东西。比如说，关于\"如何治疗灰鳞病\"的卷轴可能有好几卷，但在目录上却只记录一个条目。这样的建模错误很多时候可以置之不理。像\"标题\"和\"标签\"这样的数据，可以认为就是目录中数据的副本。如果这些数据从不发生改变，可以接受这样的表现形式。但如果需要更新其中某处数据，就必须非常小心，确保同一个目录项对应的所有数据副本都被正确地更新。\n就算没有数据更新的问题，把目录类作为卷轴类的父类，依然会让后来的开发者感到迷惑。\n首先在Scroll类中创建一个属性，令其指向一个新建的CatalogItem实例。\n然后对于子类中用到所有属于超类的函数，我要逐一为它们创建转发函数。\n详细笔记\n第1章 重构，第一个示例\n本质上说，重构就是在代码写好之后改进它的设计。\n如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。\n是需求的变化使重构变得必要。\n重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。\n每次想将一块代码抽取成一个函数时，遵循一个标准流程：最大程度减少犯错的可能。——提炼函数\n重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。\n营地法则：保证离开时的代码库一定比你来时更加健康。完美的境界很难达到，但应该时时都勤加拂拭。\n以实例展开如何重构：包括提炼函数、内联变量、搬移函数和以多态取代条件表达式等，\n几个重要的阶段：将原函数分解成一组嵌套的函数、应用拆分阶段分离计算逻辑与输出格式化逻辑，以及为计算器引入多态性来处理计算逻辑。每一步都给代码添加了更多的结构，以便更好地表达代码的意图。\n好代码的检验标准就是人们是否能轻而易举地修改它。\n总结：\n开展高效有序的重构，关键的心得是：小的步子可以更快前进，请保持代码永远处于可工作状态，小步修改累积起来也能大大改善系统的设计。\n第2章　重构的原则\n为何重构\n它不是一颗\"银弹\"，却可以算是一把\"银钳子\"，可以帮你始终良好地控制自己的代码。重构是一个工具\n重构改进软件的设计\n代码结构的流失有累积效应。经常性的重构有助于代码维持自己该有的形态。消除重复代码，以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。\n重构使软件更容易理解\n在重构上花一点点时间，就可以让代码更好地表达自己的意图——更清晰地说出我想要做的。\n重构帮助找到bug\nKent Beck经常形容自己的一句话：“我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。”\n重构提高编程速度\n需要添加新功能时，内部质量良好的软件让我可以很容易找到在哪里修改、如何修改。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，引入bug的可能性就会变小。\n“设计耐久性假说”：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。\n何时重构\n预备性重构：让添加新功能更容易\n重构的最佳时机就在添加新功能之前。\n如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样bug的概率也会降低。\n帮助理解的重构：使代码更易懂\n捡垃圾式重构\n有计划的重构和见机行事的重构\n预备性重构、帮助理解的重构、捡垃圾式重构——都是见机行事的\n长期重构\n如果想替换掉一个正在使用的库，可以先如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。\n复审代码时重构\n与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。\n重构的挑战\n延缓新功能开发\n重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。\n有时会看到一个（大规模的）重构很有必要进行，而马上要添加的功能非常小，这时应先把新功能加上，然后再做这次大规模重构。\n重构不足的情况远多于重构过度的情况。换句话说，绝大多数人应该尝试多做重构。\n重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量。我们之所以重构，因为它能让我们更快——添加功能更快，修复bug更快。\n代码所有权\n旧的接口标记为\"不推荐使用\"（deprecated）。\n分支\n持续集成（Continuous Integration，CI），也叫\"基于主干开发\"（Trunk-Based Development）。\n重构、架构和YAGNI\n重构对架构最大的影响在于，通过重构，我们能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。“在编码之前先完成架构\"这种做法最大的问题在于，它假设了软件的需求可以预先充分理解。\n重构与软件开发过程\n既牢固可靠又能快速响应变化的需求。\n自动化重构\n不仅能处理文本，还能处理语法树，这是IDE相比于文本编辑器更先进的地方。重构工具不仅需要理解和修改语法树，还要知道如何把修改后的代码写回编辑器视图。如果我给一个变量改名，工具会提醒我修改使用了旧名字的注释。能借助语法树来分析和重构程序代码，这是IDE与普通文本编辑器相比具有的一大优势。\n第3章　代码的坏味道\n神秘命名（Mysterious Name）\n命名是编程中最难的两件事之一[mf-2h]。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（用于给函数改名）、变量改名、字段改名。\n重复代码（Duplicated Code）\n过长函数（Long Function）\n积极地分解函数.\n原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。关键不在于函数的长度，而在于函数\"做什么\"和\"如何做\"之间的语义距离。\n如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。\n条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式处理条件表达式。\n对于庞大的switch语句，其中的每个分支都应该通过提炼函数变成独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式。\n应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环将其拆分成各自独立的任务。\n过长参数列表（Long Parameter List）\n如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数去掉这第二个参数。\n如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象将其合并成一个对象。\n如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数。\n使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类，将这些共同的参数变成这个类的字段。\n全局数据（Global Data）\n封装变量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。\n可变数据（Mutable Data）\n可以用封装变量来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。\n如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句和提炼函数尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。设计API时，可以使用将查询函数和修改函数分离。\n尽早使用移除设值函数，缩小变量作用域。\n发散式变化（Divergent Change）\n如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。\n提炼拆分。\n霰弹式修改（Shotgun Surgery）\n如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。\n搬移函数和搬移字段把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段。\n一个常用的策略就是使用与内联（inline）相关的重构——如内联函数（1或是内联类——把本不该分散的逻辑拽回一处。完成内联之后，你可能会闻到过长函数或者过大的类的味道，再用与提炼相关的重构手法将其拆解成更合理的小块。\n依恋情结（Feature Envy）\n模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。\n一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。\n数据泥团（Data Clumps）\n总是绑在一起出现的数据真应该拥有属于它们自己的对象。\n基本类型偏执（Primitive Obsession）\n把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似if (a \u003c upper \u0026\u0026 a \u003e lower)这样的代码。\n运用以对象取代基本类型。\n重复的switch （Repeated Switches）\n多态。\n循环语句（Loops）\n？管道操作（如filter和map）\n冗赘的元素（Lazy Element）\n随着重构的进行越变越小，类最后只剩了一个函数。及时删除这个类，使用内联函数或是内联类。\n夸夸其谈通用性（Speculative Generality）\n用不上的装置只会挡你的路，所以，把它搬开吧。\n临时字段（Temporary Field）\n其内部某个字段仅为某种特定情况而设。\n过长的消息链（Message Chains）\n先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数把这个函数推入消息链。\n中间人（Middle Man）\n某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人。\n内幕交易（Insider Trading）\n模块之间大量交换数据，因为这会增加模块间的耦合。\n在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。\n过大的类（Large Class）\n异曲同工的类（Alternative Classes with Different Interfaces）\n纯数据类（Data Class）\n纯数据类：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。\n被拒绝的遗赠（Refused Bequest）\n子类应该继承超类的函数和数据。\n不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类或者以委托取代超类彻底划清界限。\n注释（Comments）\n如果你需要注释来解释一块代码做了什么，试试提炼函数；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言。\n第4章　构筑测试体系\n自测试代码的价值\n时间统计：编写代码的时间仅占所有时间中很少的一部分。有些时间用来决定下一步干什么，有些时间花在设计上，但是，花费在调试上的时间是最多的。\n一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。\n撰写测试代码的最好时机是在开始动手编码之前，把注意力集中于接口而非实现。\n测试实例\n总是确保测试不该通过时真的会失败：在代码中暂时引入一个错误。\n探测边界条件\n输入：空集合、0、空字符串... 预期输出：？\n考虑可能出错的边界条件，把测试火力集中在那儿。\n不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。\n第5章　介绍重构名录\n本章主要作用是承上启下，略。\n第6章 第一组重构\n提炼函数（Extract Function）\n动机\n将意图与实现分开：如果你需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。因为大多数时候根本不需要关心函数如何达成其用途（这是函数体内干的事）\n好名字：在一个大函数中，一段代码放着一句注释，提炼成函数，注释往往提示一个好名字。\n做法\n创造一个新函数：以\"做什么\"而非\"怎么做\"来命名。\n无局部变量，直接提炼成函数；\n有局部变量但只读，作为参数传递给目标函数\n局部变量被赋值：只在提炼函数中被使用则可直接声明在提炼函数中；在提炼函数外也被使用则可作为提炼函数的返回值；多个变量被修改可考虑返回一个对象或者使用其他重构手法（以查询取代临时变量、拆分变量）\n内联函数（Inline Function）\n动机\n间接性可能带来帮助，但非必要的间接性总是让人不舒服。\n某些函数其内容和名称清晰易读\n一群函数的组织不甚合理，先内联到一个大函数，再提炼。\n做法\n确定函数不具多态性\n找到所有调用点执行替换（重点在于始终小步前进）\n提炼变量（Extract Variable）\n动机\n提供了合适的上下文：帮助我们将表达式分解为比较容易管理的形式，也便于理解一部分代码是干什么的。\n内联变量（Inline Variable）\n动机\n有时候，变量名字并不比表达式本身更具表现力。还有些时候，变量可能会妨碍重构附近的代码。\n改变函数声明（Change Function Declaration）\n动机\n一个好名字能让人一眼看出函数的用途；\n函数的参数列表阐述了函数如何与外部世界共处，修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合。\n封装变量（Encapsulate Variable）\n动机\n对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。\n变量改名（Rename Variable）\n动机\n解释一段程序在干什么，对于作用域超出一次函数调用的字段，则需要更用心命名。\n引入参数对象（Introduce Parameter Object）\n动机\n将数据组织成结构，使数据项之间的关系更清晰；\n缩短参数列表；\n代码一致性：所有使用该数据结构的函数都可以通过相同的名字来访问其中元素。\n改变代码的概念图景，将这些数据结构提升为新的抽象概念\n函数组合成类（Combine Functions into Class）\n动机\n如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用。\n函数组合成变换（Combine Functions into Transform）\n动机\n在软件中，经常需要把数据\"喂\"给一个程序，让它再计算出各种派生信息。这些派生数值可能会在几个不同地方用到，因此这些计算逻辑也常会在用到派生数据的地方重复。把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。\n函数组合成变换与函数组合成类区别：\n如果代码中会对源数据做更新，那么使用类要好得多；如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。\n拆分阶段（Split Phase）\n动机\n一段代码在同时处理两件不同的事，可以考虑把它拆分成各自独立的模块，因为这样到了需要修改的时候，可以单独处理每个主题。\n例子\n重构前：\n重构后：\n提炼函数、引入中转数据结构：\n第七章 封装\n封装记录（Encapsulate Record）\n动机\n对象可以隐藏结构的细节，有助于字段的改名，方便拓展以应对变化。\n封装集合（Encapsulate Collection）\n动机\n封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。\n做法：\n在类上提供一些修改集合的方法——通常是\"添加\"和\"移除\"方法。\n以对象取代基本类型（Replace Primitive with Object）\n以查询取代临时变量（Replace Temp with Query）\n提炼类（Extract Class）\n动机\n如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。\n如果你发现子类化只影响类的部分特性，或如果你发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着你需要分解原来的类。\n内联类（Inline Class）\n隐藏委托关系（Hide Delegate）\n移除中间人（Remove Middle Man）\n“合适的隐藏程度”。\n替换算法（Substitute Algorithm）\n第8章　搬移特性\n另一种类型的重构也很重要，那就是在不同的上下文之间搬移元素。\n搬移函数（Move Function）\n任何函数都需要具备上下文环境才能存活。\n搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少，将函数移动到联系更紧密的上下文那么系统别处就可以减少对当前模块的依赖，获得更好的封装效果。\n整理代码时，发现需要频繁调用一个别处的函数；或者函数内部定义了一个帮助函数，而该帮助函数可能在别的地方也有用处，此时就可以将它搬移到某些更通用的地方。\n是否需要搬移函数常常不易抉择，但决定越难做，通常说明\"搬移这个函数与否\"的重要性也越低。\n范例：搬移内嵌函数至顶层\nbefore：\nafter：\n范例：在类之间搬移函数\nbefore：\nafter：\n搬移字段（Move Field）\n范例\nbefore：\nafter：\n范例：搬移字段到共享对象\nbefore：\nafter：\n搬移语句到函数（Move Statements into Function）\n“消除重复”：如果发现调用某个函数时，总有一些相同的代码也需要每次执行，则考虑将此段代码合并到函数里头。\n如果某些语句与一个函数放在一起更像一个整体，并且更有助于理解，则将语句搬移到函数里去。如果它们与函数不像一个整体，但仍应与函数一起执行，可以用提炼函数将语句和函数一并提炼出去。\n范例\nbefore：\nafter：\n搬移语句到调用者（Move Statements to Callers）\n随着系统能力发生演进，原先设定的抽象边界总会悄无声息地发生偏移。对于函数来说，这样的边界偏移意味着曾经视为一个整体、一个单元的行为，如今可能已经分化出两个甚至是多个不同的关注点。\n范例\nbefore：\nafter：\n以函数调用取代内联代码（Replace Inline Code with Function Call）\n移动语句（Slide Statements）\n让存在关联的东西一起出现，可以使代码更容易理解。\n命令查询分离原则（Command-Query Separation,CQS原则）：\n**查询：**方法返回结果，但不改变任何系统状态(无副作用)。\n**命令：**方法没有结果，但会改变系统状态。\n优点如下\n查询类型的方法，对于调用者来讲不用在顾虑各个查询方法的调用顺序和次数(忽略性能的因素)。\n命令类型的方法，从语义上来讲更准确。\n范例\n思考：哪些语句可以移动？\n范例：包含条件逻辑的移动\nbefore：\nafter：\n拆分循环（Split Loop）\n范例\nbefore：\nafter：\n以管道取代循环（Replace Loop with Pipeline）\nmap运算是指用一个函数作用于输入集合的每一个元素上，将集合变换成另外一个集合的过程；filter运算是指用一个函数从输入集合中筛选出符合条件的元素子集的过程。运算得到的集合可以供管道的后续流程使用。\n范例\nbefore：\nafter：\n移除死代码（Remove Dead Code）\n第9章　重新组织数据\n拆分变量（Split Variable）\n除\"循环变量\"和\"结果收集变量\"外，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种**变量应该只被赋值一次。**如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，保持职责单一。\n范例：对输入参数赋值\nbefore：\nafter：\n字段改名（Rename Field）\n范例：给字段改名\nbefore：\nafter：\n以查询取代派生变量（Replace Derived Variable with Query）\n范例\n即时计算，不必每次更新。\nbefore：\nafter：\n范例：不止一个数据来源\nbefore：\nafter：\n引入断言：\n将引用对象改为值对象（Change Reference to Value）\n不需要共享一个对象。\n范例\nbefore：\nafter：\n将值对象改为引用对象（Change Value to Reference）\n共享一个对象。\n范例\nbefore：\nafter：\n存在的问题：构造函数与一个全局的仓库对象耦合。\n改进的办法：将仓库对象作为参数传递给构造函数。\n第10章　简化条件逻辑\n分解条件表达式（Decompose Conditional）\n程序之中，复杂的条件逻辑是最常导致复杂度上升的因素之一。\n对于条件逻辑，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。\n注：实际上为提炼函数的一个应用场景。\n范例\nbefore：\nafter：\n合并条件表达式（Consolidate Conditional Expression）\n以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard Clauses）\n如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为\"卫语句”（guard clauses）。\n如果使用if-then-else结构，则对if分支和else分支的重视是同等的；以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。\n“每个函数只能有一个入口和一个出口\"的观念未必有用，保持代码清晰才是最关键的。\n范例\nbefore\nafter\n范例：将条件反转\n初始\n反转\n合并条件表达式\n删除可变变量\n以多态取代条件表达式（Replace Conditional with Polymorphism）\n引入特例（Introduce Special Case）\n“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理，从而用一个函数调用取代大部分特例检查逻辑。\n引入断言（Introduce Assertion）\n第11章 重构API\n将查询函数和修改函数分离（Separate Query from Modifier）\n范例\nbefore\nAfter\n函数参数化（Parameterize Function）\n范例\nbefore\nAfter\ng)\n移除标记参数（Remove Flag Argument）\n“标记参数\"是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。\n范例\nBefore\nAfter\n保持对象完整（Preserve Whole Object）\n减少函数参数长度，方便后续拓展。\n以查询取代参数（Replace Parameter with Query）\n函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该尽量避免重复，并且参数列表越短就越容易理解。\n使用场景：调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易\n什么是\"同样容易”：函数可以承担这份原本由调用方所承担的\"获得正确的参数值\"的责任。\n什么时候不适用：移除参数可能会给函数体增加不必要的依赖关系。\n留意：如果在处理的函数具有引用透明性（referential transparency，即，不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试，不会去除参数，让它访问一个可变的全部变量。\n以参数取代查询（Replace Query with Parameter）\n好处：改变依赖关系，去掉令人不快的引用。\n注意：要考虑责任分配问题，会增加函数调用者的复杂度，而设计接口时又需要考虑易用性。\n移除设值函数（Remove Setting Method）\n去除不必要的设值函数。\n以工厂函数取代构造函数（Replace Constructor with Factory Function）\n工厂函数的实现更为灵活。\n以命令取代函数（Replace Function with Command）\n以函数取代命令（Replace Command with Function）\n处理的逻辑不是特别复杂，则命令对象可能显得费而不惠。\n第12章　处理继承关系\n函数上移（Pull Up Method）\n消除重复代码。\n字段上移（Pull Up Field）\n同样也是消除重复代码。\n构造函数本体上移（Pull Up Constructor Body）\n提炼各个子类函数中的重复部分至父类中，同样也是消除重复代码。\n函数下移（Push Down Method）\n如果超类中的某个函数只与一个（或少数几个）子类有关，那么最好将其从父类中挪走，放到真正关心它的子类中去。\n字段下移（Push Down Field）\n如果某个字段只被一个子类（或者一小部分子类）用到，就将其搬移到需要该字段的子类中。\n以子类取代类型码（Replace Type Code with Subclasses）\n可以用多态来处理条件逻辑，而不是根据不同的类型码采取不同的行为。\n有些字段或函数只对特定的类型码取值才有意义，子类的形式能更明确地表达数据与类型之间的关系。\n移除子类（Remove Subclass）\n如果子类的用处太少，可以移除子类，将替换为父类的一个字段。\n提炼超类（Extract Superclass）\n目的在于把重复的行为收拢一处。\n折叠继承体系（Collapse Hierarchy）\n随着继承体系的演化，有时会发现一个类与其父类差别不大，此时可以把父类和子类合并起来。\n以委托取代子类（Replace Subclass with Delegate）\n与继承关系相比，使用委托（即组合）关系时接口更清晰、耦合更少。\n以委托取代超类（Replace Superclass with Delegate）\n以组合取代继承。\n一个经典的误用继承的例子：让栈（stack）继承列表（list）。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了。\n所以，如果超类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。\n同时也要避免走弯路：完全避免使用继承，如果符合继承关系的语义条件（超类的所有方法都适用于子类，子类的所有实例都是超类的实例），那么继承是一种简洁又高效的复用机制。\n建议：首先（尽量）使用继承，如果发现继承有问题，再使用以委托取代超类。\n","wordCount":"2573","inLanguage":"en","datePublished":"2024-09-05T00:00:00Z","dateModified":"2024-09-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_refactor/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Refactor</h1><div class=post-meta><span title='2024-09-05 00:00:00 +0000 UTC'>September 5, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-bad-taste-in-code aria-label="1. Bad taste in code">1. Bad taste in code</a><ul><li><a href=#1-mysterious-name aria-label="1. Mysterious Name">1. Mysterious Name</a></li><li><a href=#2-global-data aria-label="2. Global Data">2. Global Data</a></li><li><a href=#3-mutable-data aria-label="3. Mutable Data">3. Mutable Data</a></li><li><a href=#4-long-functions aria-label="4. Long Functions">4. Long Functions</a></li><li><a href=#5-long-parameter-list aria-label="5. Long Parameter List">5. Long Parameter List</a></li><li><a href=#6-shotgun-surgery aria-label="6. Shotgun Surgery">6. Shotgun Surgery</a></li><li><a href=#7-comments aria-label="7. Comments.">7. Comments.</a></li><li><a href=#8-data-clumps aria-label="8. Data Clumps.">8. Data Clumps.</a></li><li><a href=#9-repeated-switches aria-label="9. Repeated Switches">9. Repeated Switches</a></li><li><a href=#10-lazy-element aria-label="10. **Lazy Element">10. **Lazy Element</a></li><li><a href=#11-refused-bequest aria-label="11. Refused Bequest.">11. Refused Bequest.</a></li></ul></li><li><a href=#2-first-set-of-reconstructions aria-label="2. First set of reconstructions">2. First set of reconstructions</a><ul><li><a href=#1-extract-function aria-label="1. Extract Function">1. Extract Function</a></li><li><a href=#2-inline-function aria-label="2. Inline Function">2. Inline Function</a></li><li><a href=#3-extract-variable aria-label="3. Extract Variable">3. Extract Variable</a></li><li><a href=#4-inline-variable aria-label="4. Inline Variable">4. Inline Variable</a></li><li><a href=#5-rename-variable aria-label="5. Rename Variable">5. Rename Variable</a></li><li><a href=#6-change-function-declaration aria-label="6. Change Function Declaration">6. Change Function Declaration</a></li><li><a href=#7-introduce-parameter-object aria-label="7. Introduce Parameter Object">7. Introduce Parameter Object</a></li><li><a href=#8-combine-functions-into-class aria-label="8. Combine Functions into Class">8. Combine Functions into Class</a></li><li><a href=#9-split-phase aria-label="9. Split Phase">9. Split Phase</a></li></ul></li><li><a href=#3-encapsulate aria-label="3. Encapsulate">3. Encapsulate</a><ul><li><a href=#1-encapsulate-record aria-label="1. Encapsulate Record">1. Encapsulate Record</a></li><li><a href=#2-encapsulate-variable aria-label="2. Encapsulate Variable">2. Encapsulate Variable</a></li><li><a href=#3-encapsulate-collection aria-label="3. Encapsulate Collection">3. Encapsulate Collection</a></li><li><a href=#4-substitute-algorithm aria-label="4. Substitute Algorithm">4. Substitute Algorithm</a></li></ul></li><li><a href=#3-move-characteristics aria-label="3. Move Characteristics">3. Move Characteristics</a><ul><li><a href=#1-%e6%90%ac%e7%a7%bb%e5%87%bd%e6%95%b0move-function aria-label="1. 搬移函数（Move Function）">1. 搬移函数（Move Function）</a></li><li><a href=#2-%e6%90%ac%e7%a7%bb%e8%af%ad%e5%8f%a5%e5%88%b0%e5%87%bd%e6%95%b0move-statements-into-function aria-label="2. 搬移语句到函数（Move Statements into Function）">2. 搬移语句到函数（Move Statements into Function）</a></li></ul></li></ul></div></details></div><div class=post-content><p>Essentially, <strong>refactoring is improving the design of code after it&rsquo;s been written</strong>.</p><p>If you want to add a feature to a program, but find that the code isn&rsquo;t easy to change due to a lack of good structure, refactor that program first so that it&rsquo;s easier to add the feature, and then add the feature.</p><p>It is the change in <strong>requirements</strong> that makes refactoring necessary.</p><p>The refactoring technique is to <strong>modify the program at a tiny pace</strong>. If you make a mistake, it&rsquo;s easy to spot it.</p><p>The test of good code is how easily one can modify it.</p><p>To summarize:</p><p>The key takeaways for efficient and organized refactoring are: <strong>Smaller steps lead to faster progress</strong>, keep your code in a working state forever, and small changes add up to a much better system design. Refactoring is not a “silver bullet”, but it can be considered a “silver tongs”, which can help you always have good control over your code. Refactoring is a tool.</p><h1 id=1-bad-taste-in-code><strong>1. Bad taste in code</strong><a hidden class=anchor aria-hidden=true href=#1-bad-taste-in-code>#</a></h1><h2 id=1-mysterious-name>1. <strong>Mysterious Name</strong><a hidden class=anchor aria-hidden=true href=#1-mysterious-name>#</a></h2><p>There are only two hard things in Computer Science: cache invalidation
and naming things-- Phil Karlt</p><p>Naming is one of the two hardest things in programming. Because of this, renaming is probably the most commonly used refactoring technique, including changing function declarations (for renaming functions), variable renaming, and field renaming.</p><h2 id=2-global-data>2. <strong>Global Data</strong><a hidden class=anchor aria-hidden=true href=#2-global-data>#</a></h2><p><strong>Wrapped Variables</strong>. It may not hurt to have a small amount of global data, but the larger the number, the exponentially more difficult it is to deal with.</p><h2 id=3-mutable-data>3. <strong>Mutable Data</strong><a hidden class=anchor aria-hidden=true href=#3-mutable-data>#</a></h2><p>Encapsulated variables can be <strong>used to ensure that all data update operations are performed through very few functions</strong>, making them easier to monitor and evolve.</p><p><strong>If a variable is used to store different things at different times, split variables can be used to split it into variables for their own different purposes, thus avoiding dangerous update operations</strong>.</p><p>Use move statements and refine functions to try to move logic out of the code that handles update operations, separating code that has no side effects from code that performs data update operations.</p><p>When designing APIs, you can use ** to separate query functions from modification functions**.</p><p>Use <strong>Remove set-value functions</strong> as early as possible to narrow the variable scope.</p><h2 id=4-long-functions>4. <strong>Long Functions</strong><a hidden class=anchor aria-hidden=true href=#4-long-functions>#</a></h2><p><strong>Actively Decompose Functions.</strong></p><p>Principle: <strong>Whenever we feel that we need to explain something in a comment, we write what we need to explain in a separate function and name it after its purpose (not how it was implemented)</strong>.</p><p>What kind of function is too long? More than 50 lines? More than 70 lines? It&rsquo;s not the length of the function that matters, it&rsquo;s the semantic distance between the “what” and “how” of the function.</p><p>How do you determine which piece of code to refine? A good tip is to <strong>look for comments. They usually indicate the semantic distance between what the code does and how it does it.</strong></p><p><strong>Conditional expressions and loops often signal refinement as well</strong>. Conditional expressions can be handled using decomposition conditional expressions.</p><p><strong>For huge switch statements, each branch should be turned into a separate function call by refining the function. If there are multiple switch statements that branch selection based on the same condition, you should use replace conditional expressions with polymorphism.</strong></p><p><strong>Loops and code within loops should be refined into a separate function</strong>. If you find the distilled loop hard to name, it may be because it does several different things in it. If this is the case, be brave and use a split loop to break it up into its own separate tasks.</p><h2 id=5-long-parameter-list>5. <strong>Long Parameter List</strong><a hidden class=anchor aria-hidden=true href=#5-long-parameter-list>#</a></h2><p><strong>If it is possible to launch a query on one parameter to get the value of another parameter, then this second parameter can be removed by replacing the parameter with a query.</strong></p><p>If you find yourself pulling a lot of data items out of an existing data structure, consider <strong>Using the Keep Objects Intact technique to pass directly into the original data structure</strong>. <strong>If there are several parameters that always appear at the same time, you can combine them into a single object</strong> by introducing a parameter object.</p><p>If a parameter is used as a flag to distinguish the behavior of a function, remove the flag parameter.</p><p><strong>Using classes can effectively shorten the argument list</strong>. Introducing a class makes particular sense if multiple functions have the same few parameters. You can use functions combined into classes to make these common parameters into fields of this class.</p><h2 id=6-shotgun-surgery>6. <strong>Shotgun Surgery</strong><a hidden class=anchor aria-hidden=true href=#6-shotgun-surgery>#</a></h2><p><strong>If you have to make many small modifications within many different classes every time you encounter some kind of change</strong>, the bad taste you&rsquo;re facing is Shotgun Surgery.</p><p><strong>Moving functions and moving fields puts all the code that needs to be modified into the same module</strong>. If <strong>there are a lot of functions that operate on similar data, you can use a combination of functions into a class</strong>. If some functions function to transform or enrich data structures, you can use functions to combine into transformations. If the output of some functions can be combined and made available to a piece of logic that specializes in using the results of those computations, this is often useful <strong>Split Stage (e.g., parsing an order before calculating the price of an order</strong>)**.</p><p>A common strategy is to use refactoring related to inlining &mdash;&mdash; such as <strong>inline functions</strong> (or inline classes) &mdash;&mdash; to yank logic that shouldn&rsquo;t be scattered back into one place**. After you&rsquo;ve finished inlining, you may smell an overly long function or overly large class, and then use refactoring techniques related to refinement to break it up into more sensible chunks.</p><h2 id=7-comments>7. <strong>Comments</strong>.<a hidden class=anchor aria-hidden=true href=#7-comments>#</a></h2><p><strong>If you need comments to explain what a piece of code does, try refining the function</strong>; <strong>If the function has been refined but still needs comments to explain its behavior, try renaming it with a change to the function declaration</strong>; **If you need comments to explain the specification of some system requirement, try introducing an assertion.</p><p><strong>When you feel the need to write comments, try refactoring first and try making all comments redundant.</strong></p><h2 id=8-data-clumps>8. <strong>Data Clumps</strong>.<a hidden class=anchor aria-hidden=true href=#8-data-clumps>#</a></h2><p>Data that always appears tied together really should have objects of their own.</p><h2 id=9-repeated-switches>9. Repeated Switches<a hidden class=anchor aria-hidden=true href=#9-repeated-switches>#</a></h2><p>Polymorphism.</p><h2 id=10-lazy-element>10. **Lazy Element<a hidden class=anchor aria-hidden=true href=#10-lazy-element>#</a></h2><p>As the refactoring progresses it gets smaller and smaller and the class ends up with only one function. Remove this class in time to use inline functions or inline classes.</p><h2 id=11-refused-bequest>11. <strong>Refused Bequest</strong>.<a hidden class=anchor aria-hidden=true href=#11-refused-bequest>#</a></h2><p>Subclasses should inherit functions and data from the superclass.</p><p>If you do not want to support the interface of the superclass, you should not be false to the inheritance system, and you should use delegates (using combinations instead of inheritance) instead of subclasses or delegates instead of superclasses to draw a line in the sand.</p><h1 id=2-first-set-of-reconstructions><strong>2. First set of reconstructions</strong><a hidden class=anchor aria-hidden=true href=#2-first-set-of-reconstructions>#</a></h1><h2 id=1-extract-function>1. <strong>Extract Function</strong><a hidden class=anchor aria-hidden=true href=#1-extract-function>#</a></h2><p><img loading=lazy src=/img/0_refactor.png alt></p><p><img loading=lazy src=/img/0_refactor-1.png alt></p><p><strong>Separate Intent from Implementation</strong>: If you need to spend time browsing through a piece of code to figure out what it&rsquo;s actually doing, then you should distill it down to a function and name it according to what it does. Because most of the time you don&rsquo;t need to care about how the function accomplishes its purpose (that&rsquo;s what the function does inside)</p><p>Good names: in a big function, a piece of code puts a comment that distills it into a function, and the comment often suggests a good name.</p><p><strong>Practice</strong>*</p><p><strong>Create a new function: name it after “what it does”, not “how it does it”</strong>.</p><p>Without local variables, refine directly into a function;</p><p>with local variables but read-only, passed as arguments to the target function</p><p>Local variables are assigned values: declared directly in the refining function if they are used only within the refining function; used outside the refining function as the return value of the refining function; multiple variables are modified by considering returning an object or using other refactoring techniques (querying instead of temporary variables, splitting variables)</p><h2 id=2-inline-function>2. <strong>Inline Function</strong><a hidden class=anchor aria-hidden=true href=#2-inline-function>#</a></h2><p><img loading=lazy src=/img/0_refactor-2.png alt></p><p><img loading=lazy src=/img/0_refactor-3.png alt></p><p><img loading=lazy src=/img/0_refactor-4.png alt></p><p><strong>Indirectness may help, but non-essential indirectness is always uncomfortable.</strong></p><p>Some functions have their contents and names clear and easy to read</p><p>A group of functions is not well organized, inline to one big function first, then refine.</p><h2 id=3-extract-variable>3. <strong>Extract Variable</strong><a hidden class=anchor aria-hidden=true href=#3-extract-variable>#</a></h2><p><img loading=lazy src=/img/0_refactor-5.png alt></p><p><img loading=lazy src=/img/0_refactor-6.png alt></p><p><strong>Variables provide the right context</strong>: they help us break up expressions into more manageable forms, and also make it easier to understand what a portion of the code is doing.</p><p>According to The Tao of Tidy Code, “<strong>Use explanatory variables to break up the computation into a series of well-named intermediate values</strong>”.</p><h2 id=4-inline-variable>4. <strong>Inline Variable</strong><a hidden class=anchor aria-hidden=true href=#4-inline-variable>#</a></h2><p><img loading=lazy src=/img/0_refactor-7.png alt></p><p><img loading=lazy src=/img/0_refactor-8.png alt></p><p>Sometimes, <strong>variable names are no more expressive</strong> than the expression itself. There are also times when variables may get in the way of refactoring nearby code.</p><h2 id=5-rename-variable>5. <strong>Rename Variable</strong><a hidden class=anchor aria-hidden=true href=#5-rename-variable>#</a></h2><p><img loading=lazy src=/img/0_refactor-9.png alt></p><p>Explain what a piece of program is doing, <strong>and be more careful naming fields whose scope extends beyond a single function call.</strong></p><h2 id=6-change-function-declaration>6. <strong>Change Function Declaration</strong><a hidden class=anchor aria-hidden=true href=#6-change-function-declaration>#</a></h2><p><img loading=lazy src=/img/0_refactor-10.png alt></p><p>A good name gives an immediate indication of what the <strong>function is used for</strong>;</p><p>The argument list of a <strong>function</strong> describes how the function coexists with the outside world, and modifying the argument list not only increases the scope of the function&rsquo;s application, but also removes unnecessary coupling by changing the conditions required to connect a module.</p><p><strong>&ldquo;A good way to improve the name of a function: write a comment describing what the function is used for, then turn that comment into the name of the function.”</strong></p><h2 id=7-introduce-parameter-object>7. <strong>Introduce Parameter Object</strong><a hidden class=anchor aria-hidden=true href=#7-introduce-parameter-object>#</a></h2><p><img loading=lazy src=/img/0_refactor-11.png alt></p><p>Organize data into structures that make the <strong>relationships</strong> between data items clearer;</p><p><strong>shorter parameter list</strong>;</p><p><strong>Code consistency</strong>: all functions that use this data structure can access elements of it by the same name.</p><p>Changing the conceptual picture of the code elevates these data structures to new abstractions</p><h2 id=8-combine-functions-into-class>8. <strong>Combine Functions into Class</strong><a hidden class=anchor aria-hidden=true href=#8-combine-functions-into-class>#</a></h2><p><img loading=lazy src=/img/0_refactor-12.png alt></p><p><strong>If you find a group of functions that manipulate the same piece of data (usually by passing that piece of data as a parameter to the function), it&rsquo;s time to form a class</strong>. Classes explicitly provide a common environment for these functions, and calling them from within an object simplifies function calls by passing many fewer arguments.</p><h2 id=9-split-phase>9. <strong>Split Phase</strong><a hidden class=anchor aria-hidden=true href=#9-split-phase>#</a></h2><p><img loading=lazy src=/img/0_refactor-13.png alt></p><p>A piece of code that handles two different things at <strong>simultaneously</strong> can be considered to be <strong>split into its own separate modules</strong>, because then each topic can be handled separately when it comes time to make changes.</p><h1 id=3-encapsulate><strong>3. Encapsulate</strong><a hidden class=anchor aria-hidden=true href=#3-encapsulate>#</a></h1><h2 id=1-encapsulate-record>1. <strong>Encapsulate Record</strong><a hidden class=anchor aria-hidden=true href=#1-encapsulate-record>#</a></h2><p><img loading=lazy src=/img/0_refactor-14.png alt></p><p>Objects can hide details of the structure, <strong>help with renaming of fields</strong>, and are easy to expand to cope with changes.</p><h2 id=2-encapsulate-variable>2. <strong>Encapsulate Variable</strong><a hidden class=anchor aria-hidden=true href=#2-encapsulate-variable>#</a></h2><p><img loading=lazy src=/img/0_refactor-15.png alt></p><p>For all mutable data, as long as its scope extends beyond a single function, I encapsulate it and only allow access through the function. The larger the scope of the data, the more important encapsulation becomes.</p><h2 id=3-encapsulate-collection>3. <strong>Encapsulate Collection</strong><a hidden class=anchor aria-hidden=true href=#3-encapsulate-collection>#</a></h2><p><img loading=lazy src=/img/0_refactor-16.png alt></p><p>One mistake people often make when encapsulating collections is that ** only encapsulates access to the collection variables, but still lets the fetch function return the collection itself. This allows the collection&rsquo;s member variables to be modified directly, while the class encapsulating it is completely unaware and unable to intervene**.</p><p>Practice:</p><p>Provide methods to modify the collection on the class &mdash;&mdash;<strong>Usually “add” and “remove” methods to unify the management</strong>.</p><h2 id=4-substitute-algorithm>4. <strong>Substitute Algorithm</strong><a hidden class=anchor aria-hidden=true href=#4-substitute-algorithm>#</a></h2><p><img loading=lazy src=/img/0_refactor-17.png alt></p><h1 id=3-move-characteristics><strong>3. Move Characteristics</strong><a hidden class=anchor aria-hidden=true href=#3-move-characteristics>#</a></h1><p>Another type of refactoring that is also important is <strong>moving elements between contexts</strong>.</p><h2 id=1-搬移函数move-function>1. <strong>搬移函数（Move Function）</strong><a hidden class=anchor aria-hidden=true href=#1-搬移函数move-function>#</a></h2><p><img loading=lazy src=/img/0_refactor-18.png alt></p><p><strong>任何函数都需要具备上下文环境才能存活</strong>。</p><p>搬移函数最直接的一个动因是，<strong>它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少</strong>，将函数移动到联系更紧密的上下文那么系统别处就可以减少对当前模块的依赖，<strong>获得更好的封装效果。</strong></p><p>整理代码时，发现需要<strong>频繁调用一个别处的函数</strong>；或者函数内部定义了一个帮助函数，而该帮助函数可能<strong>在别的地方也有用处</strong>，此时就可以将它搬移到某些更通用的地方。</p><p><strong>是否需要搬移函数常常不易抉择，但决定越难做，通常说明"搬移这个函数与否"的重要性也越低。</strong></p><p><strong>范例：搬移内嵌函数至顶层</strong></p><p>before：</p><p>计算两点之间距离的函数在别处也有调用</p><p><img loading=lazy src=/img/0_refactor-19.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-20.png alt></p><h2 id=2-搬移语句到函数move-statements-into-function>2. <strong>搬移语句到函数（Move Statements into Function）</strong><a hidden class=anchor aria-hidden=true href=#2-搬移语句到函数move-statements-into-function>#</a></h2><p><img loading=lazy src=/img/0_refactor-21.png alt></p><p><strong>&ldquo;消除重复&rdquo;</strong>：如果发现调用某个函数时，总有一些相同的代码也需要每次执行，则考虑将此段代码合并到函数里头。</p><p><strong>如果某些语句与一个函数放在一起更像一个整体</strong>，并且更<strong>有助于理解</strong>，则将语句搬移到函数里去。<strong>如果它们与函数不像一个整体</strong>，但仍应与函数一起执行，可以用<strong>提炼函数将语句和函数一并提炼出去</strong>。</p><p><strong>五. 重新组织数据</strong></p><p>1. <strong>拆分变量（Split Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-22.png alt></p><p>除"循环变量"和"结果收集变量"外，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种**变量应该只被赋值一次。**如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，<strong>保持职责单一</strong>。</p><p><strong>范例：对输入参数赋值</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-23.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-24.png alt></p><p><strong>六. 简化条件逻辑</strong></p><p>1. <strong>分解条件表达式（Decompose Conditional）</strong></p><p><img loading=lazy src=/img/0_refactor-25.png alt></p><p>程序之中，复杂的条件逻辑是最常导致复杂度上升的因素之一。</p><p>对于条件逻辑，<strong>将每个分支条件分解成新函数</strong>还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p><p>注：实际上为<strong>提炼函数</strong>的一个应用场景。</p><p>2. <strong>合并条件表达式（Consolidate Conditional Expression）</strong></p><p><img loading=lazy src=/img/0_refactor-26.png alt></p><p>3. <strong>以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard
Clauses）</strong></p><p><img loading=lazy src=/img/0_refactor-27.png alt></p><p>如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。<strong>这样的单独检查常常被称为"卫语句&rdquo;（guard
clauses）</strong>。</p><p><strong>如果使用if-then-else结构，则对if分支和else分支的重视是同等的；以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。</strong></p><p>&ldquo;每个函数只能有一个入口和一个出口"的观念未必有用，<strong>保持代码清晰才是最关键的</strong>。</p><p><strong>范例</strong></p><p>before</p><p><img loading=lazy src=/img/0_refactor-28.png alt></p><p>after</p><p><img loading=lazy src=/img/0_refactor-29.png alt></p><p><strong>范例：将条件反转</strong></p><p>初始</p><p><img loading=lazy src=/img/0_refactor-30.png alt></p><p>反转</p><p><img loading=lazy src=/img/0_refactor-31.png alt></p><p>合并条件表达式</p><p><img loading=lazy src=/img/0_refactor-32.png alt></p><p>删除可变变量</p><p><img loading=lazy src=/img/0_refactor-33.png alt></p><p>4. <strong>以多态取代条件表达式（Replace Conditional with Polymorphism）</strong></p><p><img loading=lazy src=/img/0_refactor-34.png alt></p><p><strong>七. 重构API</strong></p><p><strong>以查询取代参数（Replace Parameter with Query）</strong></p><p><img loading=lazy src=/img/0_refactor-35.png alt></p><p><strong>函数的参数列表应该总结该函数的可变性</strong>，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，<strong>参数列表应该尽量避免重复</strong>，并且参数列表越短就越容易理解。</p><p>使用场景：调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易</p><p>什么是"同样容易&rdquo;：函数可以承担这份原本由调用方所承担的"获得正确的参数值"的责任。</p><p>什么时候不适用：移除参数可能会给函数体增加不必要的依赖关系。</p><p><strong>以参数取代查询（Replace Query with Parameter）</strong></p><p><img loading=lazy src=/img/0_refactor-36.png alt></p><p>好处：<strong>改变依赖关系</strong>，去掉令人不快的引用。</p><p>注意：<strong>要考虑责任分配问题，会增加函数调用者的复杂度，而设计接口时又需要考虑易用性</strong>。</p><p><strong>八. 处理继承关系</strong></p><p><strong>以委托取代超类（Replace Superclass with Delegate）</strong></p><p><img loading=lazy src=/img/0_refactor-37.png alt></p><p>继承：子类继承父类的特征和行为 （车-交通工具）</p><p>组合：通过对现有对象进行拼装即组合产生新的具有更复杂的功能 （车-轮胎）</p><p>以组合取代继承。</p><p><strong>一个经典的误用继承的例子：</strong></p><p><strong>让栈（stack）继承列表（list）</strong>。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。<strong>更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了</strong>。</p><hr><p>Java<br>public class Stack&lt;E> extends Vector&lt;E> {<br>public E push(E item) {<br>addElement(item);<br>return item;<br>}<br>public synchronized E pop() {<br>E obj;<br>int len = size();<br>obj = peek();<br>removeElementAt(len - 1);<br>return obj;<br>}<br>}</p><hr><p>Stack真正需要的只有四个方法，push/pop/size/isEmpty， Stack只用到了
Vector的两个方法 isEmpty 和 size，而 push 和 pop 是 Stack 自有的实现，
Vector 有大量的方法， 不适用于stack。</p><p><strong>所以，如果父类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。</strong></p><p>同时也要避免走弯路：完全避免使用继承，如果符合继承关系的语义条件（超类的所有方法都适用于子类，子类的所有实例都是超类的实例），那么继承是一种简洁又高效的复用机制。</p><p>建议：<strong>首先（尽量）使用继承，如果发现继承有问题，再使用以委托取代超类。</strong></p><p><strong>范例</strong></p><p>背景：</p><p>给一个古城里存放上古卷轴（scroll）的图书馆做了咨询。他们给卷轴的信息编制了一份目录（catalog），每份卷轴都有一个ID号，并记录了卷轴的标题（title）和一系列标签（tag），这些古老的卷轴需要日常清扫，因此代表卷轴的Scroll类继承了代表目录项的CatalogItem类，并扩展出与"需要清扫"相关的数据。</p><p><img loading=lazy src=/img/0_refactor-38.png alt></p><p><img loading=lazy src=/img/0_refactor-39.png alt></p><p>这就是一个常见的建模错误。真实存在的卷轴和只存在于纸面上的目录项，是完全不同的两种东西。比如说，关于"如何治疗灰鳞病"的卷轴可能有好几卷，但在目录上却只记录一个条目。这样的建模错误很多时候可以置之不理。像"标题"和"标签"这样的数据，可以认为就是目录中数据的副本。如果这些数据从不发生改变，可以接受这样的表现形式。但如果需要更新其中某处数据，就必须非常小心，确保同一个目录项对应的所有数据副本都被正确地更新。</p><p>就算没有数据更新的问题，把目录类作为卷轴类的父类，依然会让后来的开发者感到迷惑。</p><p>首先在Scroll类中创建一个属性，令其指向一个新建的CatalogItem实例。</p><p><img loading=lazy src=/img/0_refactor-40.png alt></p><p>然后对于子类中用到所有属于超类的函数，我要逐一为它们创建转发函数。</p><p><img loading=lazy src=/img/0_refactor-41.png alt></p><p><strong>详细笔记</strong></p><p><strong>第1章 重构，第一个示例</strong></p><p>本质上说，重构就是在代码写好之后改进它的设计。</p><p>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。</p><p>是需求的变化使重构变得必要。</p><p>重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。</p><p>每次想将一块代码抽取成一个函数时，遵循一个标准流程：最大程度减少犯错的可能。&mdash;&mdash;<strong>提炼函数</strong></p><p>重构技术就是<strong>以微小的步伐修改程序</strong>。如果你犯下错误，很容易便可发现它。</p><p><strong>营地法则</strong>：保证离开时的代码库一定比你来时更加健康。完美的境界很难达到，但应该时时都<strong>勤加拂拭</strong>。</p><p>以实例展开如何重构：包括提炼函数、内联变量、搬移函数和以多态取代条件表达式等，</p><p>几个重要的阶段：将原函数分解成一组嵌套的函数、应用拆分阶段分离计算逻辑与输出格式化逻辑，以及为计算器引入多态性来处理计算逻辑。每一步都给代码添加了更多的结构，以便更好地表达代码的意图。</p><p>好代码的检验标准就是人们是否能轻而易举地修改它。</p><p>总结：</p><p>开展高效有序的重构，关键的心得是：<strong>小的步子可以更快前进</strong>，请保持代码永远处于可工作状态，小步修改累积起来也能大大改善系统的设计。</p><p><strong>第2章　重构的原则</strong></p><p><strong>为何重构</strong></p><p>它不是一颗"银弹"，却可以算是一把"银钳子"，可以帮你始终良好地控制自己的代码。重构是一个工具</p><p><strong>重构改进软件的设计</strong></p><p>代码结构的流失有累积效应。经常性的重构有助于代码维持自己该有的形态。消除重复代码，以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。</p><p><strong>重构使软件更容易理解</strong></p><p>在重构上花一点点时间，就可以让代码更好地表达自己的意图&mdash;&mdash;更清晰地说出我想要做的。</p><p><strong>重构帮助找到bug</strong></p><p>Kent
Beck经常形容自己的一句话：&ldquo;我不是一个特别好的程序员，我只是一个有着一些特别好的习惯的还不错的程序员。&rdquo;</p><p><strong>重构提高编程速度</strong></p><p><img loading=lazy src=/img/0_refactor-42.png alt></p><p>需要添加新功能时，内部质量良好的软件让我可以很容易找到在哪里修改、如何修改。良好的模块划分使我只需要理解代码库的一小部分，就可以做出修改。如果代码很清晰，引入bug的可能性就会变小。</p><p>&ldquo;设计耐久性假说&rdquo;：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间地保持开发的快速。</p><p><strong>何时重构</strong></p><p><strong>预备性重构：让添加新功能更容易</strong></p><p>重构的最佳时机就在添加新功能之前。</p><p>如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样bug的概率也会降低。</p><p><strong>帮助理解的重构：使代码更易懂</strong></p><p><strong>捡垃圾式重构</strong></p><p><strong>有计划的重构和见机行事的重构</strong></p><p>预备性重构、帮助理解的重构、捡垃圾式重构&mdash;&mdash;都是见机行事的</p><p><strong>长期重构</strong></p><p>如果想替换掉一个正在使用的库，可以先如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得多。</p><p><strong>复审代码时重构</strong></p><p>与原作者肩并肩坐在一起，一边浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向结对编程：在编程的过程中持续不断地进行代码复审。</p><p><strong>重构的挑战</strong></p><p><strong>延缓新功能开发</strong></p><p>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</p><p>有时会看到一个（大规模的）重构很有必要进行，而马上要添加的功能非常小，这时应先把新功能加上，然后再做这次大规模重构。</p><p>重构不足的情况远多于重构过度的情况。换句话说，绝大多数人应该尝试多做重构。</p><p>重构的意义不在于把代码库打磨得闪闪发光，而是纯粹经济角度出发的考量。我们之所以重构，因为它能让我们更快&mdash;&mdash;添加功能更快，修复bug更快。</p><p><strong>代码所有权</strong></p><p>旧的接口标记为"不推荐使用"（deprecated）。</p><p><strong>分支</strong></p><p>持续集成（Continuous Integration，CI），也叫"基于主干开发"（Trunk-Based
Development）。</p><p><strong>重构、架构和YAGNI</strong></p><p>重构对架构最大的影响在于，通过重构，我们能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。&ldquo;在编码之前先完成架构"这种做法最大的问题在于，它假设了软件的需求可以预先充分理解。</p><p><strong>重构与软件开发过程</strong></p><p>既牢固可靠又能快速响应变化的需求。</p><p><strong>自动化重构</strong></p><p>不仅能处理文本，还能处理语法树，这是IDE相比于文本编辑器更先进的地方。重构工具不仅需要理解和修改语法树，还要知道如何把修改后的代码写回编辑器视图。如果我给一个变量改名，工具会提醒我修改使用了旧名字的注释。能借助语法树来分析和重构程序代码，这是IDE与普通文本编辑器相比具有的一大优势。</p><p><strong>第3章　代码的坏味道</strong></p><p><strong>神秘命名（Mysterious Name）</strong></p><p>命名是编程中最难的两件事之一[mf-2h]。正因为如此，改名可能是最常用的重构手法，包括改变函数声明（用于给函数改名）、变量改名、字段改名。</p><p><strong>重复代码（Duplicated Code）</strong></p><p><strong>过长函数（Long Function）</strong></p><p>积极地分解函数.</p><p>原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。关键不在于函数的长度，而在于函数"做什么"和"如何做"之间的语义距离。</p><p>如何确定该提炼哪一段代码呢？一个很好的技巧是：寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。</p><p>条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式处理条件表达式。</p><p>对于庞大的switch语句，其中的每个分支都应该通过提炼函数变成独立的函数调用。如果有多个switch语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式。</p><p>应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环将其拆分成各自独立的任务。</p><p><strong>过长参数列表（Long Parameter List）</strong></p><p>如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数去掉这第二个参数。</p><p>如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整手法，直接传入原来的数据结构。如果有几项参数总是同时出现，可以用引入参数对象将其合并成一个对象。</p><p>如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数。</p><p>使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用函数组合成类，将这些共同的参数变成这个类的字段。</p><p><strong>全局数据（Global Data）</strong></p><p>封装变量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。</p><p><strong>可变数据（Mutable Data）</strong></p><p>可以用封装变量来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进。</p><p>如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句和提炼函数尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。设计API时，可以使用将查询函数和修改函数分离。</p><p>尽早使用移除设值函数，缩小变量作用域。</p><p><strong>发散式变化（Divergent Change）</strong></p><p>如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。</p><p>提炼拆分。</p><p><strong>霰弹式修改（Shotgun Surgery）</strong></p><p>如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。</p><p>搬移函数和搬移字段把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段。</p><p>一个常用的策略就是使用与内联（inline）相关的重构&mdash;&mdash;如内联函数（1或是内联类&mdash;&mdash;把本不该分散的逻辑拽回一处。完成内联之后，你可能会闻到过长函数或者过大的类的味道，再用与提炼相关的重构手法将其拆解成更合理的小块。</p><p><strong>依恋情结（Feature Envy）</strong></p><p>模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。</p><p>一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。</p><p><strong>数据泥团（Data Clumps）</strong></p><p>总是绑在一起出现的数据真应该拥有属于它们自己的对象。</p><p><strong>基本类型偏执（Primitive Obsession）</strong></p><p>把钱当作普通数字来计算的情况、计算物理量时无视单位（如把英寸与毫米相加）的情况以及大量类似if
(a &lt; upper && a > lower)这样的代码。</p><p>运用以对象取代基本类型。</p><p><strong>重复的switch （Repeated Switches）</strong></p><p>多态。</p><p><strong>循环语句（Loops）</strong></p><p>？管道操作（如filter和map）</p><p><strong>冗赘的元素（Lazy Element）</strong></p><p>随着重构的进行越变越小，类最后只剩了一个函数。及时删除这个类，使用内联函数或是内联类。</p><p><strong>夸夸其谈通用性（Speculative Generality）</strong></p><p>用不上的装置只会挡你的路，所以，把它搬开吧。</p><p><strong>临时字段（Temporary Field）</strong></p><p>其内部某个字段仅为某种特定情况而设。</p><p><strong>过长的消息链（Message Chains）</strong></p><p>先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数把这个函数推入消息链。</p><p><strong>中间人（Middle Man）</strong></p><p>某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用移除中间人。</p><p><strong>内幕交易（Insider Trading）</strong></p><p>模块之间大量交换数据，因为这会增加模块间的耦合。</p><p>在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。</p><p><strong>过大的类（Large Class）</strong></p><p><strong>异曲同工的类（Alternative Classes with Different Interfaces）</strong></p><p><strong>纯数据类（Data Class）</strong></p><p>纯数据类：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。</p><p><strong>被拒绝的遗赠（Refused Bequest）</strong></p><p>子类应该继承超类的函数和数据。</p><p>不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类或者以委托取代超类彻底划清界限。</p><p><strong>注释（Comments）</strong></p><p>如果你需要注释来解释一块代码做了什么，试试提炼函数；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明为它改名；如果你需要注释说明某些系统的需求规格，试试引入断言。</p><p><strong>第4章　构筑测试体系</strong></p><p><strong>自测试代码的价值</strong></p><p><strong>时间统计：编写代码的时间仅占所有时间中很少的一部分。有些时间用来决定下一步干什么，有些时间花在设计上，但是，花费在调试上的时间是最多的。</strong></p><p>一套测试就是一个强大的bug侦测器，能够大大缩减查找bug所需的时间。</p><p>撰写测试代码的最好时机是在开始动手编码之前，把注意力集中于接口而非实现。</p><p><strong>测试实例</strong></p><p><strong>总是确保测试不该通过时真的会失败：在代码中暂时引入一个错误。</strong></p><p><strong>探测边界条件</strong></p><p>输入：空集合、0、空字符串... 预期输出：？</p><p><strong>考虑可能出错的边界条件</strong>，把测试火力集中在那儿。</p><p>不要因为测试无法捕捉所有的bug就不写测试，因为测试的确可以捕捉到大多数bug。</p><p><strong>第5章　介绍重构名录</strong></p><p>本章主要作用是承上启下，略。</p><p><strong>第6章 第一组重构</strong></p><p><strong>提炼函数（Extract Function）</strong></p><p><img loading=lazy src=/img/0_refactor.png alt></p><p><img loading=lazy src=/img/0_refactor-1.png alt></p><p><strong>动机</strong></p><p><strong>将意图与实现分开</strong>：如果你需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名。因为大多数时候根本不需要关心函数如何达成其用途（这是函数体内干的事）</p><p>好名字：在一个大函数中，一段代码放着一句注释，提炼成函数，注释往往提示一个好名字。</p><p><strong>做法</strong></p><p>创造一个新函数：以"做什么"而非"怎么做"来命名。</p><p>无局部变量，直接提炼成函数；</p><p>有局部变量但只读，作为参数传递给目标函数</p><p>局部变量被赋值：只在提炼函数中被使用则可直接声明在提炼函数中；在提炼函数外也被使用则可作为提炼函数的返回值；多个变量被修改可考虑返回一个对象或者使用其他重构手法（以查询取代临时变量、拆分变量）</p><p><strong>内联函数（Inline Function）</strong></p><p><img loading=lazy src=/img/0_refactor-2.png alt></p><p><img loading=lazy src=/img/0_refactor-3.png alt></p><p><img loading=lazy src=/img/0_refactor-4.png alt></p><p><strong>动机</strong></p><p><strong>间接性可能带来帮助，但非必要的间接性总是让人不舒服。</strong></p><p>某些函数其内容和名称清晰易读</p><p>一群函数的组织不甚合理，先内联到一个大函数，再提炼。</p><p><strong>做法</strong></p><p>确定函数不具多态性</p><p>找到所有调用点执行替换（重点在于始终小步前进）</p><p><strong>提炼变量（Extract Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-5.png alt></p><p><img loading=lazy src=/img/0_refactor-6.png alt></p><p><strong>动机</strong></p><p><strong>提供了合适的上下文</strong>：帮助我们将表达式分解为比较容易管理的形式，也便于理解一部分代码是干什么的。</p><p><strong>内联变量（Inline Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-7.png alt></p><p><img loading=lazy src=/img/0_refactor-8.png alt></p><p><strong>动机</strong></p><p>有时候，变量名字并不比表达式本身更具表现力。还有些时候，变量可能会妨碍重构附近的代码。</p><p><strong>改变函数声明（Change Function Declaration）</strong></p><p><img loading=lazy src=/img/0_refactor-10.png alt></p><p><strong>动机</strong></p><p>一个好名字能让人一眼看出函数的用途；</p><p>函数的参数列表阐述了函数如何与外部世界共处，修改参数列表不仅能增加函数的应用范围，还能改变连接一个模块所需的条件，从而去除不必要的耦合。</p><p><strong>封装变量（Encapsulate Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-15.png alt></p><p><strong>动机</strong></p><p>对于所有可变的数据，只要它的作用域超出单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。</p><p><strong>变量改名（Rename Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-9.png alt></p><p><strong>动机</strong></p><p>解释一段程序在干什么，<strong>对于作用域超出一次函数调用的字段，则需要更用心命名。</strong></p><p><strong>引入参数对象（Introduce Parameter Object）</strong></p><p><img loading=lazy src=/img/0_refactor-11.png alt></p><p><strong>动机</strong></p><p>将数据组织成结构，使数据项之间的<strong>关系更清晰</strong>；</p><p><strong>缩短参数列表</strong>；</p><p><strong>代码一致性</strong>：所有使用该数据结构的函数都可以通过相同的名字来访问其中元素。</p><p>改变代码的概念图景，将这些数据结构提升为新的抽象概念</p><p><strong>函数组合成类（Combine Functions into Class）</strong></p><p><img loading=lazy src=/img/0_refactor-12.png alt></p><p><strong>动机</strong></p><p>如果发现一组函数形影不离地操作同一块数据（通常是将这块数据作为参数传递给函数），是时候组建一个类了。类能明确地给这些函数提供一个共用的环境，在对象内部调用这些函数可以少传许多参数，从而简化函数调用。</p><p><strong>函数组合成变换（Combine Functions into Transform）</strong></p><p><img loading=lazy src=/img/0_refactor-43.png alt></p><p><strong>动机</strong></p><p>在软件中，经常需要把数据"喂"给一个程序，让它<strong>再计算出各种派生信息</strong>。这些派生数值可能会在几个不同地方用到，因此<strong>这些计算逻辑也常会在用到派生数据的地方重复</strong>。把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免到处重复。</p><p><strong>函数组合成变换</strong>与<strong>函数组合成类</strong>区别：</p><p>如果代码中会对源数据做更新，那么使用类要好得多；如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。</p><p><strong>拆分阶段（Split Phase）</strong></p><p><img loading=lazy src=/img/0_refactor-13.png alt></p><p><strong>动机</strong></p><p>一段代码在<strong>同时处理两件不同的事</strong>，可以考虑把它<strong>拆分成各自独立的模块</strong>，因为这样到了需要修改的时候，可以单独处理每个主题。</p><p><strong>例子</strong></p><p>重构前：</p><p><img loading=lazy src=/img/0_refactor-44.png alt></p><p>重构后：</p><p>提炼函数、引入中转数据结构：</p><p><img loading=lazy src=/img/0_refactor-45.png alt></p><p><strong>第七章 封装</strong></p><p><strong>封装记录（Encapsulate Record）</strong></p><p><img loading=lazy src=/img/0_refactor-14.png alt></p><p><strong>动机</strong></p><p>对象可以隐藏结构的细节，有助于字段的改名，方便拓展以应对变化。</p><p><strong>封装集合（Encapsulate Collection）</strong></p><p><img loading=lazy src=/img/0_refactor-16.png alt></p><p><strong>动机</strong></p><p>封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。</p><p>做法：</p><p>在类上提供一些修改集合的方法&mdash;&mdash;通常是"添加"和"移除"方法。</p><p><strong>以对象取代基本类型（Replace Primitive with Object）</strong></p><p><img loading=lazy src=/img/0_refactor-46.png alt></p><p><strong>以查询取代临时变量（Replace Temp with Query）</strong></p><p><img loading=lazy src=/img/0_refactor-47.png alt></p><p><strong>提炼类（Extract Class）</strong></p><p><img loading=lazy src=/img/0_refactor-48.png alt></p><p><strong>动机</strong></p><p>如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。</p><p>如果你发现子类化只影响类的部分特性，或如果你发现某些特性需要以一种方式来子类化，某些特性则需要以另一种方式子类化，这就意味着你需要分解原来的类。</p><p><strong>内联类（Inline Class）</strong></p><p><img loading=lazy src=/img/0_refactor-49.png alt></p><p><strong>隐藏委托关系（Hide Delegate）</strong></p><p><img loading=lazy src=/img/0_refactor-50.png alt></p><p><strong>移除中间人（Remove Middle Man）</strong></p><p><img loading=lazy src=/img/0_refactor-51.png alt></p><p>&ldquo;合适的隐藏程度&rdquo;。</p><p><strong>替换算法（Substitute Algorithm）</strong></p><p><img loading=lazy src=/img/0_refactor-17.png alt></p><p><strong>第8章　搬移特性</strong></p><p>另一种类型的重构也很重要，那就是<strong>在不同的上下文之间搬移元素</strong>。</p><p><strong>搬移函数（Move Function）</strong></p><p><img loading=lazy src=/img/0_refactor-18.png alt></p><p><strong>任何函数都需要具备上下文环境才能存活</strong>。</p><p>搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少，将函数移动到联系更紧密的上下文那么系统别处就可以减少对当前模块的依赖，<strong>获得更好的封装效果。</strong></p><p>整理代码时，发现需要频繁调用一个别处的函数；或者函数内部定义了一个帮助函数，而该帮助函数可能在别的地方也有用处，此时就可以将它搬移到某些更通用的地方。</p><p><strong>是否需要搬移函数常常不易抉择，但决定越难做，通常说明"搬移这个函数与否"的重要性也越低。</strong></p><p><strong>范例：搬移内嵌函数至顶层</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-19.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-20.png alt></p><p><strong>范例：在类之间搬移函数</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-52.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-53.png alt></p><p><strong>搬移字段（Move Field）</strong></p><p><img loading=lazy src=/img/0_refactor-54.png alt></p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-55.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-56.png alt></p><p><img loading=lazy src=/img/0_refactor-57.png alt></p><p><strong>范例：搬移字段到共享对象</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-58.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-59.png alt></p><p><img loading=lazy src=/img/0_refactor-60.png alt></p><p><strong>搬移语句到函数（Move Statements into Function）</strong></p><p><img loading=lazy src=/img/0_refactor-21.png alt></p><p><strong>&ldquo;消除重复&rdquo;</strong>：如果发现调用某个函数时，总有一些相同的代码也需要每次执行，则考虑将此段代码合并到函数里头。</p><p>如果某些语句与一个函数放在一起更像一个整体，并且更<strong>有助于理解</strong>，则将语句搬移到函数里去。如果它们与函数不像一个整体，但仍应与函数一起执行，可以用提炼函数将语句和函数一并提炼出去。</p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-61.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-62.png alt></p><p><strong>搬移语句到调用者（Move Statements to Callers）</strong></p><p><img loading=lazy src=/img/0_refactor-63.png alt></p><p>随着系统能力发生演进，原先设定的抽象边界总会悄无声息地发生偏移。对于函数来说，这样的边界偏移意味着曾经视为一个整体、一个单元的行为，如今可能已经分化出两个甚至是多个不同的关注点。</p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-64.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-65.png alt></p><p><strong>以函数调用取代内联代码（Replace Inline Code with Function Call）</strong></p><p><img loading=lazy src=/img/0_refactor-66.png alt></p><p><strong>移动语句（Slide Statements）</strong></p><p><img loading=lazy src=/img/0_refactor-67.png alt></p><p>让存在关联的东西一起出现，可以使代码更容易理解。</p><p><strong>命令查询分离原则</strong>（Command-Query Separation,CQS原则）：</p><p>**查询：**方法返回结果，但不改变任何系统状态(无副作用)。</p><p>**命令：**方法没有结果，但会改变系统状态。</p><p>优点如下</p><p>查询类型的方法，对于调用者来讲不用在顾虑各个查询方法的调用顺序和次数(忽略性能的因素)。</p><p>命令类型的方法，从语义上来讲更准确。</p><p><strong>范例</strong></p><p><img loading=lazy src=/img/0_refactor-68.png alt></p><p>思考：哪些语句可以移动？</p><p><strong>范例：包含条件逻辑的移动</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-69.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-70.png alt></p><p><strong>拆分循环（Split Loop）</strong></p><p><img loading=lazy src=/img/0_refactor-71.png alt></p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-72.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-73.png alt></p><p><strong>以管道取代循环（Replace Loop with Pipeline）</strong></p><p><img loading=lazy src=/img/0_refactor-74.png alt></p><p>map运算是指用一个函数作用于输入集合的每一个元素上，将集合变换成另外一个集合的过程；filter运算是指用一个函数从输入集合中筛选出符合条件的元素子集的过程。运算得到的集合可以供管道的后续流程使用。</p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-75.png alt></p><p><img loading=lazy src=/img/0_refactor-76.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-77.png alt></p><p><strong>移除死代码（Remove Dead Code）</strong></p><p><img loading=lazy src=/img/0_refactor-78.png alt></p><p><strong>第9章　重新组织数据</strong></p><p><strong>拆分变量（Split Variable）</strong></p><p><img loading=lazy src=/img/0_refactor-22.png alt></p><p>除"循环变量"和"结果收集变量"外，还有很多变量用于保存一段冗长代码的运算结果，以便稍后使用。这种**变量应该只被赋值一次。**如果它们被赋值超过一次，就意味它们在函数中承担了一个以上的责任。如果变量承担多个责任，它就应该被替换（分解）为多个变量，<strong>保持职责单一</strong>。</p><p><strong>范例：对输入参数赋值</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-23.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-24.png alt></p><p><strong>字段改名（Rename Field）</strong></p><p><img loading=lazy src=/img/0_refactor-79.png alt></p><p><strong>范例：给字段改名</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-80.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-81.png alt></p><p><strong>以查询取代派生变量（Replace Derived Variable with Query）</strong></p><p><img loading=lazy src=/img/0_refactor-82.png alt></p><p><strong>范例</strong></p><p>即时计算，不必每次更新。</p><p>before：</p><p><img loading=lazy src=/img/0_refactor-83.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-84.png alt></p><p><img loading=lazy src=/img/0_refactor-85.png alt></p><p><strong>范例：不止一个数据来源</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-86.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-87.png alt></p><p>引入断言：</p><p><img loading=lazy src=/img/0_refactor-88.png alt></p><p><strong>将引用对象改为值对象（Change Reference to Value）</strong></p><p>不需要共享一个对象。</p><p><img loading=lazy src=/img/0_refactor-89.png alt></p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-90.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-91.png alt></p><p><strong>将值对象改为引用对象（Change Value to Reference）</strong></p><p>共享一个对象。</p><p><img loading=lazy src=/img/0_refactor-92.png alt></p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-93.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-94.png alt></p><p><img loading=lazy src=/img/0_refactor-95.png alt></p><p>存在的问题：构造函数与一个全局的仓库对象<strong>耦合</strong>。</p><p>改进的办法：<strong>将仓库对象作为参数传递给构造函数</strong>。</p><p><strong>第10章　简化条件逻辑</strong></p><p><strong>分解条件表达式（Decompose Conditional）</strong></p><p><img loading=lazy src=/img/0_refactor-25.png alt></p><p>程序之中，复杂的条件逻辑是最常导致复杂度上升的因素之一。</p><p>对于条件逻辑，<strong>将每个分支条件分解成新函数</strong>还可以带来更多好处：可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因。</p><p>注：实际上为提炼函数的一个应用场景。</p><p><strong>范例</strong></p><p>before：</p><p><img loading=lazy src=/img/0_refactor-96.png alt></p><p>after：</p><p><img loading=lazy src=/img/0_refactor-97.png alt></p><p><strong>合并条件表达式（Consolidate Conditional Expression）</strong></p><p><img loading=lazy src=/img/0_refactor-26.png alt></p><p><strong>以卫语句取代嵌套条件表达式（Replace Nested Conditional with Guard
Clauses）</strong></p><p><img loading=lazy src=/img/0_refactor-27.png alt></p><p>如果两条分支都是正常行为，就应该使用形如if...else...的条件表达式；如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查常常被称为"卫语句&rdquo;（guard
clauses）。</p><p><strong>如果使用if-then-else结构，则对if分支和else分支的重视是同等的；以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。</strong></p><p>&ldquo;每个函数只能有一个入口和一个出口"的观念未必有用，保持代码清晰才是最关键的。</p><p><strong>范例</strong></p><p>before</p><p><img loading=lazy src=/img/0_refactor-28.png alt></p><p>after</p><p><img loading=lazy src=/img/0_refactor-29.png alt></p><p><strong>范例：将条件反转</strong></p><p>初始</p><p><img loading=lazy src=/img/0_refactor-30.png alt></p><p>反转</p><p><img loading=lazy src=/img/0_refactor-31.png alt></p><p>合并条件表达式</p><p><img loading=lazy src=/img/0_refactor-32.png alt></p><p>删除可变变量</p><p><img loading=lazy src=/img/0_refactor-33.png alt></p><p><strong>以多态取代条件表达式（Replace Conditional with Polymorphism）</strong></p><p><img loading=lazy src=/img/0_refactor-34.png alt></p><p><strong>引入特例（Introduce Special Case）</strong></p><p><img loading=lazy src=/img/0_refactor-98.png alt></p><p>&ldquo;特例&rdquo;（Special
Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理，<strong>从而用一个函数调用取代大部分特例检查逻辑</strong>。</p><p><strong>引入断言（Introduce Assertion）</strong></p><p><img loading=lazy src=/img/0_refactor-99.png alt></p><p><strong>第11章 重构API</strong></p><p><strong>将查询函数和修改函数分离（Separate Query from Modifier）</strong></p><p><img loading=lazy src=/img/0_refactor-100.png alt></p><p><strong>范例</strong></p><p>before</p><p><img loading=lazy src=/img/0_refactor-101.png alt></p><p>After</p><p><img loading=lazy src=/img/0_refactor-102.png alt></p><p><img loading=lazy src=/img/0_refactor-103.png alt></p><p><strong>函数参数化（Parameterize Function）</strong></p><p><img loading=lazy src=/img/0_refactor-104.png alt></p><p>范例</p><p>before</p><p><img loading=lazy src=/img/0_refactor-105.png alt></p><p>After</p><p><img loading=lazy src=/img/0_refactor-106.png alt>
<img loading=lazy src=/img/0_refactor-107.png alt>
g)</p><p><strong>移除标记参数（Remove Flag Argument）</strong></p><p><img loading=lazy src=/img/0_refactor-108.png alt></p><p><strong>&ldquo;标记参数"是这样的一种参数：调用者用它来指示被调函数应该执行哪一部分逻辑。</strong></p><p><strong>范例</strong></p><p>Before</p><p><img loading=lazy src=/img/0_refactor-109.png alt></p><p>After</p><p><img loading=lazy src=/img/0_refactor-110.png alt></p><p><strong>保持对象完整（Preserve Whole Object）</strong></p><p><img loading=lazy src=/img/0_refactor-111.png alt></p><p>减少函数参数长度，方便后续拓展。</p><p><strong>以查询取代参数（Replace Parameter with Query）</strong></p><p><img loading=lazy src=/img/0_refactor-35.png alt></p><p><strong>函数的参数列表应该总结该函数的可变性</strong>，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，<strong>参数列表应该尽量避免重复</strong>，并且参数列表越短就越容易理解。</p><p>使用场景：调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易</p><p>什么是"同样容易&rdquo;：函数可以承担这份原本由调用方所承担的"获得正确的参数值"的责任。</p><p>什么时候不适用：移除参数可能会给函数体增加不必要的依赖关系。</p><p>留意：如果在处理的函数具有<strong>引用透明性</strong>（referential
transparency，即，不论任何时候，只要传入相同的参数值，该函数的行为永远一致），这样的函数既容易理解又容易测试，不会去除参数，让它访问一个可变的全部变量。</p><p><strong>以参数取代查询（Replace Query with Parameter）</strong></p><p><img loading=lazy src=/img/0_refactor-36.png alt></p><p>好处：改变依赖关系，去掉令人不快的引用。</p><p>注意：要考虑责任分配问题，会增加函数调用者的复杂度，而设计接口时又需要考虑易用性。</p><p><strong>移除设值函数（Remove Setting Method）</strong></p><p><img loading=lazy src=/img/0_refactor-112.png alt></p><p>去除不必要的设值函数。</p><p><strong>以工厂函数取代构造函数（Replace Constructor with Factory Function）</strong></p><p><img loading=lazy src=/img/0_refactor-113.png alt></p><p>工厂函数的实现更为灵活。</p><p><strong>以命令取代函数（Replace Function with Command）</strong></p><p><img loading=lazy src=/img/0_refactor-114.png alt></p><p><strong>以函数取代命令（Replace Command with Function）</strong></p><p><img loading=lazy src=/img/0_refactor-115.png alt></p><p>处理的逻辑不是特别复杂，则命令对象可能显得费而不惠。</p><p><strong>第12章　处理继承关系</strong></p><p><strong>函数上移（Pull Up Method）</strong></p><p><img loading=lazy src=/img/0_refactor-116.png alt></p><p>消除重复代码。</p><p><strong>字段上移（Pull Up Field）</strong></p><p><img loading=lazy src=/img/0_refactor-117.png alt></p><p>同样也是消除重复代码。</p><p><strong>构造函数本体上移（Pull Up Constructor Body）</strong></p><p><img loading=lazy src=/img/0_refactor-118.png alt></p><p>提炼各个子类函数中的重复部分至父类中，同样也是消除重复代码。</p><p><strong>函数下移（Push Down Method）</strong></p><p><img loading=lazy src=/img/0_refactor-119.png alt></p><p>如果超类中的某个函数只与一个（或少数几个）子类有关，那么最好将其从父类中挪走，放到真正关心它的子类中去。</p><p><strong>字段下移（Push Down Field）</strong></p><p><img loading=lazy src=/img/0_refactor-120.png alt></p><p>如果某个字段只被一个子类（或者一小部分子类）用到，就将其搬移到需要该字段的子类中。</p><p><strong>以子类取代类型码（Replace Type Code with Subclasses）</strong></p><p><img loading=lazy src=/img/0_refactor-121.png alt></p><p>可以用多态来处理条件逻辑，而不是根据不同的类型码采取不同的行为。</p><p>有些字段或函数只对特定的类型码取值才有意义，子类的形式能更明确地表达数据与类型之间的关系。</p><p><strong>移除子类（Remove Subclass）</strong></p><p><img loading=lazy src=/img/0_refactor-122.png alt></p><p>如果子类的用处太少，可以移除子类，将替换为父类的一个字段。</p><p><strong>提炼超类（Extract Superclass）</strong></p><p><img loading=lazy src=/img/0_refactor-123.png alt></p><p>目的在于把重复的行为收拢一处。</p><p><strong>折叠继承体系（Collapse Hierarchy）</strong></p><p><img loading=lazy src=/img/0_refactor-124.png alt></p><p>随着继承体系的演化，有时会发现一个类与其父类差别不大，此时可以把父类和子类合并起来。</p><p><strong>以委托取代子类（Replace Subclass with Delegate）</strong></p><p><img loading=lazy src=/img/0_refactor-125.png alt></p><p><img loading=lazy src=/img/0_refactor-126.png alt></p><p>与继承关系相比，使用委托（即组合）关系时接口更清晰、耦合更少。</p><p><strong>以委托取代超类（Replace Superclass with Delegate）</strong></p><p><img loading=lazy src=/img/0_refactor-37.png alt></p><p>以组合取代继承。</p><p>一个经典的误用继承的例子：让栈（stack）继承列表（list）。这个想法的出发点是想复用列表类的数据存储和操作能力。虽说复用是一件好事，但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用。更好的做法应该是把列表作为栈的字段，把必要的操作委派给列表就行了。</p><p><strong>所以，如果超类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。</strong></p><p>同时也要避免走弯路：完全避免使用继承，如果符合继承关系的语义条件（超类的所有方法都适用于子类，子类的所有实例都是超类的实例），那么继承是一种简洁又高效的复用机制。</p><p>建议：首先（尽量）使用继承，如果发现继承有问题，再使用以委托取代超类。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/snippet/>Snippet</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>