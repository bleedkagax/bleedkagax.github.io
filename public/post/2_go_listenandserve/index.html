<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go's `http.ListenAndServe` | Kaga Blog</title>
<meta name=keywords content="Golang"><meta name=description content="Implementation Overview
The ListenAndServe function is part of Go&rsquo;s standard library in the net/http package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/2_go_listenandserve/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/2_go_listenandserve/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go's `http.ListenAndServe`"><meta property="og:description" content="Implementation Overview
The ListenAndServe function is part of Go&rsquo;s standard library in the net/http package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/2_go_listenandserve/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go's `http.ListenAndServe`"><meta name=twitter:description content="Implementation Overview
The ListenAndServe function is part of Go&rsquo;s standard library in the net/http package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Go's `http.ListenAndServe`","item":"https://bleedkagax.github.io/post/2_go_listenandserve/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go's `http.ListenAndServe`","name":"Go\u0027s \u0060http.ListenAndServe\u0060","description":"Implementation Overview The ListenAndServe function is part of Go\u0026rsquo;s standard library in the net/http package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.\nfunc ListenAndServe(addr string, handler Handler) error { server := \u0026amp;Server{Addr: addr, Handler: handler} return server.ListenAndServe() } ","keywords":["Golang"],"articleBody":"Implementation Overview The ListenAndServe function is part of Go’s standard library in the net/http package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.\nfunc ListenAndServe(addr string, handler Handler) error { server := \u0026Server{Addr: addr, Handler: handler} return server.ListenAndServe() } This function creates a Server instance and calls its ListenAndServe method.\nDetailed Implementation The core logic is in the Server.ListenAndServe and Server.Serve methods:\nfunc (srv *Server) ListenAndServe() error { if srv.shuttingDown() { return ErrServerClosed } addr := srv.Addr if addr == \"\" { addr = \":http\" } ln, err := net.Listen(\"tcp\", addr) if err != nil { return err } return srv.Serve(ln) } func (srv *Server) Serve(l net.Listener) error { // ... (initialization code omitted) for { rw, e := l.Accept() if e != nil { // ... (error handling omitted) } c := srv.newConn(rw) go c.serve(connCtx) } } Goroutine Usage Main Goroutine:\nThe ListenAndServe function runs in the calling goroutine (often the main goroutine). It enters an infinite loop in Serve, continuously accepting new connections. Per-Connection Goroutines:\nFor each accepted connection, a new goroutine is spawned (go c.serve(connCtx)). This allows concurrent handling of multiple client connections. No Separate Listener Goroutine:\nUnlike some server implementations, ListenAndServe doesn’t create a dedicated goroutine for listening. The listening and accepting of connections occur in the same goroutine that called ListenAndServe. Waiting Behavior Blocking Nature:\nListenAndServe is a blocking call. It doesn’t return until the server is closed or encounters an unrecoverable error. The main loop in Serve continuously waits for new connections via l.Accept(). Efficient Waiting:\nWhile waiting for connections, the goroutine is in a “sleep” state, not consuming CPU cycles. Go’s runtime uses efficient I/O polling mechanisms (like epoll or kqueue) under the hood. Error Handling and Shutdown:\nThe loop breaks and the function returns if Accept() returns a non-temporary error or if the server is shutting down. Resource Consumption CPU Usage:\nMinimal when waiting for connections, as the goroutine is mostly idle. Memory Usage:\nLow and constant for the main goroutine. Additional memory is used for each client connection goroutine. File Descriptors:\nOne for the listening socket, plus one for each active client connection. Scalability and Performance This design scales well, handling many concurrent connections efficiently. The single listening goroutine doesn’t become a bottleneck, as accepting connections is typically very fast. The per-connection goroutine model allows for high concurrency in request handling. Conclusion Go’s http.ListenAndServe implementation provides an efficient and scalable approach to running an HTTP server:\nIt uses goroutines effectively for concurrent connection handling. The main goroutine blocks efficiently, waiting for new connections without consuming significant resources. This design allows for simple usage in Go programs while providing robust performance for handling HTTP requests. ","wordCount":"454","inLanguage":"en","datePublished":"2024-10-04T00:00:00Z","dateModified":"2024-10-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/2_go_listenandserve/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go's `http.ListenAndServe`</h1><div class=post-meta><span title='2024-10-04 00:00:00 +0000 UTC'>October 4, 2024</span></div></header><div class=post-content><h2 id=implementation-overview>Implementation Overview<a hidden class=anchor aria-hidden=true href=#implementation-overview>#</a></h2><p>The <code>ListenAndServe</code> function is part of Go&rsquo;s standard library in the <code>net/http</code> package. Its primary purpose is to start an HTTP server that listens on a specified address and handles incoming requests.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>handler</span> <span style=color:#a6e22e>Handler</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>server</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Server</span>{<span style=color:#a6e22e>Addr</span>: <span style=color:#a6e22e>addr</span>, <span style=color:#a6e22e>Handler</span>: <span style=color:#a6e22e>handler</span>}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>server</span>.<span style=color:#a6e22e>ListenAndServe</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function creates a <code>Server</code> instance and calls its <code>ListenAndServe</code> method.</p><h2 id=detailed-implementation>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation>#</a></h2><p>The core logic is in the <code>Server.ListenAndServe</code> and <code>Server.Serve</code> methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>srv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>ListenAndServe</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>shuttingDown</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ErrServerClosed</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>addr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>Addr</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>addr</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>addr</span> = <span style=color:#e6db74>&#34;:http&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>addr</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>ln</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>srv</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Server</span>) <span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>l</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listener</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... (initialization code omitted)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rw</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>l</span>.<span style=color:#a6e22e>Accept</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ... (error handling omitted)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>srv</span>.<span style=color:#a6e22e>newConn</span>(<span style=color:#a6e22e>rw</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>serve</span>(<span style=color:#a6e22e>connCtx</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=goroutine-usage>Goroutine Usage<a hidden class=anchor aria-hidden=true href=#goroutine-usage>#</a></h2><ol><li><p><strong>Main Goroutine</strong>:</p><ul><li>The <code>ListenAndServe</code> function runs in the calling goroutine (often the main goroutine).</li><li>It enters an infinite loop in <code>Serve</code>, continuously accepting new connections.</li></ul></li><li><p><strong>Per-Connection Goroutines</strong>:</p><ul><li>For each accepted connection, a new goroutine is spawned (<code>go c.serve(connCtx)</code>).</li><li>This allows concurrent handling of multiple client connections.</li></ul></li><li><p><strong>No Separate Listener Goroutine</strong>:</p><ul><li>Unlike some server implementations, <code>ListenAndServe</code> doesn&rsquo;t create a dedicated goroutine for listening.</li><li>The listening and accepting of connections occur in the same goroutine that called <code>ListenAndServe</code>.</li></ul></li></ol><h2 id=waiting-behavior>Waiting Behavior<a hidden class=anchor aria-hidden=true href=#waiting-behavior>#</a></h2><ol><li><p><strong>Blocking Nature</strong>:</p><ul><li><code>ListenAndServe</code> is a blocking call. It doesn&rsquo;t return until the server is closed or encounters an unrecoverable error.</li><li>The main loop in <code>Serve</code> continuously waits for new connections via <code>l.Accept()</code>.</li></ul></li><li><p><strong>Efficient Waiting</strong>:</p><ul><li>While waiting for connections, the goroutine is in a &ldquo;sleep&rdquo; state, not consuming CPU cycles.</li><li>Go&rsquo;s runtime uses efficient I/O polling mechanisms (like epoll or kqueue) under the hood.</li></ul></li><li><p><strong>Error Handling and Shutdown</strong>:</p><ul><li>The loop breaks and the function returns if <code>Accept()</code> returns a non-temporary error or if the server is shutting down.</li></ul></li></ol><h2 id=resource-consumption>Resource Consumption<a hidden class=anchor aria-hidden=true href=#resource-consumption>#</a></h2><ol><li><p><strong>CPU Usage</strong>:</p><ul><li>Minimal when waiting for connections, as the goroutine is mostly idle.</li></ul></li><li><p><strong>Memory Usage</strong>:</p><ul><li>Low and constant for the main goroutine.</li><li>Additional memory is used for each client connection goroutine.</li></ul></li><li><p><strong>File Descriptors</strong>:</p><ul><li>One for the listening socket, plus one for each active client connection.</li></ul></li></ol><h2 id=scalability-and-performance>Scalability and Performance<a hidden class=anchor aria-hidden=true href=#scalability-and-performance>#</a></h2><ul><li>This design scales well, handling many concurrent connections efficiently.</li><li>The single listening goroutine doesn&rsquo;t become a bottleneck, as accepting connections is typically very fast.</li><li>The per-connection goroutine model allows for high concurrency in request handling.</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Go&rsquo;s <code>http.ListenAndServe</code> implementation provides an efficient and scalable approach to running an HTTP server:</p><ul><li>It uses goroutines effectively for concurrent connection handling.</li><li>The main goroutine blocks efficiently, waiting for new connections without consuming significant resources.</li><li>This design allows for simple usage in Go programs while providing robust performance for handling HTTP requests.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/golang/>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>