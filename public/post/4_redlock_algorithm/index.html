<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redlock Algorithm | Kaga Blog</title>
<meta name=keywords content="Redis"><meta name=description content="Redlock Algorithm: Distributed Lock Management
Introduction
The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose
The main purpose of the Redlock algorithm is to ensure that:

Mutual exclusion is guaranteed
Deadlock free operation is possible
Fault tolerance is achieved up to a certain degree

Algorithm Overview
The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/4_redlock_algorithm/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/4_redlock_algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redlock Algorithm"><meta property="og:description" content="Redlock Algorithm: Distributed Lock Management
Introduction
The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose
The main purpose of the Redlock algorithm is to ensure that:

Mutual exclusion is guaranteed
Deadlock free operation is possible
Fault tolerance is achieved up to a certain degree

Algorithm Overview
The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/4_redlock_algorithm/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redlock Algorithm"><meta name=twitter:description content="Redlock Algorithm: Distributed Lock Management
Introduction
The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose
The main purpose of the Redlock algorithm is to ensure that:

Mutual exclusion is guaranteed
Deadlock free operation is possible
Fault tolerance is achieved up to a certain degree

Algorithm Overview
The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Redlock Algorithm","item":"https://bleedkagax.github.io/post/4_redlock_algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redlock Algorithm","name":"Redlock Algorithm","description":"Redlock Algorithm: Distributed Lock Management Introduction The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.\nPurpose The main purpose of the Redlock algorithm is to ensure that:\nMutual exclusion is guaranteed Deadlock free operation is possible Fault tolerance is achieved up to a certain degree Algorithm Overview The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition.\n","keywords":["Redis"],"articleBody":"Redlock Algorithm: Distributed Lock Management Introduction The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.\nPurpose The main purpose of the Redlock algorithm is to ensure that:\nMutual exclusion is guaranteed Deadlock free operation is possible Fault tolerance is achieved up to a certain degree Algorithm Overview The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition.\nDetailed Steps Lock Acquisition Get the current time in milliseconds. Try to acquire the lock in all N Redis instances sequentially: Use a timeout for each instance that is small compared to the total lock auto-release time. If the instance is unavailable, immediately try the next instance. Calculate the time elapsed to acquire the locks. The lock is considered acquired if: The lock was acquired in the majority of instances (at least N/2 + 1) The total time elapsed is less than the lock validity time If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed. If the lock was not acquired in the majority of instances, try to unlock all instances. Lock Release To release the lock, the client sends an unlock command to all instances, regardless of whether it was able to lock all of them during the acquisition phase or not.\nKey Considerations Clock Drift: The algorithm assumes that the clock drift between nodes is small. Timing: The validity time of the lock should be much larger than the network latency and the clock drift between nodes. Fault Tolerance: The system can tolerate at most N/2 - 1 failed nodes. Advantages High reliability due to multiple Redis instances Resistant to split-brain scenarios Does not require strong consistency between Redis nodes Disadvantages Complexity in implementation and management Increased latency due to communication with multiple Redis instances Potential for reduced availability if multiple Redis instances fail Example Implementation (Pseudocode) def acquire_lock(resource, lock_timeout): start_time = current_time_millis() for redis_instance in redis_instances: try: success = redis_instance.set(resource, unique_value, nx=True, px=lock_timeout) if success: acquired_instances.append(redis_instance) except ConnectionError: continue elapsed_time = current_time_millis() - start_time if len(acquired_instances) \u003e= (N/2 + 1) and elapsed_time \u003c lock_timeout: return True, lock_timeout - elapsed_time else: release_lock(resource, acquired_instances) return False, 0 def release_lock(resource, acquired_instances): for redis_instance in acquired_instances: redis_instance.delete(resource) Conclusion The Redlock algorithm provides a robust solution for distributed lock management, particularly suitable for scenarios where high reliability and fault tolerance are required. However, its complexity and potential performance impact should be carefully considered before implementation.\n","wordCount":"458","inLanguage":"en","datePublished":"2024-10-02T00:00:00Z","dateModified":"2024-10-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/4_redlock_algorithm/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redlock Algorithm</h1><div class=post-meta><span title='2024-10-02 00:00:00 +0000 UTC'>October 2, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#redlock-algorithm-distributed-lock-management aria-label="Redlock Algorithm: Distributed Lock Management">Redlock Algorithm: Distributed Lock Management</a><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#purpose aria-label=Purpose>Purpose</a></li><li><a href=#algorithm-overview aria-label="Algorithm Overview">Algorithm Overview</a></li><li><a href=#detailed-steps aria-label="Detailed Steps">Detailed Steps</a><ul><li><a href=#lock-acquisition aria-label="Lock Acquisition">Lock Acquisition</a></li><li><a href=#lock-release aria-label="Lock Release">Lock Release</a></li></ul></li><li><a href=#key-considerations aria-label="Key Considerations">Key Considerations</a></li><li><a href=#advantages aria-label=Advantages>Advantages</a></li><li><a href=#disadvantages aria-label=Disadvantages>Disadvantages</a></li><li><a href=#example-implementation-pseudocode aria-label="Example Implementation (Pseudocode)">Example Implementation (Pseudocode)</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=redlock-algorithm-distributed-lock-management>Redlock Algorithm: Distributed Lock Management<a hidden class=anchor aria-hidden=true href=#redlock-algorithm-distributed-lock-management>#</a></h1><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.</p><h2 id=purpose>Purpose<a hidden class=anchor aria-hidden=true href=#purpose>#</a></h2><p>The main purpose of the Redlock algorithm is to ensure that:</p><ol><li>Mutual exclusion is guaranteed</li><li>Deadlock free operation is possible</li><li>Fault tolerance is achieved up to a certain degree</li></ol><h2 id=algorithm-overview>Algorithm Overview<a hidden class=anchor aria-hidden=true href=#algorithm-overview>#</a></h2><p>The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition.</p><h2 id=detailed-steps>Detailed Steps<a hidden class=anchor aria-hidden=true href=#detailed-steps>#</a></h2><h3 id=lock-acquisition>Lock Acquisition<a hidden class=anchor aria-hidden=true href=#lock-acquisition>#</a></h3><ol><li>Get the current time in milliseconds.</li><li>Try to acquire the lock in all N Redis instances sequentially:<ul><li>Use a timeout for each instance that is small compared to the total lock auto-release time.</li><li>If the instance is unavailable, immediately try the next instance.</li></ul></li><li>Calculate the time elapsed to acquire the locks.</li><li>The lock is considered acquired if:<ul><li>The lock was acquired in the majority of instances (at least N/2 + 1)</li><li>The total time elapsed is less than the lock validity time</li></ul></li><li>If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed.</li><li>If the lock was not acquired in the majority of instances, try to unlock all instances.</li></ol><h3 id=lock-release>Lock Release<a hidden class=anchor aria-hidden=true href=#lock-release>#</a></h3><p>To release the lock, the client sends an unlock command to all instances, regardless of whether it was able to lock all of them during the acquisition phase or not.</p><h2 id=key-considerations>Key Considerations<a hidden class=anchor aria-hidden=true href=#key-considerations>#</a></h2><ol><li><strong>Clock Drift</strong>: The algorithm assumes that the clock drift between nodes is small.</li><li><strong>Timing</strong>: The validity time of the lock should be much larger than the network latency and the clock drift between nodes.</li><li><strong>Fault Tolerance</strong>: The system can tolerate at most N/2 - 1 failed nodes.</li></ol><h2 id=advantages>Advantages<a hidden class=anchor aria-hidden=true href=#advantages>#</a></h2><ol><li>High reliability due to multiple Redis instances</li><li>Resistant to split-brain scenarios</li><li>Does not require strong consistency between Redis nodes</li></ol><h2 id=disadvantages>Disadvantages<a hidden class=anchor aria-hidden=true href=#disadvantages>#</a></h2><ol><li>Complexity in implementation and management</li><li>Increased latency due to communication with multiple Redis instances</li><li>Potential for reduced availability if multiple Redis instances fail</li></ol><h2 id=example-implementation-pseudocode>Example Implementation (Pseudocode)<a hidden class=anchor aria-hidden=true href=#example-implementation-pseudocode>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>acquire_lock</span>(resource, lock_timeout):
</span></span><span style=display:flex><span>    start_time <span style=color:#f92672>=</span> current_time_millis()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> redis_instance <span style=color:#f92672>in</span> redis_instances:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            success <span style=color:#f92672>=</span> redis_instance<span style=color:#f92672>.</span>set(resource, unique_value, nx<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, px<span style=color:#f92672>=</span>lock_timeout)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> success:
</span></span><span style=display:flex><span>                acquired_instances<span style=color:#f92672>.</span>append(redis_instance)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ConnectionError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    elapsed_time <span style=color:#f92672>=</span> current_time_millis() <span style=color:#f92672>-</span> start_time
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(acquired_instances) <span style=color:#f92672>&gt;=</span> (N<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>and</span> elapsed_time <span style=color:#f92672>&lt;</span> lock_timeout:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>, lock_timeout <span style=color:#f92672>-</span> elapsed_time
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        release_lock(resource, acquired_instances)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>release_lock</span>(resource, acquired_instances):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> redis_instance <span style=color:#f92672>in</span> acquired_instances:
</span></span><span style=display:flex><span>        redis_instance<span style=color:#f92672>.</span>delete(resource)
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>The Redlock algorithm provides a robust solution for distributed lock management, particularly suitable for scenarios where high reliability and fault tolerance are required. However, its complexity and potential performance impact should be carefully considered before implementation.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/redis/>Redis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>