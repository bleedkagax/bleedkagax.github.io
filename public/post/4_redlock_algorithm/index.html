<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Redlock Algorithm - Kaga Blog</title>
<meta name=theme-color><meta name=description content="Redlock Algorithm: Distributed Lock Management
Introduction
The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose
The main purpose of the Redlock algorithm is to ensure that:

Mutual exclusion is guaranteed
Deadlock free operation is possible
Fault tolerance is achieved up to a certain degree

Algorithm Overview
The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><meta name=author content="Kaga Blog"><link rel="preload stylesheet" as=style href=https://bleedkagax.github.io/main.min.css><link rel=preload as=image href=https://bleedkagax.github.io/theme.png><script defer src=https://bleedkagax.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.0"><meta itemprop=name content="Redlock Algorithm"><meta itemprop=description content="Redlock Algorithm: Distributed Lock Management Introduction The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose The main purpose of the Redlock algorithm is to ensure that:
Mutual exclusion is guaranteed Deadlock free operation is possible Fault tolerance is achieved up to a certain degree Algorithm Overview The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><meta itemprop=datePublished content="2024-10-02T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-02T00:00:00+00:00"><meta itemprop=wordCount content="458"><meta itemprop=keywords content="Redis"><meta property="og:url" content="https://bleedkagax.github.io/post/4_redlock_algorithm/"><meta property="og:site_name" content="Kaga Blog"><meta property="og:title" content="Redlock Algorithm"><meta property="og:description" content="Redlock Algorithm: Distributed Lock Management Introduction The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose The main purpose of the Redlock algorithm is to ensure that:
Mutual exclusion is guaranteed Deadlock free operation is possible Fault tolerance is achieved up to a certain degree Algorithm Overview The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-02T00:00:00+00:00"><meta property="article:tag" content="Redis"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redlock Algorithm"><meta name=twitter:description content="Redlock Algorithm: Distributed Lock Management Introduction The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.
Purpose The main purpose of the Redlock algorithm is to ensure that:
Mutual exclusion is guaranteed Deadlock free operation is possible Fault tolerance is achieved up to a certain degree Algorithm Overview The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition."><link rel=canonical href=https://bleedkagax.github.io/post/4_redlock_algorithm/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://bleedkagax.github.io/>Kaga Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Redlock Algorithm</h1><div class="text-xs antialiased opacity-60"><time>Oct 2, 2024</time></div></header><section><h1 id=redlock-algorithm-distributed-lock-management>Redlock Algorithm: Distributed Lock Management</h1><h2 id=introduction>Introduction</h2><p>The Redlock algorithm is a distributed lock algorithm designed to provide a reliable locking mechanism in distributed systems. It was proposed by the Redis community as a way to implement distributed locks using multiple independent Redis instances.</p><h2 id=purpose>Purpose</h2><p>The main purpose of the Redlock algorithm is to ensure that:</p><ol><li>Mutual exclusion is guaranteed</li><li>Deadlock free operation is possible</li><li>Fault tolerance is achieved up to a certain degree</li></ol><h2 id=algorithm-overview>Algorithm Overview</h2><p>The Redlock algorithm uses multiple Redis instances (typically 5) to achieve consensus on lock acquisition and release. The basic idea is to acquire the lock in the majority of the instances to consider it as a successful lock acquisition.</p><h2 id=detailed-steps>Detailed Steps</h2><h3 id=lock-acquisition>Lock Acquisition</h3><ol><li>Get the current time in milliseconds.</li><li>Try to acquire the lock in all N Redis instances sequentially:<ul><li>Use a timeout for each instance that is small compared to the total lock auto-release time.</li><li>If the instance is unavailable, immediately try the next instance.</li></ul></li><li>Calculate the time elapsed to acquire the locks.</li><li>The lock is considered acquired if:<ul><li>The lock was acquired in the majority of instances (at least N/2 + 1)</li><li>The total time elapsed is less than the lock validity time</li></ul></li><li>If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed.</li><li>If the lock was not acquired in the majority of instances, try to unlock all instances.</li></ol><h3 id=lock-release>Lock Release</h3><p>To release the lock, the client sends an unlock command to all instances, regardless of whether it was able to lock all of them during the acquisition phase or not.</p><h2 id=key-considerations>Key Considerations</h2><ol><li><strong>Clock Drift</strong>: The algorithm assumes that the clock drift between nodes is small.</li><li><strong>Timing</strong>: The validity time of the lock should be much larger than the network latency and the clock drift between nodes.</li><li><strong>Fault Tolerance</strong>: The system can tolerate at most N/2 - 1 failed nodes.</li></ol><h2 id=advantages>Advantages</h2><ol><li>High reliability due to multiple Redis instances</li><li>Resistant to split-brain scenarios</li><li>Does not require strong consistency between Redis nodes</li></ol><h2 id=disadvantages>Disadvantages</h2><ol><li>Complexity in implementation and management</li><li>Increased latency due to communication with multiple Redis instances</li><li>Potential for reduced availability if multiple Redis instances fail</li></ol><h2 id=example-implementation-pseudocode>Example Implementation (Pseudocode)</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>acquire_lock</span>(resource, lock_timeout):
</span></span><span style=display:flex><span>    start_time <span style=color:#f92672>=</span> current_time_millis()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> redis_instance <span style=color:#f92672>in</span> redis_instances:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            success <span style=color:#f92672>=</span> redis_instance<span style=color:#f92672>.</span>set(resource, unique_value, nx<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, px<span style=color:#f92672>=</span>lock_timeout)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> success:
</span></span><span style=display:flex><span>                acquired_instances<span style=color:#f92672>.</span>append(redis_instance)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ConnectionError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    elapsed_time <span style=color:#f92672>=</span> current_time_millis() <span style=color:#f92672>-</span> start_time
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(acquired_instances) <span style=color:#f92672>&gt;=</span> (N<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>and</span> elapsed_time <span style=color:#f92672>&lt;</span> lock_timeout:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>, lock_timeout <span style=color:#f92672>-</span> elapsed_time
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        release_lock(resource, acquired_instances)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>release_lock</span>(resource, acquired_instances):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> redis_instance <span style=color:#f92672>in</span> acquired_instances:
</span></span><span style=display:flex><span>        redis_instance<span style=color:#f92672>.</span>delete(resource)
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>The Redlock algorithm provides a robust solution for distributed lock management, particularly suitable for scenarios where high reliability and fault tolerance are required. However, its complexity and potential performance impact should be carefully considered before implementation.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://bleedkagax.github.io/tags/redis>Redis</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://bleedkagax.github.io/post/8_go_memory_allocation/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Go Memory Allocation</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://bleedkagax.github.io/post/7_go_gmp_model/><span>Go's GMP Model</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid [&_svg]:block [&_svg]:m-auto">${e.innerHTML}</div>`})</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://bleedkagax.github.io/>Kaga Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>