<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mysql Interview | Kaga Blog</title>
<meta name=keywords content="Mysql"><meta name=description content="What are the main MySQL storage engines and their differences?
MySQL supports multiple storage engines, each with distinct characteristics:


InnoDB:

Default engine since MySQL 5.5
Supports ACID transactions
Provides row-level locking
Supports foreign keys and relationship constraints
Uses clustered indexes



MyISAM:

Older engine, used as default before MySQL 5.5
Non-transactional
Table-level locking
Faster for read-heavy operations
Supports full-text indexing



Memory (HEAP):"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_mysql_interview/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_mysql_interview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Mysql Interview"><meta property="og:description" content="What are the main MySQL storage engines and their differences?
MySQL supports multiple storage engines, each with distinct characteristics:


InnoDB:

Default engine since MySQL 5.5
Supports ACID transactions
Provides row-level locking
Supports foreign keys and relationship constraints
Uses clustered indexes



MyISAM:

Older engine, used as default before MySQL 5.5
Non-transactional
Table-level locking
Faster for read-heavy operations
Supports full-text indexing



Memory (HEAP):"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_mysql_interview/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-07T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql Interview"><meta name=twitter:description content="What are the main MySQL storage engines and their differences?
MySQL supports multiple storage engines, each with distinct characteristics:


InnoDB:

Default engine since MySQL 5.5
Supports ACID transactions
Provides row-level locking
Supports foreign keys and relationship constraints
Uses clustered indexes



MyISAM:

Older engine, used as default before MySQL 5.5
Non-transactional
Table-level locking
Faster for read-heavy operations
Supports full-text indexing



Memory (HEAP):"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Mysql Interview","item":"https://bleedkagax.github.io/post/0_mysql_interview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mysql Interview","name":"Mysql Interview","description":"What are the main MySQL storage engines and their differences? MySQL supports multiple storage engines, each with distinct characteristics:\nInnoDB:\nDefault engine since MySQL 5.5 Supports ACID transactions Provides row-level locking Supports foreign keys and relationship constraints Uses clustered indexes MyISAM:\nOlder engine, used as default before MySQL 5.5 Non-transactional Table-level locking Faster for read-heavy operations Supports full-text indexing Memory (HEAP):\n","keywords":["Mysql"],"articleBody":"What are the main MySQL storage engines and their differences? MySQL supports multiple storage engines, each with distinct characteristics:\nInnoDB:\nDefault engine since MySQL 5.5 Supports ACID transactions Provides row-level locking Supports foreign keys and relationship constraints Uses clustered indexes MyISAM:\nOlder engine, used as default before MySQL 5.5 Non-transactional Table-level locking Faster for read-heavy operations Supports full-text indexing Memory (HEAP):\nStores data in RAM for fast access Non-persistent (data lost on restart) Useful for temporary tables and caches Archive:\nDesigned for storing large amounts of unindexed data Compressed storage Ideal for logging and data archiving CSV:\nStores data in CSV files Useful for data interchange with other applications InnoDB’s Key Components and Principles B+ Tree Structure\nUsed for all indexes Efficiently handles both range and point queries Buffer Pool\nIn-memory cache for data and indexes Reduces disk I/O for better performance Change Buffer\nCaches changes to secondary indexes Improves write performance Redo Log\nRecords all changes to ensure durability Crucial for crash recovery Undo Log\nSupports transaction rollback and consistent reads Enables multi-version concurrency control (MVCC) ACID Compliance\nEnsures data integrity and reliability Row-Level Locking\nAllows high concurrency for multi-user environments Crash Recovery\nAutomatic recovery after system crashes Foreign Key Support\nMaintains referential integrity between tables Transactions\nSupports both auto-commit and explicit transactions What are the main types of MySQL indexes, and how does the B+ tree work? B+ tree indexes:\nDefault index type Suitable for comparisons using \u003c, \u003e, =, BETWEEN, and LIKE Hash indexes:\nFaster for exact lookups Not suitable for range queries Used internally by Memory tables Full-text indexes:\nOptimized for full-text searches Available in MyISAM and InnoDB (since MySQL 5.6) Spatial indexes:\nUsed for indexing spatial data types B+ tree structure and characteristics:\nA self-balancing tree structure All leaf nodes are at the same level Internal nodes store keys and pointers to child nodes Leaf nodes store keys and data (or pointers to data) Leaf nodes are linked, allowing efficient range queries B+ tree advantages:\nMaintains sorted data for efficient range queries Allows for fast insertions, deletions, and updates Provides logarithmic time complexity for search operations Reduces disk I/O by storing multiple keys in each node B+ tree in MySQL:\nInnoDB uses B+ trees for both clustered and secondary indexes Clustered index stores the actual data in leaf nodes Secondary indexes store the primary key in leaf nodes When updating large data sets in MySQL, which strategies can be used? Batch the updates to minimize long transactions. Use transactions for consistency when necessary. Disable and re-enable indexes to speed up the process (Only applicable for non-unique indexes and for tables using the MyISAM storage engine. For InnoDB, this approach won’t work as InnoDB maintains indexes automatically.). Use tools like pt-online-schema-change for large schema changes. Optimize buffer pool size to handle large datasets more efficiently. Monitor the update progress to detect and address performance bottlenecks.\nDatabase Index Concepts 1. Index An index is a data structure that improves the speed of data retrieval operations on a database table.\n2. Key A key is a column or set of columns in a table that is used to identify a row uniquely.\n3. Primary Key A primary key is a special type of key that uniquely identifies each record in a table. It must contain unique values and cannot contain null values. A table can have only one primary key.\n4. Clustered Index A clustered index determines the physical order of data in a table. In MySQL’s InnoDB, the primary key is always the clustered index.\n5. Secondary Index A secondary index is any index that is not the clustered index. In InnoDB, secondary index leaf nodes contain the indexed columns and a pointer to the primary key value.\nClustered Index vs. Secondary Index Clustered Index:\nRoot Node │ ├── Internal Nodes (with key ranges) │ └── Leaf Nodes (contain actual data rows) Secondary Index:\nRoot Node │ ├── Internal Nodes (with key ranges) │ └── Leaf Nodes (contain indexed column + primary key) Explain the differences between MyISAM and InnoDB storage engines. MyISAM:\nFaster for read-heavy operations Table-level locking Does not support transactions Does not support foreign keys InnoDB:\nSupports ACID transactions Row-level locking Supports foreign keys Better crash recovery Explain the concept of normalization in databases. Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity.\nFirst Normal Form (1NF): Eliminate repeating groups Second Normal Form (2NF): Eliminate partial dependencies Third Normal Form (3NF): Eliminate transitive dependencies Boyce-Codd Normal Form (BCNF): A stricter version of 3NF What is a transaction in MySQL? A transaction is a sequence of one or more SQL statements that are executed as a single unit of work. The main properties of transactions are often referred to as ACID:\nAtomicity: All operations in a transaction succeed or every operation is rolled back Consistency: The database is in a consistent state before and after the transaction Isolation: Intermediate transaction states are invisible to other transactions Durability: Completed transactions are permanently saved in the database Explain the different types of joins in MySQL. INNER JOIN: Returns rows when there is a match in both tables LEFT JOIN: Returns all rows from the left table, and the matched rows from the right table RIGHT JOIN: Returns all rows from the right table, and the matched rows from the left table FULL JOIN: Returns rows when there is a match in one of the tables CROSS JOIN: Returns the Cartesian product of the two tables What is the difference between CHAR and VARCHAR data types? CHAR: Fixed-length string data type. Always uses the specified length, padding with spaces if necessary VARCHAR: Variable-length string data type. Uses only as much space as needed, plus one or two bytes to store length Explain the concept of indexing in MySQL. Indexing is a data structure technique used to quickly locate and access data in a database. It improves the speed of data retrieval operations but can slow down data insertion and update operations.\nWhat is a stored procedure in MySQL? A stored procedure is a prepared SQL code that you can save and reuse. Benefits include:\nImproved performance (compiled once, stored in executable form) Reduction in network traffic Centralized business logic in the database server Explain the concept of database sharding. Sharding is a database architecture pattern related to horizontal partitioning — the practice of separating one table’s rows into multiple different tables, known as partitions. Each partition has the same schema and columns, but entirely different rows.\nWhen using hash index in mysql, it supports ange quesry? When using a hash index in MySQL, it only supports equality comparisons using the = or \u003c=\u003e operators. It does not support range queries (e.g., using \u003c, \u003e, \u003c=, \u003e=, BETWEEN, LIKE). This is a key limitation of hash indexes compared to B+ tree indexes, which support both equality and range comparisons.\nExplain \u003c=\u003e operator In MySQL, the \u003c=\u003e operator is the NULL-safe equality comparison operator. It compares two values for equality, but treats NULL values as equal to each other. This is different from the = operator, which considers NULL unequal to any value, including another NULL.\nFor example:\nNULL = NULL evaluates to false. NULL \u003c=\u003e NULL evaluates to true. Query Processing MySQL processes queries through several stages:\nParsing: Checks SQL syntax and creates a parse tree. Preprocessing: Checks table and column existence, resolves aliases. Query optimization: Determines the most efficient execution plan. Execution: Runs the query and returns results. Key components:\nQuery Cache (deprecated in MySQL 8.0) Query Optimizer Storage Engine API Transactions and Locking MySQL supports transactions and various locking mechanisms:\nACID properties: Ensures data integrity and consistency. Isolation levels: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE. Locking mechanisms: Table-level locks Row-level locks (InnoDB) Intention locks Gap locks and next-key locks (InnoDB) Query Optimization Use appropriate indexes:\nCreate indexes on frequently queried columns. Use composite indexes for multi-column conditions. Optimize JOIN operations:\nUse proper join types (INNER, LEFT, RIGHT). Order tables in joins from smallest to largest. Utilize EXPLAIN to analyze query execution plans:\nIdentify full table scans and inefficient index usage. Look for opportunities to add or modify indexes. Avoid using wildcards at the beginning of LIKE patterns:\nUse column LIKE 'abc%' instead of column LIKE '%abc'. Use LIMIT for pagination:\nImplement efficient pagination with LIMIT and OFFSET. Optimize subqueries:\nRewrite subqueries as JOINs when possible. Use correlated subqueries judiciously. Utilize query hints:\nUse INDEX hints to force specific index usage. Apply JOIN_ORDER hints for complex queries. Implement proper WHERE clause:\nPlace most restrictive conditions first. Avoid using functions on indexed columns in WHERE clauses. Use appropriate data types:\nChoose the smallest data type that can hold the required data. Use ENUM or SET for columns with a fixed set of values. Optimize GROUP BY and ORDER BY:\nAdd indexes to support these operations. Use covering indexes when possible. Schema Optimization Normalize tables appropriately:\nAim for 3NF (Third Normal Form) in most cases. Consider denormalization for read-heavy workloads. Use appropriate data types:\nUse INT for primary keys instead of larger types like BIGINT when possible. Use VARCHAR instead of CHAR for variable-length strings. Implement proper constraints:\nUse foreign key constraints to maintain data integrity. Implement CHECK constraints for data validation. Partition large tables:\nUse range, list, or hash partitioning for better query performance. Implement partition pruning for efficient data access. Use efficient storage engines:\nUse InnoDB for transactional tables. Consider MyISAM for read-only or read-heavy tables. Implement proper indexing strategy:\nCreate indexes based on query patterns. Avoid over-indexing, which can slow down writes. Use appropriate character sets and collations:\nUse UTF8MB4 for full Unicode support. Choose appropriate collations for sorting and comparison. Implement vertical partitioning:\nSplit large tables into smaller ones based on column usage patterns. Use computed columns:\nImplement computed columns for frequently calculated values. Optimize BLOB and TEXT columns:\nStore large objects separately when possible. Use external file storage for very large objects. Server Configuration Optimization Optimize MySQL server configuration for better performance:\nAdjust buffer pool size:\nSet innodb_buffer_pool_size to 70-80% of available RAM for InnoDB. Optimize thread handling:\nSet thread_cache_size appropriately to reduce thread creation overhead. Configure query cache (for versions prior to 8.0):\nSet query_cache_type and query_cache_size based on workload. Adjust max_connections:\nSet based on expected concurrent connections. Optimize file system usage:\nUse innodb_file_per_table for easier management of table spaces. Configure log files:\nSet appropriate sizes for binary log and InnoDB log files. Optimize I/O subsystem:\nUse innodb_flush_method=O_DIRECT on Linux for improved I/O performance. Tune sort buffer:\nAdjust sort_buffer_size based on complex query requirements. Configure temporary tables:\nSet tmp_table_size and max_heap_table_size for in-memory temporary tables. Optimize network settings:\nAdjust max_allowed_packet for large queries or BLOB data. Hardware Optimization Optimize hardware for MySQL performance:\nUse SSDs for database storage:\nSignificantly improves random I/O performance. Implement RAID for improved I/O:\nUse RAID 10 for balanced read/write performance. Allocate sufficient RAM:\nEnsure enough memory for MySQL buffer pool and operating system. Use multiple CPU cores:\nMySQL can utilize multiple cores for query execution. Optimize network infrastructure:\nUse high-speed network interfaces and switches. Implement proper storage layout:\nSeparate data files, log files, and temporary files on different disks. Consider using PCIe NVMe drives:\nProvides extremely high I/O performance for demanding workloads. Use battery-backed write cache:\nImproves write performance while maintaining data integrity. Implement proper cooling and power supply:\nEnsure stable environment for consistent performance. Consider using dedicated database servers:\nSeparates database workload from application servers. Replication Asynchronous replication:\nTraditional master-slave setup. Slaves can lag behind the master. Semi-synchronous replication:\nMaster waits for at least one slave to acknowledge receipt of events. Group Replication:\nMulti-master update everywhere replication with built-in conflict detection. Binary log file position-based replication:\nTraditional method using binary log positions. GTID-based replication:\nUses Global Transaction Identifiers for easier failover and slave provisioning. Key features:\nRow-based, statement-based, or mixed replication formats. Parallel replication for improved performance. Delayed replication for disaster recovery. Partitioning MySQL supports table partitioning for improved query performance and data management:\nRange partitioning:\nPartitions based on column value ranges. List partitioning:\nPartitions based on lists of column values. Hash partitioning:\nDistributes data evenly across partitions using a hash function. Key partitioning:\nSimilar to hash partitioning but uses MySQL’s internal hashing function. Composite partitioning:\nCombines multiple partitioning methods. Benefits:\nImproved query performance through partition pruning. Easier data archiving and deletion. Better distribution of data across multiple disks. COUNT(*)``COUNT(1)``COUNT(primary_key_field)``COUNT(field) Function Count Content Affected by NULLs Performance COUNT(*) All rows Not affected Typically the fastest, highly optimized by DBMS COUNT(1) All rows (equivalent to COUNT(*)) Not affected Similar performance to COUNT(*) COUNT(primary_key_field) Number of non-NULL values in the primary key field Typically not affected (primary keys are usually NOT NULL) Similar performance to COUNT(*) COUNT(field) Number of non-NULL values in the specified field Affected Generally slower than COUNT(*) and COUNT(1), depends on indexing ","wordCount":"2134","inLanguage":"en","datePublished":"2024-09-07T00:00:00Z","dateModified":"2024-09-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_mysql_interview/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Mysql Interview</h1><div class=post-meta><span title='2024-09-07 00:00:00 +0000 UTC'>September 7, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-are-the-main-mysql-storage-engines-and-their-differences aria-label="What are the main MySQL storage engines and their differences?">What are the main MySQL storage engines and their differences?</a></li><li><a href=#innodbs-key-components-and-principles aria-label="InnoDB&rsquo;s Key Components and Principles">InnoDB&rsquo;s Key Components and Principles</a></li><li><a href=#what-are-the-main-types-of-mysql-indexes-and-how-does-the-b-tree-work aria-label="What are the main types of MySQL indexes, and how does the B+ tree work?">What are the main types of MySQL indexes, and how does the B+ tree work?</a></li><li><a href=#when-updating-large-data-sets-in-mysql-which-strategies-can-be-used aria-label="When updating large data sets in MySQL, which strategies can be used?">When updating large data sets in MySQL, which strategies can be used?</a></li><li><a href=#database-index-concepts aria-label="Database Index Concepts">Database Index Concepts</a><ul><li><a href=#1-index aria-label="1. Index">1. Index</a></li><li><a href=#2-key aria-label="2. Key">2. Key</a></li><li><a href=#3-primary-key aria-label="3. Primary Key">3. Primary Key</a></li><li><a href=#4-clustered-index aria-label="4. Clustered Index">4. Clustered Index</a></li><li><a href=#5-secondary-index aria-label="5. Secondary Index">5. Secondary Index</a></li></ul></li><li><a href=#clustered-index-vs-secondary-index aria-label="Clustered Index vs. Secondary Index">Clustered Index vs. Secondary Index</a></li><li><a href=#explain-the-differences-between-myisam-and-innodb-storage-engines aria-label="Explain the differences between MyISAM and InnoDB storage engines.">Explain the differences between MyISAM and InnoDB storage engines.</a></li><li><a href=#explain-the-concept-of-normalization-in-databases aria-label="Explain the concept of normalization in databases.">Explain the concept of normalization in databases.</a></li><li><a href=#what-is-a-transaction-in-mysql aria-label="What is a transaction in MySQL?">What is a transaction in MySQL?</a></li><li><a href=#explain-the-different-types-of-joins-in-mysql aria-label="Explain the different types of joins in MySQL.">Explain the different types of joins in MySQL.</a></li><li><a href=#what-is-the-difference-between-char-and-varchar-data-types aria-label="What is the difference between CHAR and VARCHAR data types?">What is the difference between CHAR and VARCHAR data types?</a></li><li><a href=#explain-the-concept-of-indexing-in-mysql aria-label="Explain the concept of indexing in MySQL.">Explain the concept of indexing in MySQL.</a></li><li><a href=#what-is-a-stored-procedure-in-mysql aria-label="What is a stored procedure in MySQL?">What is a stored procedure in MySQL?</a></li><li><a href=#explain-the-concept-of-database-sharding aria-label="Explain the concept of database sharding.">Explain the concept of database sharding.</a></li><li><a href=#when-using-hash-index-in-mysql-it-supports-ange-quesry aria-label="When using hash index in mysql, it supports ange quesry?">When using hash index in mysql, it supports ange quesry?</a></li><li><a href=#explain--operator aria-label="Explain <=> operator">Explain &lt;=> operator</a></li><li><a href=#query-processing aria-label="Query Processing">Query Processing</a></li><li><a href=#transactions-and-locking aria-label="Transactions and Locking">Transactions and Locking</a></li><li><a href=#query-optimization aria-label="Query Optimization">Query Optimization</a></li><li><a href=#schema-optimization aria-label="Schema Optimization">Schema Optimization</a></li><li><a href=#server-configuration-optimization aria-label="Server Configuration Optimization">Server Configuration Optimization</a></li><li><a href=#hardware-optimization aria-label="Hardware Optimization">Hardware Optimization</a></li><li><a href=#replication aria-label=Replication>Replication</a></li><li><a href=#partitioning aria-label=Partitioning>Partitioning</a></li><li><a href=#countcount1countprimary_key_fieldcountfield aria-label="COUNT(*)``COUNT(1)``COUNT(primary_key_field)``COUNT(field)">COUNT(*)``COUNT(1)``COUNT(primary_key_field)``COUNT(field)</a></li></ul></div></details></div><div class=post-content><h2 id=what-are-the-main-mysql-storage-engines-and-their-differences>What are the main MySQL storage engines and their differences?<a hidden class=anchor aria-hidden=true href=#what-are-the-main-mysql-storage-engines-and-their-differences>#</a></h2><p>MySQL supports multiple storage engines, each with distinct characteristics:</p><ol><li><p>InnoDB:</p><ul><li>Default engine since MySQL 5.5</li><li>Supports ACID transactions</li><li>Provides row-level locking</li><li>Supports foreign keys and relationship constraints</li><li>Uses clustered indexes</li></ul></li><li><p>MyISAM:</p><ul><li>Older engine, used as default before MySQL 5.5</li><li>Non-transactional</li><li>Table-level locking</li><li>Faster for read-heavy operations</li><li>Supports full-text indexing</li></ul></li><li><p>Memory (HEAP):</p><ul><li>Stores data in RAM for fast access</li><li>Non-persistent (data lost on restart)</li><li>Useful for temporary tables and caches</li></ul></li><li><p>Archive:</p><ul><li>Designed for storing large amounts of unindexed data</li><li>Compressed storage</li><li>Ideal for logging and data archiving</li></ul></li><li><p>CSV:</p><ul><li>Stores data in CSV files</li><li>Useful for data interchange with other applications</li></ul></li></ol><h2 id=innodbs-key-components-and-principles>InnoDB&rsquo;s Key Components and Principles<a hidden class=anchor aria-hidden=true href=#innodbs-key-components-and-principles>#</a></h2><p><img loading=lazy src=/img/0_mysql_interview.png alt></p><ol><li><p>B+ Tree Structure</p><ul><li>Used for all indexes</li><li>Efficiently handles both range and point queries</li></ul></li><li><p>Buffer Pool</p><ul><li>In-memory cache for data and indexes</li><li>Reduces disk I/O for better performance</li></ul></li><li><p>Change Buffer</p><ul><li>Caches changes to secondary indexes</li><li>Improves write performance</li></ul></li><li><p>Redo Log</p><ul><li>Records all changes to ensure durability</li><li>Crucial for crash recovery</li></ul></li><li><p>Undo Log</p><ul><li>Supports transaction rollback and consistent reads</li><li>Enables multi-version concurrency control (MVCC)</li></ul></li><li><p>ACID Compliance</p><ul><li>Ensures data integrity and reliability</li></ul></li><li><p>Row-Level Locking</p><ul><li>Allows high concurrency for multi-user environments</li></ul></li><li><p>Crash Recovery</p><ul><li>Automatic recovery after system crashes</li></ul></li><li><p>Foreign Key Support</p><ul><li>Maintains referential integrity between tables</li></ul></li><li><p>Transactions</p></li></ol><ul><li>Supports both auto-commit and explicit transactions</li></ul><h2 id=what-are-the-main-types-of-mysql-indexes-and-how-does-the-b-tree-work>What are the main types of MySQL indexes, and how does the B+ tree work?<a hidden class=anchor aria-hidden=true href=#what-are-the-main-types-of-mysql-indexes-and-how-does-the-b-tree-work>#</a></h2><ol><li><p>B+ tree indexes:</p><ul><li>Default index type</li><li>Suitable for comparisons using &lt;, >, =, BETWEEN, and LIKE</li></ul></li><li><p>Hash indexes:</p><ul><li>Faster for exact lookups</li><li>Not suitable for range queries</li><li>Used internally by Memory tables</li></ul></li><li><p>Full-text indexes:</p><ul><li>Optimized for full-text searches</li><li>Available in MyISAM and InnoDB (since MySQL 5.6)</li></ul></li><li><p>Spatial indexes:</p><ul><li>Used for indexing spatial data types</li></ul></li></ol><p>B+ tree structure and characteristics:</p><ul><li>A self-balancing tree structure</li><li>All leaf nodes are at the same level</li><li>Internal nodes store keys and pointers to child nodes</li><li>Leaf nodes store keys and data (or pointers to data)</li><li>Leaf nodes are linked, allowing efficient range queries</li></ul><p>B+ tree advantages:</p><ul><li>Maintains sorted data for efficient range queries</li><li>Allows for fast insertions, deletions, and updates</li><li>Provides logarithmic time complexity for search operations</li><li>Reduces disk I/O by storing multiple keys in each node</li></ul><p>B+ tree in MySQL:</p><ul><li>InnoDB uses B+ trees for both clustered and secondary indexes</li><li>Clustered index stores the actual data in leaf nodes</li><li>Secondary indexes store the primary key in leaf nodes</li></ul><h2 id=when-updating-large-data-sets-in-mysql-which-strategies-can-be-used>When updating large data sets in MySQL, which strategies can be used?<a hidden class=anchor aria-hidden=true href=#when-updating-large-data-sets-in-mysql-which-strategies-can-be-used>#</a></h2><p>Batch the updates to minimize long transactions.
Use transactions for consistency when necessary.
Disable and re-enable indexes to speed up the process (Only applicable for non-unique indexes and for tables using the MyISAM storage engine. For InnoDB, this approach won’t work as InnoDB maintains indexes automatically.).
Use tools like pt-online-schema-change for large schema changes.
Optimize buffer pool size to handle large datasets more efficiently.
Monitor the update progress to detect and address performance bottlenecks.</p><h2 id=database-index-concepts>Database Index Concepts<a hidden class=anchor aria-hidden=true href=#database-index-concepts>#</a></h2><h3 id=1-index>1. Index<a hidden class=anchor aria-hidden=true href=#1-index>#</a></h3><p>An index is a data structure that improves the speed of data retrieval operations on a database table.</p><h3 id=2-key>2. Key<a hidden class=anchor aria-hidden=true href=#2-key>#</a></h3><p>A key is a column or set of columns in a table that is used to identify a row uniquely.</p><h3 id=3-primary-key>3. Primary Key<a hidden class=anchor aria-hidden=true href=#3-primary-key>#</a></h3><p>A primary key is a special type of key that uniquely identifies each record in a table. It must contain unique values and cannot contain null values. A table can have only one primary key.</p><h3 id=4-clustered-index>4. Clustered Index<a hidden class=anchor aria-hidden=true href=#4-clustered-index>#</a></h3><p>A clustered index determines the physical order of data in a table. In MySQL&rsquo;s InnoDB, the primary key is always the clustered index.</p><h3 id=5-secondary-index>5. Secondary Index<a hidden class=anchor aria-hidden=true href=#5-secondary-index>#</a></h3><p>A secondary index is any index that is not the clustered index. In InnoDB, secondary index leaf nodes contain the indexed columns and a pointer to the primary key value.</p><h2 id=clustered-index-vs-secondary-index>Clustered Index vs. Secondary Index<a hidden class=anchor aria-hidden=true href=#clustered-index-vs-secondary-index>#</a></h2><p><strong>Clustered Index:</strong></p><pre tabindex=0><code>Root Node
│
├── Internal Nodes (with key ranges)
│
└── Leaf Nodes (contain actual data rows)
</code></pre><p><strong>Secondary Index:</strong></p><pre tabindex=0><code>Root Node
│
├── Internal Nodes (with key ranges)
│
└── Leaf Nodes (contain indexed column + primary key)
</code></pre><h2 id=explain-the-differences-between-myisam-and-innodb-storage-engines>Explain the differences between MyISAM and InnoDB storage engines.<a hidden class=anchor aria-hidden=true href=#explain-the-differences-between-myisam-and-innodb-storage-engines>#</a></h2><ul><li><p>MyISAM:</p><ul><li>Faster for read-heavy operations</li><li>Table-level locking</li><li>Does not support transactions</li><li>Does not support foreign keys</li></ul></li><li><p>InnoDB:</p><ul><li>Supports ACID transactions</li><li>Row-level locking</li><li>Supports foreign keys</li><li>Better crash recovery</li></ul></li></ul><h2 id=explain-the-concept-of-normalization-in-databases>Explain the concept of normalization in databases.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-normalization-in-databases>#</a></h2><p>Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity.</p><ol><li>First Normal Form (1NF): Eliminate repeating groups</li><li>Second Normal Form (2NF): Eliminate partial dependencies</li><li>Third Normal Form (3NF): Eliminate transitive dependencies</li><li>Boyce-Codd Normal Form (BCNF): A stricter version of 3NF</li></ol><h2 id=what-is-a-transaction-in-mysql>What is a transaction in MySQL?<a hidden class=anchor aria-hidden=true href=#what-is-a-transaction-in-mysql>#</a></h2><p>A transaction is a sequence of one or more SQL statements that are executed as a single unit of work. The main properties of transactions are often referred to as ACID:</p><ul><li>Atomicity: All operations in a transaction succeed or every operation is rolled back</li><li>Consistency: The database is in a consistent state before and after the transaction</li><li>Isolation: Intermediate transaction states are invisible to other transactions</li><li>Durability: Completed transactions are permanently saved in the database</li></ul><h2 id=explain-the-different-types-of-joins-in-mysql>Explain the different types of joins in MySQL.<a hidden class=anchor aria-hidden=true href=#explain-the-different-types-of-joins-in-mysql>#</a></h2><ul><li>INNER JOIN: Returns rows when there is a match in both tables</li><li>LEFT JOIN: Returns all rows from the left table, and the matched rows from the right table</li><li>RIGHT JOIN: Returns all rows from the right table, and the matched rows from the left table</li><li>FULL JOIN: Returns rows when there is a match in one of the tables</li><li>CROSS JOIN: Returns the Cartesian product of the two tables</li></ul><h2 id=what-is-the-difference-between-char-and-varchar-data-types>What is the difference between CHAR and VARCHAR data types?<a hidden class=anchor aria-hidden=true href=#what-is-the-difference-between-char-and-varchar-data-types>#</a></h2><ul><li>CHAR: Fixed-length string data type. Always uses the specified length, padding with spaces if necessary</li><li>VARCHAR: Variable-length string data type. Uses only as much space as needed, plus one or two bytes to store length</li></ul><h2 id=explain-the-concept-of-indexing-in-mysql>Explain the concept of indexing in MySQL.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-indexing-in-mysql>#</a></h2><p>Indexing is a data structure technique used to quickly locate and access data in a database. It improves the speed of data retrieval operations but can slow down data insertion and update operations.</p><h2 id=what-is-a-stored-procedure-in-mysql>What is a stored procedure in MySQL?<a hidden class=anchor aria-hidden=true href=#what-is-a-stored-procedure-in-mysql>#</a></h2><p>A stored procedure is a prepared SQL code that you can save and reuse. Benefits include:</p><ul><li>Improved performance (compiled once, stored in executable form)</li><li>Reduction in network traffic</li><li>Centralized business logic in the database server</li></ul><h2 id=explain-the-concept-of-database-sharding>Explain the concept of database sharding.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-database-sharding>#</a></h2><p>Sharding is a database architecture pattern related to horizontal partitioning — the practice of separating one table&rsquo;s rows into multiple different tables, known as partitions. Each partition has the same schema and columns, but entirely different rows.</p><h2 id=when-using-hash-index-in-mysql-it-supports-ange-quesry>When using hash index in mysql, it supports ange quesry?<a hidden class=anchor aria-hidden=true href=#when-using-hash-index-in-mysql-it-supports-ange-quesry>#</a></h2><p>When using a hash index in MySQL, it only supports equality comparisons using the = or &lt;=> operators. It does not support range queries (e.g., using &lt;, >, &lt;=, >=, BETWEEN, LIKE). This is a key limitation of hash indexes compared to B+ tree indexes, which support both equality and range comparisons.</p><h2 id=explain--operator>Explain &lt;=> operator<a hidden class=anchor aria-hidden=true href=#explain--operator>#</a></h2><p>In MySQL, the <code>&lt;=></code> operator is the NULL-safe equality comparison operator.
It compares two values for equality, but treats NULL values as equal to each other. This is different from the = operator, which considers NULL unequal to any value, including another NULL.</p><p>For example:</p><ul><li><code>NULL = NULL</code> evaluates to <code>false</code>.</li><li><code>NULL &lt;=> NULL</code> evaluates to <code>true</code>.</li></ul><h2 id=query-processing>Query Processing<a hidden class=anchor aria-hidden=true href=#query-processing>#</a></h2><p>MySQL processes queries through several stages:</p><ol><li>Parsing: Checks SQL syntax and creates a parse tree.</li><li>Preprocessing: Checks table and column existence, resolves aliases.</li><li>Query optimization: Determines the most efficient execution plan.</li><li>Execution: Runs the query and returns results.</li></ol><p>Key components:</p><ul><li>Query Cache (deprecated in MySQL 8.0)</li><li>Query Optimizer</li><li>Storage Engine API</li></ul><h2 id=transactions-and-locking>Transactions and Locking<a hidden class=anchor aria-hidden=true href=#transactions-and-locking>#</a></h2><p>MySQL supports transactions and various locking mechanisms:</p><ol><li>ACID properties: Ensures data integrity and consistency.</li><li>Isolation levels: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE.</li><li>Locking mechanisms:<ul><li>Table-level locks</li><li>Row-level locks (InnoDB)</li><li>Intention locks</li><li>Gap locks and next-key locks (InnoDB)</li></ul></li></ol><h2 id=query-optimization>Query Optimization<a hidden class=anchor aria-hidden=true href=#query-optimization>#</a></h2><ol><li><p>Use appropriate indexes:</p><ul><li>Create indexes on frequently queried columns.</li><li>Use composite indexes for multi-column conditions.</li></ul></li><li><p>Optimize JOIN operations:</p><ul><li>Use proper join types (INNER, LEFT, RIGHT).</li><li>Order tables in joins from smallest to largest.</li></ul></li><li><p>Utilize EXPLAIN to analyze query execution plans:</p><ul><li>Identify full table scans and inefficient index usage.</li><li>Look for opportunities to add or modify indexes.</li></ul></li><li><p>Avoid using wildcards at the beginning of LIKE patterns:</p><ul><li>Use <code>column LIKE 'abc%'</code> instead of <code>column LIKE '%abc'</code>.</li></ul></li><li><p>Use LIMIT for pagination:</p><ul><li>Implement efficient pagination with LIMIT and OFFSET.</li></ul></li><li><p>Optimize subqueries:</p><ul><li>Rewrite subqueries as JOINs when possible.</li><li>Use correlated subqueries judiciously.</li></ul></li><li><p>Utilize query hints:</p><ul><li>Use INDEX hints to force specific index usage.</li><li>Apply JOIN_ORDER hints for complex queries.</li></ul></li><li><p>Implement proper WHERE clause:</p><ul><li>Place most restrictive conditions first.</li><li>Avoid using functions on indexed columns in WHERE clauses.</li></ul></li><li><p>Use appropriate data types:</p><ul><li>Choose the smallest data type that can hold the required data.</li><li>Use ENUM or SET for columns with a fixed set of values.</li></ul></li><li><p>Optimize GROUP BY and ORDER BY:</p></li></ol><ul><li>Add indexes to support these operations.</li><li>Use covering indexes when possible.</li></ul><h2 id=schema-optimization>Schema Optimization<a hidden class=anchor aria-hidden=true href=#schema-optimization>#</a></h2><ol><li><p>Normalize tables appropriately:</p><ul><li>Aim for 3NF (Third Normal Form) in most cases.</li><li>Consider denormalization for read-heavy workloads.</li></ul></li><li><p>Use appropriate data types:</p><ul><li>Use INT for primary keys instead of larger types like BIGINT when possible.</li><li>Use VARCHAR instead of CHAR for variable-length strings.</li></ul></li><li><p>Implement proper constraints:</p><ul><li>Use foreign key constraints to maintain data integrity.</li><li>Implement CHECK constraints for data validation.</li></ul></li><li><p>Partition large tables:</p><ul><li>Use range, list, or hash partitioning for better query performance.</li><li>Implement partition pruning for efficient data access.</li></ul></li><li><p>Use efficient storage engines:</p><ul><li>Use InnoDB for transactional tables.</li><li>Consider MyISAM for read-only or read-heavy tables.</li></ul></li><li><p>Implement proper indexing strategy:</p><ul><li>Create indexes based on query patterns.</li><li>Avoid over-indexing, which can slow down writes.</li></ul></li><li><p>Use appropriate character sets and collations:</p><ul><li>Use UTF8MB4 for full Unicode support.</li><li>Choose appropriate collations for sorting and comparison.</li></ul></li><li><p>Implement vertical partitioning:</p><ul><li>Split large tables into smaller ones based on column usage patterns.</li></ul></li><li><p>Use computed columns:</p><ul><li>Implement computed columns for frequently calculated values.</li></ul></li><li><p>Optimize BLOB and TEXT columns:</p></li></ol><ul><li>Store large objects separately when possible.</li><li>Use external file storage for very large objects.</li></ul><h2 id=server-configuration-optimization>Server Configuration Optimization<a hidden class=anchor aria-hidden=true href=#server-configuration-optimization>#</a></h2><p>Optimize MySQL server configuration for better performance:</p><ol><li><p>Adjust buffer pool size:</p><ul><li>Set innodb_buffer_pool_size to 70-80% of available RAM for InnoDB.</li></ul></li><li><p>Optimize thread handling:</p><ul><li>Set thread_cache_size appropriately to reduce thread creation overhead.</li></ul></li><li><p>Configure query cache (for versions prior to 8.0):</p><ul><li>Set query_cache_type and query_cache_size based on workload.</li></ul></li><li><p>Adjust max_connections:</p><ul><li>Set based on expected concurrent connections.</li></ul></li><li><p>Optimize file system usage:</p><ul><li>Use innodb_file_per_table for easier management of table spaces.</li></ul></li><li><p>Configure log files:</p><ul><li>Set appropriate sizes for binary log and InnoDB log files.</li></ul></li><li><p>Optimize I/O subsystem:</p><ul><li>Use innodb_flush_method=O_DIRECT on Linux for improved I/O performance.</li></ul></li><li><p>Tune sort buffer:</p><ul><li>Adjust sort_buffer_size based on complex query requirements.</li></ul></li><li><p>Configure temporary tables:</p><ul><li>Set tmp_table_size and max_heap_table_size for in-memory temporary tables.</li></ul></li><li><p>Optimize network settings:</p></li></ol><ul><li>Adjust max_allowed_packet for large queries or BLOB data.</li></ul><h2 id=hardware-optimization>Hardware Optimization<a hidden class=anchor aria-hidden=true href=#hardware-optimization>#</a></h2><p>Optimize hardware for MySQL performance:</p><ol><li><p>Use SSDs for database storage:</p><ul><li>Significantly improves random I/O performance.</li></ul></li><li><p>Implement RAID for improved I/O:</p><ul><li>Use RAID 10 for balanced read/write performance.</li></ul></li><li><p>Allocate sufficient RAM:</p><ul><li>Ensure enough memory for MySQL buffer pool and operating system.</li></ul></li><li><p>Use multiple CPU cores:</p><ul><li>MySQL can utilize multiple cores for query execution.</li></ul></li><li><p>Optimize network infrastructure:</p><ul><li>Use high-speed network interfaces and switches.</li></ul></li><li><p>Implement proper storage layout:</p><ul><li>Separate data files, log files, and temporary files on different disks.</li></ul></li><li><p>Consider using PCIe NVMe drives:</p><ul><li>Provides extremely high I/O performance for demanding workloads.</li></ul></li><li><p>Use battery-backed write cache:</p><ul><li>Improves write performance while maintaining data integrity.</li></ul></li><li><p>Implement proper cooling and power supply:</p><ul><li>Ensure stable environment for consistent performance.</li></ul></li><li><p>Consider using dedicated database servers:</p></li></ol><ul><li>Separates database workload from application servers.</li></ul><h2 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h2><ol><li><p>Asynchronous replication:</p><ul><li>Traditional master-slave setup.</li><li>Slaves can lag behind the master.</li></ul></li><li><p>Semi-synchronous replication:</p><ul><li>Master waits for at least one slave to acknowledge receipt of events.</li></ul></li><li><p>Group Replication:</p><ul><li>Multi-master update everywhere replication with built-in conflict detection.</li></ul></li><li><p>Binary log file position-based replication:</p><ul><li>Traditional method using binary log positions.</li></ul></li><li><p>GTID-based replication:</p><ul><li>Uses Global Transaction Identifiers for easier failover and slave provisioning.</li></ul></li></ol><p>Key features:</p><ul><li>Row-based, statement-based, or mixed replication formats.</li><li>Parallel replication for improved performance.</li><li>Delayed replication for disaster recovery.</li></ul><h2 id=partitioning>Partitioning<a hidden class=anchor aria-hidden=true href=#partitioning>#</a></h2><p>MySQL supports table partitioning for improved query performance and data management:</p><ol><li><p>Range partitioning:</p><ul><li>Partitions based on column value ranges.</li></ul></li><li><p>List partitioning:</p><ul><li>Partitions based on lists of column values.</li></ul></li><li><p>Hash partitioning:</p><ul><li>Distributes data evenly across partitions using a hash function.</li></ul></li><li><p>Key partitioning:</p><ul><li>Similar to hash partitioning but uses MySQL&rsquo;s internal hashing function.</li></ul></li><li><p>Composite partitioning:</p><ul><li>Combines multiple partitioning methods.</li></ul></li></ol><p>Benefits:</p><ul><li>Improved query performance through partition pruning.</li><li>Easier data archiving and deletion.</li><li>Better distribution of data across multiple disks.</li></ul><h2 id=countcount1countprimary_key_fieldcountfield><code>COUNT(*)``COUNT(1)``COUNT(primary_key_field)``COUNT(field)</code><a hidden class=anchor aria-hidden=true href=#countcount1countprimary_key_fieldcountfield>#</a></h2><table><thead><tr><th style=text-align:left><strong>Function</strong></th><th style=text-align:left><strong>Count Content</strong></th><th style=text-align:left><strong>Affected by NULLs</strong></th><th style=text-align:left><strong>Performance</strong></th></tr></thead><tbody><tr><td style=text-align:left><code>COUNT(*)</code></td><td style=text-align:left>All rows</td><td style=text-align:left>Not affected</td><td style=text-align:left>Typically the fastest, highly optimized by DBMS</td></tr><tr><td style=text-align:left><code>COUNT(1)</code></td><td style=text-align:left>All rows (equivalent to <code>COUNT(*)</code>)</td><td style=text-align:left>Not affected</td><td style=text-align:left>Similar performance to <code>COUNT(*)</code></td></tr><tr><td style=text-align:left><code>COUNT(primary_key_field)</code></td><td style=text-align:left>Number of non-NULL values in the primary key field</td><td style=text-align:left>Typically not affected (primary keys are usually <code>NOT NULL</code>)</td><td style=text-align:left>Similar performance to <code>COUNT(*)</code></td></tr><tr><td style=text-align:left><code>COUNT(field)</code></td><td style=text-align:left>Number of non-NULL values in the specified field</td><td style=text-align:left>Affected</td><td style=text-align:left>Generally slower than <code>COUNT(*)</code> and <code>COUNT(1)</code>, depends on indexing</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/mysql/>Mysql</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>