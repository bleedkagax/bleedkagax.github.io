<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Mysql Interview - Kaga Blog</title>
<meta name=theme-color><meta name=description content="What are the main MySQL storage engines and their differences?
MySQL supports multiple storage engines, each with distinct characteristics:


InnoDB:

Default engine since MySQL 5.5
Supports ACID transactions
Provides row-level locking
Supports foreign keys and relationship constraints
Uses clustered indexes



MyISAM:

Older engine, used as default before MySQL 5.5
Non-transactional
Table-level locking
Faster for read-heavy operations
Supports full-text indexing



Memory (HEAP):"><meta name=author content="Kaga Blog"><link rel="preload stylesheet" as=style href=https://bleedkagax.github.io/main.min.css><link rel=preload as=image href=https://bleedkagax.github.io/theme.png><script defer src=https://bleedkagax.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.0"><meta itemprop=name content="Mysql Interview"><meta itemprop=description content="What are the main MySQL storage engines and their differences? MySQL supports multiple storage engines, each with distinct characteristics:
InnoDB:
Default engine since MySQL 5.5 Supports ACID transactions Provides row-level locking Supports foreign keys and relationship constraints Uses clustered indexes MyISAM:
Older engine, used as default before MySQL 5.5 Non-transactional Table-level locking Faster for read-heavy operations Supports full-text indexing Memory (HEAP):"><meta itemprop=datePublished content="2024-09-07T00:00:00+00:00"><meta itemprop=dateModified content="2024-09-07T00:00:00+00:00"><meta itemprop=wordCount content="2134"><meta itemprop=keywords content="Mysql"><meta property="og:url" content="https://bleedkagax.github.io/post/0_mysql_interview/"><meta property="og:site_name" content="Kaga Blog"><meta property="og:title" content="Mysql Interview"><meta property="og:description" content="What are the main MySQL storage engines and their differences? MySQL supports multiple storage engines, each with distinct characteristics:
InnoDB:
Default engine since MySQL 5.5 Supports ACID transactions Provides row-level locking Supports foreign keys and relationship constraints Uses clustered indexes MyISAM:
Older engine, used as default before MySQL 5.5 Non-transactional Table-level locking Faster for read-heavy operations Supports full-text indexing Memory (HEAP):"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-07T00:00:00+00:00"><meta property="article:tag" content="Mysql"><meta name=twitter:card content="summary"><meta name=twitter:title content="Mysql Interview"><meta name=twitter:description content="What are the main MySQL storage engines and their differences? MySQL supports multiple storage engines, each with distinct characteristics:
InnoDB:
Default engine since MySQL 5.5 Supports ACID transactions Provides row-level locking Supports foreign keys and relationship constraints Uses clustered indexes MyISAM:
Older engine, used as default before MySQL 5.5 Non-transactional Table-level locking Faster for read-heavy operations Supports full-text indexing Memory (HEAP):"><link rel=canonical href=https://bleedkagax.github.io/post/0_mysql_interview/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://bleedkagax.github.io/>Kaga Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Mysql Interview</h1><div class="text-xs antialiased opacity-60"><time>Sep 7, 2024</time></div></header><section><h2 id=what-are-the-main-mysql-storage-engines-and-their-differences>What are the main MySQL storage engines and their differences?</h2><p>MySQL supports multiple storage engines, each with distinct characteristics:</p><ol><li><p>InnoDB:</p><ul><li>Default engine since MySQL 5.5</li><li>Supports ACID transactions</li><li>Provides row-level locking</li><li>Supports foreign keys and relationship constraints</li><li>Uses clustered indexes</li></ul></li><li><p>MyISAM:</p><ul><li>Older engine, used as default before MySQL 5.5</li><li>Non-transactional</li><li>Table-level locking</li><li>Faster for read-heavy operations</li><li>Supports full-text indexing</li></ul></li><li><p>Memory (HEAP):</p><ul><li>Stores data in RAM for fast access</li><li>Non-persistent (data lost on restart)</li><li>Useful for temporary tables and caches</li></ul></li><li><p>Archive:</p><ul><li>Designed for storing large amounts of unindexed data</li><li>Compressed storage</li><li>Ideal for logging and data archiving</li></ul></li><li><p>CSV:</p><ul><li>Stores data in CSV files</li><li>Useful for data interchange with other applications</li></ul></li></ol><h2 id=innodbs-key-components-and-principles>InnoDB&rsquo;s Key Components and Principles</h2><p><img src=/img/0_mysql_interview.png alt></p><ol><li><p>B+ Tree Structure</p><ul><li>Used for all indexes</li><li>Efficiently handles both range and point queries</li></ul></li><li><p>Buffer Pool</p><ul><li>In-memory cache for data and indexes</li><li>Reduces disk I/O for better performance</li></ul></li><li><p>Change Buffer</p><ul><li>Caches changes to secondary indexes</li><li>Improves write performance</li></ul></li><li><p>Redo Log</p><ul><li>Records all changes to ensure durability</li><li>Crucial for crash recovery</li></ul></li><li><p>Undo Log</p><ul><li>Supports transaction rollback and consistent reads</li><li>Enables multi-version concurrency control (MVCC)</li></ul></li><li><p>ACID Compliance</p><ul><li>Ensures data integrity and reliability</li></ul></li><li><p>Row-Level Locking</p><ul><li>Allows high concurrency for multi-user environments</li></ul></li><li><p>Crash Recovery</p><ul><li>Automatic recovery after system crashes</li></ul></li><li><p>Foreign Key Support</p><ul><li>Maintains referential integrity between tables</li></ul></li><li><p>Transactions</p></li></ol><ul><li>Supports both auto-commit and explicit transactions</li></ul><h2 id=what-are-the-main-types-of-mysql-indexes-and-how-does-the-b-tree-work>What are the main types of MySQL indexes, and how does the B+ tree work?</h2><ol><li><p>B+ tree indexes:</p><ul><li>Default index type</li><li>Suitable for comparisons using &lt;, >, =, BETWEEN, and LIKE</li></ul></li><li><p>Hash indexes:</p><ul><li>Faster for exact lookups</li><li>Not suitable for range queries</li><li>Used internally by Memory tables</li></ul></li><li><p>Full-text indexes:</p><ul><li>Optimized for full-text searches</li><li>Available in MyISAM and InnoDB (since MySQL 5.6)</li></ul></li><li><p>Spatial indexes:</p><ul><li>Used for indexing spatial data types</li></ul></li></ol><p>B+ tree structure and characteristics:</p><ul><li>A self-balancing tree structure</li><li>All leaf nodes are at the same level</li><li>Internal nodes store keys and pointers to child nodes</li><li>Leaf nodes store keys and data (or pointers to data)</li><li>Leaf nodes are linked, allowing efficient range queries</li></ul><p>B+ tree advantages:</p><ul><li>Maintains sorted data for efficient range queries</li><li>Allows for fast insertions, deletions, and updates</li><li>Provides logarithmic time complexity for search operations</li><li>Reduces disk I/O by storing multiple keys in each node</li></ul><p>B+ tree in MySQL:</p><ul><li>InnoDB uses B+ trees for both clustered and secondary indexes</li><li>Clustered index stores the actual data in leaf nodes</li><li>Secondary indexes store the primary key in leaf nodes</li></ul><h2 id=when-updating-large-data-sets-in-mysql-which-strategies-can-be-used>When updating large data sets in MySQL, which strategies can be used?</h2><p>Batch the updates to minimize long transactions.
Use transactions for consistency when necessary.
Disable and re-enable indexes to speed up the process (Only applicable for non-unique indexes and for tables using the MyISAM storage engine. For InnoDB, this approach won’t work as InnoDB maintains indexes automatically.).
Use tools like pt-online-schema-change for large schema changes.
Optimize buffer pool size to handle large datasets more efficiently.
Monitor the update progress to detect and address performance bottlenecks.</p><h2 id=database-index-concepts>Database Index Concepts</h2><h3 id=1-index>1. Index</h3><p>An index is a data structure that improves the speed of data retrieval operations on a database table.</p><h3 id=2-key>2. Key</h3><p>A key is a column or set of columns in a table that is used to identify a row uniquely.</p><h3 id=3-primary-key>3. Primary Key</h3><p>A primary key is a special type of key that uniquely identifies each record in a table. It must contain unique values and cannot contain null values. A table can have only one primary key.</p><h3 id=4-clustered-index>4. Clustered Index</h3><p>A clustered index determines the physical order of data in a table. In MySQL&rsquo;s InnoDB, the primary key is always the clustered index.</p><h3 id=5-secondary-index>5. Secondary Index</h3><p>A secondary index is any index that is not the clustered index. In InnoDB, secondary index leaf nodes contain the indexed columns and a pointer to the primary key value.</p><h2 id=clustered-index-vs-secondary-index>Clustered Index vs. Secondary Index</h2><p><strong>Clustered Index:</strong></p><pre tabindex=0><code>Root Node
│
├── Internal Nodes (with key ranges)
│
└── Leaf Nodes (contain actual data rows)
</code></pre><p><strong>Secondary Index:</strong></p><pre tabindex=0><code>Root Node
│
├── Internal Nodes (with key ranges)
│
└── Leaf Nodes (contain indexed column + primary key)
</code></pre><h2 id=explain-the-differences-between-myisam-and-innodb-storage-engines>Explain the differences between MyISAM and InnoDB storage engines.</h2><ul><li><p>MyISAM:</p><ul><li>Faster for read-heavy operations</li><li>Table-level locking</li><li>Does not support transactions</li><li>Does not support foreign keys</li></ul></li><li><p>InnoDB:</p><ul><li>Supports ACID transactions</li><li>Row-level locking</li><li>Supports foreign keys</li><li>Better crash recovery</li></ul></li></ul><h2 id=explain-the-concept-of-normalization-in-databases>Explain the concept of normalization in databases.</h2><p>Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity.</p><ol><li>First Normal Form (1NF): Eliminate repeating groups</li><li>Second Normal Form (2NF): Eliminate partial dependencies</li><li>Third Normal Form (3NF): Eliminate transitive dependencies</li><li>Boyce-Codd Normal Form (BCNF): A stricter version of 3NF</li></ol><h2 id=what-is-a-transaction-in-mysql>What is a transaction in MySQL?</h2><p>A transaction is a sequence of one or more SQL statements that are executed as a single unit of work. The main properties of transactions are often referred to as ACID:</p><ul><li>Atomicity: All operations in a transaction succeed or every operation is rolled back</li><li>Consistency: The database is in a consistent state before and after the transaction</li><li>Isolation: Intermediate transaction states are invisible to other transactions</li><li>Durability: Completed transactions are permanently saved in the database</li></ul><h2 id=explain-the-different-types-of-joins-in-mysql>Explain the different types of joins in MySQL.</h2><ul><li>INNER JOIN: Returns rows when there is a match in both tables</li><li>LEFT JOIN: Returns all rows from the left table, and the matched rows from the right table</li><li>RIGHT JOIN: Returns all rows from the right table, and the matched rows from the left table</li><li>FULL JOIN: Returns rows when there is a match in one of the tables</li><li>CROSS JOIN: Returns the Cartesian product of the two tables</li></ul><h2 id=what-is-the-difference-between-char-and-varchar-data-types>What is the difference between CHAR and VARCHAR data types?</h2><ul><li>CHAR: Fixed-length string data type. Always uses the specified length, padding with spaces if necessary</li><li>VARCHAR: Variable-length string data type. Uses only as much space as needed, plus one or two bytes to store length</li></ul><h2 id=explain-the-concept-of-indexing-in-mysql>Explain the concept of indexing in MySQL.</h2><p>Indexing is a data structure technique used to quickly locate and access data in a database. It improves the speed of data retrieval operations but can slow down data insertion and update operations.</p><h2 id=what-is-a-stored-procedure-in-mysql>What is a stored procedure in MySQL?</h2><p>A stored procedure is a prepared SQL code that you can save and reuse. Benefits include:</p><ul><li>Improved performance (compiled once, stored in executable form)</li><li>Reduction in network traffic</li><li>Centralized business logic in the database server</li></ul><h2 id=explain-the-concept-of-database-sharding>Explain the concept of database sharding.</h2><p>Sharding is a database architecture pattern related to horizontal partitioning — the practice of separating one table&rsquo;s rows into multiple different tables, known as partitions. Each partition has the same schema and columns, but entirely different rows.</p><h2 id=when-using-hash-index-in-mysql-it-supports-ange-quesry>When using hash index in mysql, it supports ange quesry?</h2><p>When using a hash index in MySQL, it only supports equality comparisons using the = or &lt;=> operators. It does not support range queries (e.g., using &lt;, >, &lt;=, >=, BETWEEN, LIKE). This is a key limitation of hash indexes compared to B+ tree indexes, which support both equality and range comparisons.</p><h2 id=explain--operator>Explain &lt;=> operator</h2><p>In MySQL, the <code>&lt;=></code> operator is the NULL-safe equality comparison operator.
It compares two values for equality, but treats NULL values as equal to each other. This is different from the = operator, which considers NULL unequal to any value, including another NULL.</p><p>For example:</p><ul><li><code>NULL = NULL</code> evaluates to <code>false</code>.</li><li><code>NULL &lt;=> NULL</code> evaluates to <code>true</code>.</li></ul><h2 id=query-processing>Query Processing</h2><p>MySQL processes queries through several stages:</p><ol><li>Parsing: Checks SQL syntax and creates a parse tree.</li><li>Preprocessing: Checks table and column existence, resolves aliases.</li><li>Query optimization: Determines the most efficient execution plan.</li><li>Execution: Runs the query and returns results.</li></ol><p>Key components:</p><ul><li>Query Cache (deprecated in MySQL 8.0)</li><li>Query Optimizer</li><li>Storage Engine API</li></ul><h2 id=transactions-and-locking>Transactions and Locking</h2><p>MySQL supports transactions and various locking mechanisms:</p><ol><li>ACID properties: Ensures data integrity and consistency.</li><li>Isolation levels: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE.</li><li>Locking mechanisms:<ul><li>Table-level locks</li><li>Row-level locks (InnoDB)</li><li>Intention locks</li><li>Gap locks and next-key locks (InnoDB)</li></ul></li></ol><h2 id=query-optimization>Query Optimization</h2><ol><li><p>Use appropriate indexes:</p><ul><li>Create indexes on frequently queried columns.</li><li>Use composite indexes for multi-column conditions.</li></ul></li><li><p>Optimize JOIN operations:</p><ul><li>Use proper join types (INNER, LEFT, RIGHT).</li><li>Order tables in joins from smallest to largest.</li></ul></li><li><p>Utilize EXPLAIN to analyze query execution plans:</p><ul><li>Identify full table scans and inefficient index usage.</li><li>Look for opportunities to add or modify indexes.</li></ul></li><li><p>Avoid using wildcards at the beginning of LIKE patterns:</p><ul><li>Use <code>column LIKE 'abc%'</code> instead of <code>column LIKE '%abc'</code>.</li></ul></li><li><p>Use LIMIT for pagination:</p><ul><li>Implement efficient pagination with LIMIT and OFFSET.</li></ul></li><li><p>Optimize subqueries:</p><ul><li>Rewrite subqueries as JOINs when possible.</li><li>Use correlated subqueries judiciously.</li></ul></li><li><p>Utilize query hints:</p><ul><li>Use INDEX hints to force specific index usage.</li><li>Apply JOIN_ORDER hints for complex queries.</li></ul></li><li><p>Implement proper WHERE clause:</p><ul><li>Place most restrictive conditions first.</li><li>Avoid using functions on indexed columns in WHERE clauses.</li></ul></li><li><p>Use appropriate data types:</p><ul><li>Choose the smallest data type that can hold the required data.</li><li>Use ENUM or SET for columns with a fixed set of values.</li></ul></li><li><p>Optimize GROUP BY and ORDER BY:</p></li></ol><ul><li>Add indexes to support these operations.</li><li>Use covering indexes when possible.</li></ul><h2 id=schema-optimization>Schema Optimization</h2><ol><li><p>Normalize tables appropriately:</p><ul><li>Aim for 3NF (Third Normal Form) in most cases.</li><li>Consider denormalization for read-heavy workloads.</li></ul></li><li><p>Use appropriate data types:</p><ul><li>Use INT for primary keys instead of larger types like BIGINT when possible.</li><li>Use VARCHAR instead of CHAR for variable-length strings.</li></ul></li><li><p>Implement proper constraints:</p><ul><li>Use foreign key constraints to maintain data integrity.</li><li>Implement CHECK constraints for data validation.</li></ul></li><li><p>Partition large tables:</p><ul><li>Use range, list, or hash partitioning for better query performance.</li><li>Implement partition pruning for efficient data access.</li></ul></li><li><p>Use efficient storage engines:</p><ul><li>Use InnoDB for transactional tables.</li><li>Consider MyISAM for read-only or read-heavy tables.</li></ul></li><li><p>Implement proper indexing strategy:</p><ul><li>Create indexes based on query patterns.</li><li>Avoid over-indexing, which can slow down writes.</li></ul></li><li><p>Use appropriate character sets and collations:</p><ul><li>Use UTF8MB4 for full Unicode support.</li><li>Choose appropriate collations for sorting and comparison.</li></ul></li><li><p>Implement vertical partitioning:</p><ul><li>Split large tables into smaller ones based on column usage patterns.</li></ul></li><li><p>Use computed columns:</p><ul><li>Implement computed columns for frequently calculated values.</li></ul></li><li><p>Optimize BLOB and TEXT columns:</p></li></ol><ul><li>Store large objects separately when possible.</li><li>Use external file storage for very large objects.</li></ul><h2 id=server-configuration-optimization>Server Configuration Optimization</h2><p>Optimize MySQL server configuration for better performance:</p><ol><li><p>Adjust buffer pool size:</p><ul><li>Set innodb_buffer_pool_size to 70-80% of available RAM for InnoDB.</li></ul></li><li><p>Optimize thread handling:</p><ul><li>Set thread_cache_size appropriately to reduce thread creation overhead.</li></ul></li><li><p>Configure query cache (for versions prior to 8.0):</p><ul><li>Set query_cache_type and query_cache_size based on workload.</li></ul></li><li><p>Adjust max_connections:</p><ul><li>Set based on expected concurrent connections.</li></ul></li><li><p>Optimize file system usage:</p><ul><li>Use innodb_file_per_table for easier management of table spaces.</li></ul></li><li><p>Configure log files:</p><ul><li>Set appropriate sizes for binary log and InnoDB log files.</li></ul></li><li><p>Optimize I/O subsystem:</p><ul><li>Use innodb_flush_method=O_DIRECT on Linux for improved I/O performance.</li></ul></li><li><p>Tune sort buffer:</p><ul><li>Adjust sort_buffer_size based on complex query requirements.</li></ul></li><li><p>Configure temporary tables:</p><ul><li>Set tmp_table_size and max_heap_table_size for in-memory temporary tables.</li></ul></li><li><p>Optimize network settings:</p></li></ol><ul><li>Adjust max_allowed_packet for large queries or BLOB data.</li></ul><h2 id=hardware-optimization>Hardware Optimization</h2><p>Optimize hardware for MySQL performance:</p><ol><li><p>Use SSDs for database storage:</p><ul><li>Significantly improves random I/O performance.</li></ul></li><li><p>Implement RAID for improved I/O:</p><ul><li>Use RAID 10 for balanced read/write performance.</li></ul></li><li><p>Allocate sufficient RAM:</p><ul><li>Ensure enough memory for MySQL buffer pool and operating system.</li></ul></li><li><p>Use multiple CPU cores:</p><ul><li>MySQL can utilize multiple cores for query execution.</li></ul></li><li><p>Optimize network infrastructure:</p><ul><li>Use high-speed network interfaces and switches.</li></ul></li><li><p>Implement proper storage layout:</p><ul><li>Separate data files, log files, and temporary files on different disks.</li></ul></li><li><p>Consider using PCIe NVMe drives:</p><ul><li>Provides extremely high I/O performance for demanding workloads.</li></ul></li><li><p>Use battery-backed write cache:</p><ul><li>Improves write performance while maintaining data integrity.</li></ul></li><li><p>Implement proper cooling and power supply:</p><ul><li>Ensure stable environment for consistent performance.</li></ul></li><li><p>Consider using dedicated database servers:</p></li></ol><ul><li>Separates database workload from application servers.</li></ul><h2 id=replication>Replication</h2><ol><li><p>Asynchronous replication:</p><ul><li>Traditional master-slave setup.</li><li>Slaves can lag behind the master.</li></ul></li><li><p>Semi-synchronous replication:</p><ul><li>Master waits for at least one slave to acknowledge receipt of events.</li></ul></li><li><p>Group Replication:</p><ul><li>Multi-master update everywhere replication with built-in conflict detection.</li></ul></li><li><p>Binary log file position-based replication:</p><ul><li>Traditional method using binary log positions.</li></ul></li><li><p>GTID-based replication:</p><ul><li>Uses Global Transaction Identifiers for easier failover and slave provisioning.</li></ul></li></ol><p>Key features:</p><ul><li>Row-based, statement-based, or mixed replication formats.</li><li>Parallel replication for improved performance.</li><li>Delayed replication for disaster recovery.</li></ul><h2 id=partitioning>Partitioning</h2><p>MySQL supports table partitioning for improved query performance and data management:</p><ol><li><p>Range partitioning:</p><ul><li>Partitions based on column value ranges.</li></ul></li><li><p>List partitioning:</p><ul><li>Partitions based on lists of column values.</li></ul></li><li><p>Hash partitioning:</p><ul><li>Distributes data evenly across partitions using a hash function.</li></ul></li><li><p>Key partitioning:</p><ul><li>Similar to hash partitioning but uses MySQL&rsquo;s internal hashing function.</li></ul></li><li><p>Composite partitioning:</p><ul><li>Combines multiple partitioning methods.</li></ul></li></ol><p>Benefits:</p><ul><li>Improved query performance through partition pruning.</li><li>Easier data archiving and deletion.</li><li>Better distribution of data across multiple disks.</li></ul><h2 id=countcount1countprimary_key_fieldcountfield><code>COUNT(*)``COUNT(1)``COUNT(primary_key_field)``COUNT(field)</code></h2><table><thead><tr><th style=text-align:left><strong>Function</strong></th><th style=text-align:left><strong>Count Content</strong></th><th style=text-align:left><strong>Affected by NULLs</strong></th><th style=text-align:left><strong>Performance</strong></th></tr></thead><tbody><tr><td style=text-align:left><code>COUNT(*)</code></td><td style=text-align:left>All rows</td><td style=text-align:left>Not affected</td><td style=text-align:left>Typically the fastest, highly optimized by DBMS</td></tr><tr><td style=text-align:left><code>COUNT(1)</code></td><td style=text-align:left>All rows (equivalent to <code>COUNT(*)</code>)</td><td style=text-align:left>Not affected</td><td style=text-align:left>Similar performance to <code>COUNT(*)</code></td></tr><tr><td style=text-align:left><code>COUNT(primary_key_field)</code></td><td style=text-align:left>Number of non-NULL values in the primary key field</td><td style=text-align:left>Typically not affected (primary keys are usually <code>NOT NULL</code>)</td><td style=text-align:left>Similar performance to <code>COUNT(*)</code></td></tr><tr><td style=text-align:left><code>COUNT(field)</code></td><td style=text-align:left>Number of non-NULL values in the specified field</td><td style=text-align:left>Affected</td><td style=text-align:left>Generally slower than <code>COUNT(*)</code> and <code>COUNT(1)</code>, depends on indexing</td></tr></tbody></table></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://bleedkagax.github.io/tags/mysql>Mysql</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://bleedkagax.github.io/post/1_jaeger/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Jaeger</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://bleedkagax.github.io/post/1_mysql_join_types_comparison/><span>Mysql's Join Types Comparison</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid [&_svg]:block [&_svg]:m-auto">${e.innerHTML}</div>`})</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://bleedkagax.github.io/>Kaga Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>