<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis, Pika, and Codis | Kaga Blog</title>
<meta name=keywords content="Redis"><meta name=description content="Comprehensive Technical Analysis: Redis, Pika, and Codis
Introduction
In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.
Redis
Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/1_redis_pika_codis/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/1_redis_pika_codis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis, Pika, and Codis"><meta property="og:description" content="Comprehensive Technical Analysis: Redis, Pika, and Codis
Introduction
In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.
Redis
Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/1_redis_pika_codis/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-09T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis, Pika, and Codis"><meta name=twitter:description content="Comprehensive Technical Analysis: Redis, Pika, and Codis
Introduction
In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.
Redis
Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Redis, Pika, and Codis","item":"https://bleedkagax.github.io/post/1_redis_pika_codis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis, Pika, and Codis","name":"Redis, Pika, and Codis","description":"Comprehensive Technical Analysis: Redis, Pika, and Codis Introduction In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.\nRedis Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue.\n","keywords":["Redis"],"articleBody":"Comprehensive Technical Analysis: Redis, Pika, and Codis Introduction In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.\nRedis Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue.\nRedis Core Architecture Redis follows a single-threaded, event-driven model using an I/O multiplexing technique.\ngraph TD A[Client Connections] --\u003e B[Event Loop] B --\u003e C[Command Processing] C --\u003e D[In-Memory Data Structures] D --\u003e E[Persistence Layer] B --\u003e F[Replication] B --\u003e G[Pub/Sub] B --\u003e H[Transactions] The event loop efficiently handles multiple client connections using mechanisms like epoll (Linux) or kqueue (BSD).\nKey components:\nEvent Loop: Manages I/O events and timers Command Processing: Executes Redis commands In-Memory Data Structures: Stores and manipulates data Persistence Layer: Handles RDB and AOF persistence Replication: Manages master-slave replication Pub/Sub: Implements publish/subscribe messaging Transactions: Handles atomic command execution Redis Data Structures and Implementations Redis offers a rich set of data structures, each with specific use cases and internal implementations:\nStrings Implementation: Simple dynamic string (SDS) Use case: Caching, counters, bit operations SET key \"Hello, Redis!\" GET key INCR counter SETBIT flag 10 1 Lists Implementation: Linked list or ziplist (for small lists) Use case: Message queues, recent items lists LPUSH mylist \"item1\" \"item2\" RPOP mylist LRANGE mylist 0 -1 Sets Implementation: Hash table or intset (for small integer sets) Use case: Unique items, relations between objects SADD myset \"member1\" \"member2\" SMEMBERS myset SINTER set1 set2 Sorted Sets Implementation: Skip list and hash table Use case: Leaderboards, priority queues ZADD leaderboard 100 \"player1\" 200 \"player2\" ZRANGE leaderboard 0 -1 WITHSCORES Hashes Implementation: Hash table or ziplist (for small hashes) Use case: Object representation, field-value pairs HSET user:1 name \"John\" age 30 HGETALL user:1 Bitmaps and HyperLogLogs Implementation: Special encoding of string keys Use case: Space-efficient storage of boolean information, cardinality estimation SETBIT visitors 10 1 BITCOUNT visitors PFADD unique_visitors \"user1\" \"user2\" PFCOUNT unique_visitors Streams Implementation: Radix tree Use case: Log storage, time-series data XADD mystream * sensor-id 1234 temperature 19.8 XRANGE mystream - + Redis Persistence Mechanisms Redis offers two primary persistence options:\nRDB (Redis Database) Point-in-time snapshots of the dataset Compact single-file format Suitable for backups and disaster recovery save 900 1 save 300 10 save 60 10000 AOF (Append-Only File) Logs every write operation Higher durability Supports background rewrite for log compaction appendonly yes appendfsync everysec auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb Implementation details:\nRDB uses fork() to create a child process for snapshotting AOF uses a write buffer and background fsync for performance Redis Replication and High Availability Redis supports master-slave replication for high availability and read scalability.\ngraph TD A[Master] --\u003e|Sync| B[Slave 1] A --\u003e|Sync| C[Slave 2] A --\u003e|Sync| D[Slave 3] E[Sentinel 1] --\u003e|Monitor| A E --\u003e|Monitor| B E --\u003e|Monitor| C E --\u003e|Monitor| D F[Sentinel 2] --\u003e|Monitor| A F --\u003e|Monitor| B F --\u003e|Monitor| C F --\u003e|Monitor| D G[Sentinel 3] --\u003e|Monitor| A G --\u003e|Monitor| B G --\u003e|Monitor| C G --\u003e|Monitor| D Key features:\nAsynchronous replication Partial resynchronization for efficiency Redis Sentinel for automatic failover Configuration example:\n# On slave slaveof 192.168.1.100 6379 slave-read-only yes # Sentinel configuration sentinel monitor mymaster 192.168.1.100 6379 2 sentinel down-after-milliseconds mymaster 5000 sentinel failover-timeout mymaster 60000 Redis Clustering and Sharding Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\ngraph TD A[Client] --\u003e B[Redis Cluster] B --\u003e C[Node 1 0-5460] B --\u003e D[Node 2 5461-10922] B --\u003e E[Node 3 10923-16383] C \u003c--\u003e|Gossip| D D \u003c--\u003e|Gossip| E E \u003c--\u003e|Gossip| C C --\u003e F[Replica 1] D --\u003e G[Replica 2] E --\u003e H[Replica 3] Key features:\n16384 hash slots distributed across nodes Client-side sharding using CRC16 Automatic failover and resharding Cluster setup example:\nredis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\ 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\ --cluster-replicas 1 Redis Transactions and Lua Scripting Redis supports transactions and Lua scripting for complex operations.\nTransactions Allows execution of a group of commands in a single step Provides optimistic locking with WATCH command MULTI INCR foo INCR bar EXEC Lua Scripting Allows execution of complex operations atomically Scripts are executed using SHA1 digest for efficiency EVAL \"return redis.call('SET', KEYS[1], ARGV[1])\" 1 mykey myvalue Redis Pub/Sub and Streams Redis provides publish/subscribe messaging and a more advanced streams data structure.\nPub/Sub Allows for real-time messaging between publishers and subscribers SUBSCRIBE channel1 channel2 PUBLISH channel1 \"Hello, subscribers!\" Streams Append-only log data structure Supports consumer groups for parallel processing XADD mystream * field1 value1 field2 value2 XREAD COUNT 2 STREAMS mystream 0-0 Redis Memory Management and Eviction Policies Redis manages memory carefully and provides eviction policies for when memory limits are reached.\nMemory management techniques:\nJemalloc memory allocator Memory sharing between instances (copy-on-write) Eviction policies:\nvolatile-lru allkeys-lru volatile-random allkeys-random volatile-ttl noeviction Configuration example:\nmaxmemory 100mb maxmemory-policy allkeys-lru Pika Pika is a persistent huge storage service, compatible with the Redis protocol but designed to handle datasets larger than memory.\nPika Architecture and Design Principles Pika uses a multi-threaded architecture with RocksDB as its storage engine.\ngraph TD A[Client Connections] --\u003e B[Network Thread] B --\u003e C[Worker Threads] C --\u003e D[RocksDB Storage Engine] D --\u003e E[Disk Storage] F[Backup Thread] --\u003e D G[Compact Thread] --\u003e D Key components:\nNetwork Thread: Handles client connections and command parsing Worker Threads: Execute commands and interact with RocksDB RocksDB Storage Engine: Manages data persistence and retrieval Backup Thread: Handles asynchronous backups Compact Thread: Manages RocksDB compaction Pika Storage Engine: RocksDB Integration Pika leverages RocksDB for efficient storage and retrieval of large datasets.\nKey features:\nLog-structured merge-tree (LSM) based storage Efficient range queries and compactions Write-ahead logging for durability RocksDB configuration example:\nrocksdb::Options options; options.create_if_missing = true; options.write_buffer_size = 64 * 1024 * 1024; // 64MB options.max_write_buffer_number = 3; options.target_file_size_base = 32 * 1024 * 1024; // 32MB options.max_background_compactions = 4; options.max_background_flushes = 2; options.compression = rocksdb::kSnappyCompression; Pika Thread Model and Concurrency Pika uses a multi-threaded model to improve performance and concurrency.\ngraph TD A[Client Requests] --\u003e B[Dispatch Thread] B --\u003e C[Worker Thread 1] B --\u003e D[Worker Thread 2] B --\u003e E[Worker Thread N] C --\u003e F[RocksDB] D --\u003e F E --\u003e F Implementation details:\nThread pool for handling client requests Lock-free data structures for inter-thread communication Fine-grained locking for concurrent access to data structures Pika Data Structures and Redis Compatibility Pika supports most Redis data structures and commands, with some limitations.\nSupported data structures:\nStrings Hashes Lists Sets Sorted Sets Example of using Pika with a Redis client:\nimport redis p = redis.Redis(host='localhost', port=9221, db=0) # String operations p.set('key', 'value') print(p.get('key')) # Hash operations p.hset('hash', 'field1', 'value1') p.hset('hash', 'field2', 'value2') print(p.hgetall('hash')) # List operations p.lpush('list', 'item1', 'item2', 'item3') print(p.lrange('list', 0, -1)) Pika Replication and Consistency Pika supports master-slave replication for high availability and data consistency.\ngraph TD A[Master] --\u003e|Binary Log| B[Slave 1] A --\u003e|Binary Log| C[Slave 2] A --\u003e|Binary Log| D[Slave 3] Replication features:\nAsynchronous replication Full and incremental sync support Configurable sync speed limit Configuration example:\n# On master slave-read-only no # On slave slaveof 192.168.1.100 9221 slave-read-only yes Pika Backup and Recovery Pika provides mechanisms for backup and recovery to ensure data durability.\nBackup methods:\nFull Backup: Complete snapshot of the database Incremental Backup: Only changes since the last backup Recovery process:\nStop Pika server Replace data directory with backup Start Pika server Backup command example:\n./pika_tools -t backup -s ./pika.conf Pika Performance Optimization Techniques Pika employs various techniques to optimize performance:\nWrite Amplification Reduction: Careful tuning of RocksDB parameters Read Amplification Reduction: Use of bloom filters and cache Compaction Optimization: Background compaction and level-based compaction Memory Management: Efficient use of block cache and index cache RocksDB tuning example:\nrocksdb::BlockBasedTableOptions table_options; table_options.block_cache = rocksdb::NewLRUCache(100 * 1024 * 1024); // 100MB cache table_options.filter_policy.reset(rocksdb::NewBloomFilterPolicy(10)); rocksdb::Options options; options.table_factory.reset(NewBlockBasedTableFactory(table_options)); options.optimize_filters_for_hits = true; options.level_compaction_dynamic_level_bytes = true; Codis Codis is a proxy-based Redis cluster solution that supports dynamic scaling and provides high availability.\nCodis System Architecture and Components Codis consists of several key components working together to provide a scalable Redis cluster solution.\ngraph TD A[Client] --\u003e B[Codis Proxy] B --\u003e C[Redis 1] B --\u003e D[Redis 2] B --\u003e E[Redis N] F[Codis Dashboard] --\u003e B F --\u003e C F --\u003e D F --\u003e E G[Zookeeper/Etcd] --\u003e F H[Codis FE] --\u003e F I[Codis Admin] --\u003e F Key components:\nCodis Proxy: Stateless proxy that routes requests to the correct Redis instance Codis Dashboard: Manages the cluster topology and handles administrative tasks Codis FE: Web interface for cluster management Zookeeper/Etcd: Distributed configuration and coordination service Redis Instances: Actual data storage nodes Codis Proxy Design and Implementation The Codis Proxy is a core component that handles request routing and connection management.\ngraph TD A[Client Connections] --\u003e B[Connection Pool] B --\u003e C[Request Parser] C --\u003e D[Router] D --\u003e E[Backend Connection Pool] E --\u003e F[Redis Instances] Key features:\nSupports pipelining and multiplexing Implements consistent hashing for request routing Handles connection pooling for efficient resource utilization Proxy configuration example:\nproduct_name = \"test\" product_auth = \"\" proxy_id = \"proxy_1\" admin_addr = \"0.0.0.0:11080\" proto_type = \"tcp4\" proxy_addr = \"0.0.0.0:19000\" jodis_addr = \"zookeeper:2181\" jodis_timeout = 10 jodis_compatible = false session_break_on_failure = false Codis Data Sharding and Rebalancing Codis uses pre-sharding and dynamic slot allocation for data distribution.\ngraph TD A[1024 Slots] --\u003e B[Group 1] A --\u003e C[Group 2] A --\u003e D[Group N] B --\u003e E[Redis 1] B --\u003e F[Redis 1 Slave] C --\u003e G[Redis 2] C --\u003e H[Redis 2 Slave] D --\u003e I[Redis N] D --\u003e J[Redis N Slave] Sharding details:\n1024 slots pre-defined Slots can be migrated between groups Each group contains a master-slave pair of Redis instances Rebalancing process:\nInitiate rebalance through Codis Dashboard Slots are gradually migrated between groups Proxies update their routing table in real-time Codis High Availability and Fault Tolerance Codis provides high availability through redundancy and automatic failover.\ngraph TD A[Codis Dashboard] --\u003e B[Group 1] A --\u003e C[Group 2] A --\u003e D[Group N] B --\u003e E[Redis Master] B --\u003e F[Redis Slave] C --\u003e G[Redis Master] C --\u003e H[Redis Slave] D --\u003e I[Redis Master] D --\u003e J[Redis Slave] K[Zookeeper/Etcd] --\u003e A High availability features:\nAutomatic failover within groups Multiple Codis Proxies for load balancing Zookeeper/Etcd for configuration consistency Failover process:\nDashboard detects master failure Promote slave to master Update routing information in Zookeeper/Etcd Proxies update their routing table Codis Scaling and Online Migration Codis supports online scaling without downtime.\nScaling process:\nAdd new Redis instances to the cluster Create new groups in Codis Dashboard Initiate slot migration from existing groups to new groups Proxies automatically update routing information Migration command example:\ncodis-admin --dashboard=localhost:18080 --rebalance --confirm Codis Monitoring and Management Codis provides tools for monitoring and managing the cluster.\nMonitoring features:\nCodis FE web interface Prometheus integration for metrics Grafana dashboards for visualization Management tasks:\nAdding/removing nodes Manual failover Slot migration Configuration updates Codis Compatibility and Limitations While Codis is highly compatible with Redis, it has some limitations:\nMulti-key operations are limited to keys in the same slot Some Redis commands are not supported (e.g., KEYS, MOVE, MIGRATE) Custom support required for some language clients Client usage example (Python):\nfrom codis import CodisConnectionPool pool = CodisConnectionPool(host='localhost', port=19000, db=0) c = pool.get_connection() c.set('key', 'value') print(c.get('key')) c.hset('hash', 'field', 'value') print(c.hgetall('hash')) Comparative Analysis Performance Benchmarks Benchmark results for 100-byte SET/GET operations (operations per second):\ngraph TD A[Redis] --\u003e|150k| B[SET] A --\u003e|200k| C[GET] D[Pika] --\u003e|80k| B D --\u003e|100k| C E[Codis] --\u003e|130k| B E --\u003e|180k| C Note: These are approximate values and can vary based on hardware and configuration.\nUse Case Scenarios Redis:\nHigh-performance caching Real-time analytics Session storage Leaderboards and counters Pika:\nLarge datasets exceeding memory limits Persistent key-value storage Write-heavy workloads Codis:\nLarge-scale Redis deployments Need for horizontal scaling High availability requirements Scalability and Reliability Comparison Feature Redis Pika Codis Vertical Scaling Excellent Good Good Horizontal Scaling Limited (Redis Cluster) Limited Excellent Data Persistence Optional (RDB/AOF) Always On (RocksDB) Inherited from Redis High Availability Through Sentinel Master-Slave Built-in Automatic Failover Yes (with Sentinel) Manual Yes Online Scaling Limited Limited Yes Operational Complexity Redis:\nSimple for single instance Moderate complexity for Redis Cluster Pika:\nModerate complexity Requires RocksDB tuning for optimal performance Codis:\nHigher complexity Requires management of multiple components Conclusion Redis, Pika, and Codis each offer unique solutions to different data storage and caching challenges:\nRedis excels in high-performance, in-memory operations and is ideal for scenarios where data fits in memory. Pika offers a good balance between performance and large dataset support, making it suitable for applications that need to persist data larger than available memory. Codis provides a scalable Redis cluster solution, ideal for large-scale deployments that require horizontal scaling and high availability. ","wordCount":"2116","inLanguage":"en","datePublished":"2024-09-09T00:00:00Z","dateModified":"2024-09-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/1_redis_pika_codis/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redis, Pika, and Codis</h1><div class=post-meta><span title='2024-09-09 00:00:00 +0000 UTC'>September 9, 2024</span></div></header><div class=post-content><h1 id=comprehensive-technical-analysis-redis-pika-and-codis>Comprehensive Technical Analysis: Redis, Pika, and Codis<a hidden class=anchor aria-hidden=true href=#comprehensive-technical-analysis-redis-pika-and-codis>#</a></h1><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In the realm of distributed data storage and caching systems, Redis, Pika, and Codis represent three distinct approaches to solving scalability, persistence, and performance challenges. This comprehensive analysis delves deep into the architectures, features, and use cases of these systems, providing detailed code examples and visual representations to facilitate a thorough understanding.</p><h2 id=redis>Redis<a hidden class=anchor aria-hidden=true href=#redis>#</a></h2><p>Redis (Remote Dictionary Server) is an open-source, in-memory data structure store that has become a cornerstone in modern application architectures. Its versatility allows it to function as a database, cache, message broker, and queue.</p><h3 id=redis-core-architecture>Redis Core Architecture<a hidden class=anchor aria-hidden=true href=#redis-core-architecture>#</a></h3><p>Redis follows a single-threaded, event-driven model using an I/O multiplexing technique.</p><pre class=mermaid>
    graph TD
	    A[Client Connections] --&gt; B[Event Loop]
	    B --&gt; C[Command Processing]
	    C --&gt; D[In-Memory Data Structures]
	    D --&gt; E[Persistence Layer]
	    B --&gt; F[Replication]
	    B --&gt; G[Pub/Sub]
	    B --&gt; H[Transactions]
</pre><p>The event loop efficiently handles multiple client connections using mechanisms like <code>epoll</code> (Linux) or <code>kqueue</code> (BSD).</p><p>Key components:</p><ul><li><strong>Event Loop</strong>: Manages I/O events and timers</li><li><strong>Command Processing</strong>: Executes Redis commands</li><li><strong>In-Memory Data Structures</strong>: Stores and manipulates data</li><li><strong>Persistence Layer</strong>: Handles RDB and AOF persistence</li><li><strong>Replication</strong>: Manages master-slave replication</li><li><strong>Pub/Sub</strong>: Implements publish/subscribe messaging</li><li><strong>Transactions</strong>: Handles atomic command execution</li></ul><h3 id=redis-data-structures-and-implementations>Redis Data Structures and Implementations<a hidden class=anchor aria-hidden=true href=#redis-data-structures-and-implementations>#</a></h3><p>Redis offers a rich set of data structures, each with specific use cases and internal implementations:</p><ol><li><strong>Strings</strong><ul><li>Implementation: Simple dynamic string (SDS)</li><li>Use case: Caching, counters, bit operations</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>SET key &#34;Hello, Redis!&#34;
GET key
INCR counter
SETBIT flag 10 1
</code></pre><ol start=2><li><strong>Lists</strong><ul><li>Implementation: Linked list or ziplist (for small lists)</li><li>Use case: Message queues, recent items lists</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>LPUSH mylist &#34;item1&#34; &#34;item2&#34;
RPOP mylist
LRANGE mylist 0 -1
</code></pre><ol start=3><li><strong>Sets</strong><ul><li>Implementation: Hash table or intset (for small integer sets)</li><li>Use case: Unique items, relations between objects</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>SADD myset &#34;member1&#34; &#34;member2&#34;
SMEMBERS myset
SINTER set1 set2
</code></pre><ol start=4><li><strong>Sorted Sets</strong><ul><li>Implementation: Skip list and hash table</li><li>Use case: Leaderboards, priority queues</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>ZADD leaderboard 100 &#34;player1&#34; 200 &#34;player2&#34;
ZRANGE leaderboard 0 -1 WITHSCORES
</code></pre><ol start=5><li><strong>Hashes</strong><ul><li>Implementation: Hash table or ziplist (for small hashes)</li><li>Use case: Object representation, field-value pairs</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>HSET user:1 name &#34;John&#34; age 30
HGETALL user:1
</code></pre><ol start=6><li><strong>Bitmaps and HyperLogLogs</strong><ul><li>Implementation: Special encoding of string keys</li><li>Use case: Space-efficient storage of boolean information, cardinality estimation</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>SETBIT visitors 10 1
BITCOUNT visitors
PFADD unique_visitors &#34;user1&#34; &#34;user2&#34;
PFCOUNT unique_visitors
</code></pre><ol start=7><li><strong>Streams</strong><ul><li>Implementation: Radix tree</li><li>Use case: Log storage, time-series data</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>XADD mystream * sensor-id 1234 temperature 19.8
XRANGE mystream - +
</code></pre><h3 id=redis-persistence-mechanisms>Redis Persistence Mechanisms<a hidden class=anchor aria-hidden=true href=#redis-persistence-mechanisms>#</a></h3><p>Redis offers two primary persistence options:</p><ol><li><strong>RDB (Redis Database)</strong><ul><li>Point-in-time snapshots of the dataset</li><li>Compact single-file format</li><li>Suitable for backups and disaster recovery</li></ul></li></ol><pre tabindex=0><code class=language-conf data-lang=conf>save 900 1
save 300 10
save 60 10000
</code></pre><ol start=2><li><strong>AOF (Append-Only File)</strong><ul><li>Logs every write operation</li><li>Higher durability</li><li>Supports background rewrite for log compaction</li></ul></li></ol><pre tabindex=0><code class=language-conf data-lang=conf>appendonly yes
appendfsync everysec
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
</code></pre><p>Implementation details:</p><ul><li>RDB uses fork() to create a child process for snapshotting</li><li>AOF uses a write buffer and background fsync for performance</li></ul><h3 id=redis-replication-and-high-availability>Redis Replication and High Availability<a hidden class=anchor aria-hidden=true href=#redis-replication-and-high-availability>#</a></h3><p>Redis supports master-slave replication for high availability and read scalability.</p><pre class=mermaid>
    graph TD
	    A[Master] --&gt;|Sync| B[Slave 1]
	    A --&gt;|Sync| C[Slave 2]
	    A --&gt;|Sync| D[Slave 3]
	    E[Sentinel 1] --&gt;|Monitor| A
	    E --&gt;|Monitor| B
	    E --&gt;|Monitor| C
	    E --&gt;|Monitor| D
	    F[Sentinel 2] --&gt;|Monitor| A
	    F --&gt;|Monitor| B
	    F --&gt;|Monitor| C
	    F --&gt;|Monitor| D
	    G[Sentinel 3] --&gt;|Monitor| A
	    G --&gt;|Monitor| B
	    G --&gt;|Monitor| C
	    G --&gt;|Monitor| D
</pre><p>Key features:</p><ul><li>Asynchronous replication</li><li>Partial resynchronization for efficiency</li><li>Redis Sentinel for automatic failover</li></ul><p>Configuration example:</p><pre tabindex=0><code class=language-conf data-lang=conf># On slave
slaveof 192.168.1.100 6379
slave-read-only yes

# Sentinel configuration
sentinel monitor mymaster 192.168.1.100 6379 2
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
</code></pre><h3 id=redis-clustering-and-sharding>Redis Clustering and Sharding<a hidden class=anchor aria-hidden=true href=#redis-clustering-and-sharding>#</a></h3><p>Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.</p><pre class=mermaid>
    graph TD
	    A[Client] --&gt; B[Redis Cluster]
	    B --&gt; C[Node 1 &lt;br/&gt; 0-5460]
	    B --&gt; D[Node 2 &lt;br/&gt; 5461-10922]
	    B --&gt; E[Node 3 &lt;br/&gt; 10923-16383]
	    C &lt;--&gt;|Gossip| D
	    D &lt;--&gt;|Gossip| E
	    E &lt;--&gt;|Gossip| C
	    C --&gt; F[Replica 1]
	    D --&gt; G[Replica 2]
	    E --&gt; H[Replica 3]
</pre><p>Key features:</p><ul><li>16384 hash slots distributed across nodes</li><li>Client-side sharding using CRC16</li><li>Automatic failover and resharding</li></ul><p>Cluster setup example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cluster-replicas <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><h3 id=redis-transactions-and-lua-scripting>Redis Transactions and Lua Scripting<a hidden class=anchor aria-hidden=true href=#redis-transactions-and-lua-scripting>#</a></h3><p>Redis supports transactions and Lua scripting for complex operations.</p><ol><li><strong>Transactions</strong><ul><li>Allows execution of a group of commands in a single step</li><li>Provides optimistic locking with WATCH command</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>MULTI
INCR foo
INCR bar
EXEC
</code></pre><ol start=2><li><strong>Lua Scripting</strong><ul><li>Allows execution of complex operations atomically</li><li>Scripts are executed using SHA1 digest for efficiency</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>EVAL &#34;return redis.call(&#39;SET&#39;, KEYS[1], ARGV[1])&#34; 1 mykey myvalue
</code></pre><h3 id=redis-pubsub-and-streams>Redis Pub/Sub and Streams<a hidden class=anchor aria-hidden=true href=#redis-pubsub-and-streams>#</a></h3><p>Redis provides publish/subscribe messaging and a more advanced streams data structure.</p><ol><li><strong>Pub/Sub</strong><ul><li>Allows for real-time messaging between publishers and subscribers</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>SUBSCRIBE channel1 channel2
PUBLISH channel1 &#34;Hello, subscribers!&#34;
</code></pre><ol start=2><li><strong>Streams</strong><ul><li>Append-only log data structure</li><li>Supports consumer groups for parallel processing</li></ul></li></ol><pre tabindex=0><code class=language-redis data-lang=redis>XADD mystream * field1 value1 field2 value2
XREAD COUNT 2 STREAMS mystream 0-0
</code></pre><h3 id=redis-memory-management-and-eviction-policies>Redis Memory Management and Eviction Policies<a hidden class=anchor aria-hidden=true href=#redis-memory-management-and-eviction-policies>#</a></h3><p>Redis manages memory carefully and provides eviction policies for when memory limits are reached.</p><p>Memory management techniques:</p><ul><li>Jemalloc memory allocator</li><li>Memory sharing between instances (copy-on-write)</li></ul><p>Eviction policies:</p><ul><li>volatile-lru</li><li>allkeys-lru</li><li>volatile-random</li><li>allkeys-random</li><li>volatile-ttl</li><li>noeviction</li></ul><p>Configuration example:</p><pre tabindex=0><code class=language-conf data-lang=conf>maxmemory 100mb
maxmemory-policy allkeys-lru
</code></pre><h2 id=pika>Pika<a hidden class=anchor aria-hidden=true href=#pika>#</a></h2><p>Pika is a persistent huge storage service, compatible with the Redis protocol but designed to handle datasets larger than memory.</p><h3 id=pika-architecture-and-design-principles>Pika Architecture and Design Principles<a hidden class=anchor aria-hidden=true href=#pika-architecture-and-design-principles>#</a></h3><p>Pika uses a multi-threaded architecture with RocksDB as its storage engine.</p><pre class=mermaid>
    graph TD
	    A[Client Connections] --&gt; B[Network Thread]
	    B --&gt; C[Worker Threads]
	    C --&gt; D[RocksDB Storage Engine]
	    D --&gt; E[Disk Storage]
	    F[Backup Thread] --&gt; D
	    G[Compact Thread] --&gt; D
</pre><p>Key components:</p><ul><li><strong>Network Thread</strong>: Handles client connections and command parsing</li><li><strong>Worker Threads</strong>: Execute commands and interact with RocksDB</li><li><strong>RocksDB Storage Engine</strong>: Manages data persistence and retrieval</li><li><strong>Backup Thread</strong>: Handles asynchronous backups</li><li><strong>Compact Thread</strong>: Manages RocksDB compaction</li></ul><h3 id=pika-storage-engine-rocksdb-integration>Pika Storage Engine: RocksDB Integration<a hidden class=anchor aria-hidden=true href=#pika-storage-engine-rocksdb-integration>#</a></h3><p>Pika leverages RocksDB for efficient storage and retrieval of large datasets.</p><p>Key features:</p><ul><li>Log-structured merge-tree (LSM) based storage</li><li>Efficient range queries and compactions</li><li>Write-ahead logging for durability</li></ul><p>RocksDB configuration example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>rocksdb<span style=color:#f92672>::</span>Options options;
</span></span><span style=display:flex><span>options.create_if_missing <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>options.write_buffer_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>64</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>;  <span style=color:#75715e>// 64MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>options.max_write_buffer_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>options.target_file_size_base <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>;  <span style=color:#75715e>// 32MB
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>options.max_background_compactions <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>options.max_background_flushes <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>options.compression <span style=color:#f92672>=</span> rocksdb<span style=color:#f92672>::</span>kSnappyCompression;
</span></span></code></pre></div><h3 id=pika-thread-model-and-concurrency>Pika Thread Model and Concurrency<a hidden class=anchor aria-hidden=true href=#pika-thread-model-and-concurrency>#</a></h3><p>Pika uses a multi-threaded model to improve performance and concurrency.</p><pre class=mermaid>
    graph TD
	    A[Client Requests] --&gt; B[Dispatch Thread]
	    B --&gt; C[Worker Thread 1]
	    B --&gt; D[Worker Thread 2]
	    B --&gt; E[Worker Thread N]
	    C --&gt; F[RocksDB]
	    D --&gt; F
	    E --&gt; F
</pre><p>Implementation details:</p><ul><li>Thread pool for handling client requests</li><li>Lock-free data structures for inter-thread communication</li><li>Fine-grained locking for concurrent access to data structures</li></ul><h3 id=pika-data-structures-and-redis-compatibility>Pika Data Structures and Redis Compatibility<a hidden class=anchor aria-hidden=true href=#pika-data-structures-and-redis-compatibility>#</a></h3><p>Pika supports most Redis data structures and commands, with some limitations.</p><p>Supported data structures:</p><ul><li>Strings</li><li>Hashes</li><li>Lists</li><li>Sets</li><li>Sorted Sets</li></ul><p>Example of using Pika with a Redis client:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> redis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> redis<span style=color:#f92672>.</span>Redis(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;localhost&#39;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>9221</span>, db<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># String operations</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>set(<span style=color:#e6db74>&#39;key&#39;</span>, <span style=color:#e6db74>&#39;value&#39;</span>)
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;key&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Hash operations</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>hset(<span style=color:#e6db74>&#39;hash&#39;</span>, <span style=color:#e6db74>&#39;field1&#39;</span>, <span style=color:#e6db74>&#39;value1&#39;</span>)
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>hset(<span style=color:#e6db74>&#39;hash&#39;</span>, <span style=color:#e6db74>&#39;field2&#39;</span>, <span style=color:#e6db74>&#39;value2&#39;</span>)
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>hgetall(<span style=color:#e6db74>&#39;hash&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># List operations</span>
</span></span><span style=display:flex><span>p<span style=color:#f92672>.</span>lpush(<span style=color:#e6db74>&#39;list&#39;</span>, <span style=color:#e6db74>&#39;item1&#39;</span>, <span style=color:#e6db74>&#39;item2&#39;</span>, <span style=color:#e6db74>&#39;item3&#39;</span>)
</span></span><span style=display:flex><span>print(p<span style=color:#f92672>.</span>lrange(<span style=color:#e6db74>&#39;list&#39;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span></code></pre></div><h3 id=pika-replication-and-consistency>Pika Replication and Consistency<a hidden class=anchor aria-hidden=true href=#pika-replication-and-consistency>#</a></h3><p>Pika supports master-slave replication for high availability and data consistency.</p><pre class=mermaid>
    graph TD
	    A[Master] --&gt;|Binary Log| B[Slave 1]
	    A --&gt;|Binary Log| C[Slave 2]
	    A --&gt;|Binary Log| D[Slave 3]
</pre><p>Replication features:</p><ul><li>Asynchronous replication</li><li>Full and incremental sync support</li><li>Configurable sync speed limit</li></ul><p>Configuration example:</p><pre tabindex=0><code class=language-conf data-lang=conf># On master
slave-read-only no

# On slave
slaveof 192.168.1.100 9221
slave-read-only yes
</code></pre><h3 id=pika-backup-and-recovery>Pika Backup and Recovery<a hidden class=anchor aria-hidden=true href=#pika-backup-and-recovery>#</a></h3><p>Pika provides mechanisms for backup and recovery to ensure data durability.</p><p>Backup methods:</p><ol><li><strong>Full Backup</strong>: Complete snapshot of the database</li><li><strong>Incremental Backup</strong>: Only changes since the last backup</li></ol><p>Recovery process:</p><ol><li>Stop Pika server</li><li>Replace data directory with backup</li><li>Start Pika server</li></ol><p>Backup command example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./pika_tools -t backup -s ./pika.conf
</span></span></code></pre></div><h3 id=pika-performance-optimization-techniques>Pika Performance Optimization Techniques<a hidden class=anchor aria-hidden=true href=#pika-performance-optimization-techniques>#</a></h3><p>Pika employs various techniques to optimize performance:</p><ol><li><strong>Write Amplification Reduction</strong>: Careful tuning of RocksDB parameters</li><li><strong>Read Amplification Reduction</strong>: Use of bloom filters and cache</li><li><strong>Compaction Optimization</strong>: Background compaction and level-based compaction</li><li><strong>Memory Management</strong>: Efficient use of block cache and index cache</li></ol><p>RocksDB tuning example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>rocksdb<span style=color:#f92672>::</span>BlockBasedTableOptions table_options;
</span></span><span style=display:flex><span>table_options.block_cache <span style=color:#f92672>=</span> rocksdb<span style=color:#f92672>::</span>NewLRUCache(<span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>);  <span style=color:#75715e>// 100MB cache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>table_options.filter_policy.reset(rocksdb<span style=color:#f92672>::</span>NewBloomFilterPolicy(<span style=color:#ae81ff>10</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rocksdb<span style=color:#f92672>::</span>Options options;
</span></span><span style=display:flex><span>options.table_factory.reset(NewBlockBasedTableFactory(table_options));
</span></span><span style=display:flex><span>options.optimize_filters_for_hits <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>options.level_compaction_dynamic_level_bytes <span style=color:#f92672>=</span> true;
</span></span></code></pre></div><h2 id=codis>Codis<a hidden class=anchor aria-hidden=true href=#codis>#</a></h2><p>Codis is a proxy-based Redis cluster solution that supports dynamic scaling and provides high availability.</p><h3 id=codis-system-architecture-and-components>Codis System Architecture and Components<a hidden class=anchor aria-hidden=true href=#codis-system-architecture-and-components>#</a></h3><p>Codis consists of several key components working together to provide a scalable Redis cluster solution.</p><pre class=mermaid>
    graph TD
	    A[Client] --&gt; B[Codis Proxy]
	    B --&gt; C[Redis 1]
	    B --&gt; D[Redis 2]
	    B --&gt; E[Redis N]
	    F[Codis Dashboard] --&gt; B
	    F --&gt; C
	    F --&gt; D
	    F --&gt; E
	    G[Zookeeper/Etcd] --&gt; F
	    H[Codis FE] --&gt; F
	    I[Codis Admin] --&gt; F
</pre><p>Key components:</p><ul><li><strong>Codis Proxy</strong>: Stateless proxy that routes requests to the correct Redis instance</li><li><strong>Codis Dashboard</strong>: Manages the cluster topology and handles administrative tasks</li><li><strong>Codis FE</strong>: Web interface for cluster management</li><li><strong>Zookeeper/Etcd</strong>: Distributed configuration and coordination service</li><li><strong>Redis Instances</strong>: Actual data storage nodes</li></ul><h3 id=codis-proxy-design-and-implementation>Codis Proxy Design and Implementation<a hidden class=anchor aria-hidden=true href=#codis-proxy-design-and-implementation>#</a></h3><p>The Codis Proxy is a core component that handles request routing and connection management.</p><pre class=mermaid>
    graph TD
	    A[Client Connections] --&gt; B[Connection Pool]
	    B --&gt; C[Request Parser]
	    C --&gt; D[Router]
	    D --&gt; E[Backend Connection Pool]
	    E --&gt; F[Redis Instances]
</pre><p>Key features:</p><ul><li>Supports pipelining and multiplexing</li><li>Implements consistent hashing for request routing</li><li>Handles connection pooling for efficient resource utilization</li></ul><p>Proxy configuration example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span><span style=color:#a6e22e>product_name</span> = <span style=color:#e6db74>&#34;test&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>product_auth</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>proxy_id</span> = <span style=color:#e6db74>&#34;proxy_1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>admin_addr</span> = <span style=color:#e6db74>&#34;0.0.0.0:11080&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>proto_type</span> = <span style=color:#e6db74>&#34;tcp4&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>proxy_addr</span> = <span style=color:#e6db74>&#34;0.0.0.0:19000&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jodis_addr</span> = <span style=color:#e6db74>&#34;zookeeper:2181&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jodis_timeout</span> = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jodis_compatible</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>session_break_on_failure</span> = <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><h3 id=codis-data-sharding-and-rebalancing>Codis Data Sharding and Rebalancing<a hidden class=anchor aria-hidden=true href=#codis-data-sharding-and-rebalancing>#</a></h3><p>Codis uses pre-sharding and dynamic slot allocation for data distribution.</p><pre class=mermaid>
    graph TD
	    A[1024 Slots] --&gt; B[Group 1]
	    A --&gt; C[Group 2]
	    A --&gt; D[Group N]
	    B --&gt; E[Redis 1]
	    B --&gt; F[Redis 1 Slave]
	    C --&gt; G[Redis 2]
	    C --&gt; H[Redis 2 Slave]
	    D --&gt; I[Redis N]
	    D --&gt; J[Redis N Slave]
</pre><p>Sharding details:</p><ul><li>1024 slots pre-defined</li><li>Slots can be migrated between groups</li><li>Each group contains a master-slave pair of Redis instances</li></ul><p>Rebalancing process:</p><ol><li>Initiate rebalance through Codis Dashboard</li><li>Slots are gradually migrated between groups</li><li>Proxies update their routing table in real-time</li></ol><h3 id=codis-high-availability-and-fault-tolerance>Codis High Availability and Fault Tolerance<a hidden class=anchor aria-hidden=true href=#codis-high-availability-and-fault-tolerance>#</a></h3><p>Codis provides high availability through redundancy and automatic failover.</p><pre class=mermaid>
    graph TD
	    A[Codis Dashboard] --&gt; B[Group 1]
	    A --&gt; C[Group 2]
	    A --&gt; D[Group N]
	    B --&gt; E[Redis Master]
	    B --&gt; F[Redis Slave]
	    C --&gt; G[Redis Master]
	    C --&gt; H[Redis Slave]
	    D --&gt; I[Redis Master]
	    D --&gt; J[Redis Slave]
	    K[Zookeeper/Etcd] --&gt; A
</pre><p>High availability features:</p><ul><li>Automatic failover within groups</li><li>Multiple Codis Proxies for load balancing</li><li>Zookeeper/Etcd for configuration consistency</li></ul><p>Failover process:</p><ol><li>Dashboard detects master failure</li><li>Promote slave to master</li><li>Update routing information in Zookeeper/Etcd</li><li>Proxies update their routing table</li></ol><h3 id=codis-scaling-and-online-migration>Codis Scaling and Online Migration<a hidden class=anchor aria-hidden=true href=#codis-scaling-and-online-migration>#</a></h3><p>Codis supports online scaling without downtime.</p><p>Scaling process:</p><ol><li>Add new Redis instances to the cluster</li><li>Create new groups in Codis Dashboard</li><li>Initiate slot migration from existing groups to new groups</li><li>Proxies automatically update routing information</li></ol><p>Migration command example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>codis-admin --dashboard<span style=color:#f92672>=</span>localhost:18080 --rebalance --confirm
</span></span></code></pre></div><h3 id=codis-monitoring-and-management>Codis Monitoring and Management<a hidden class=anchor aria-hidden=true href=#codis-monitoring-and-management>#</a></h3><p>Codis provides tools for monitoring and managing the cluster.</p><p>Monitoring features:</p><ul><li>Codis FE web interface</li><li>Prometheus integration for metrics</li><li>Grafana dashboards for visualization</li></ul><p>Management tasks:</p><ul><li>Adding/removing nodes</li><li>Manual failover</li><li>Slot migration</li><li>Configuration updates</li></ul><h3 id=codis-compatibility-and-limitations>Codis Compatibility and Limitations<a hidden class=anchor aria-hidden=true href=#codis-compatibility-and-limitations>#</a></h3><p>While Codis is highly compatible with Redis, it has some limitations:</p><ul><li>Multi-key operations are limited to keys in the same slot</li><li>Some Redis commands are not supported (e.g., KEYS, MOVE, MIGRATE)</li><li>Custom support required for some language clients</li></ul><p>Client usage example (Python):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> codis <span style=color:#f92672>import</span> CodisConnectionPool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pool <span style=color:#f92672>=</span> CodisConnectionPool(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;localhost&#39;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>19000</span>, db<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>get_connection()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>set(<span style=color:#e6db74>&#39;key&#39;</span>, <span style=color:#e6db74>&#39;value&#39;</span>)
</span></span><span style=display:flex><span>print(c<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;key&#39;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>hset(<span style=color:#e6db74>&#39;hash&#39;</span>, <span style=color:#e6db74>&#39;field&#39;</span>, <span style=color:#e6db74>&#39;value&#39;</span>)
</span></span><span style=display:flex><span>print(c<span style=color:#f92672>.</span>hgetall(<span style=color:#e6db74>&#39;hash&#39;</span>))
</span></span></code></pre></div><h2 id=comparative-analysis>Comparative Analysis<a hidden class=anchor aria-hidden=true href=#comparative-analysis>#</a></h2><h3 id=performance-benchmarks>Performance Benchmarks<a hidden class=anchor aria-hidden=true href=#performance-benchmarks>#</a></h3><p>Benchmark results for 100-byte SET/GET operations (operations per second):</p><pre class=mermaid>
    graph TD
	    A[Redis] --&gt;|150k| B[SET]
	    A --&gt;|200k| C[GET]
	    D[Pika] --&gt;|80k| B
	    D --&gt;|100k| C
	    E[Codis] --&gt;|130k| B
	    E --&gt;|180k| C
</pre><p>Note: These are approximate values and can vary based on hardware and configuration.</p><h3 id=use-case-scenarios>Use Case Scenarios<a hidden class=anchor aria-hidden=true href=#use-case-scenarios>#</a></h3><ol><li><p><strong>Redis</strong>:</p><ul><li>High-performance caching</li><li>Real-time analytics</li><li>Session storage</li><li>Leaderboards and counters</li></ul></li><li><p><strong>Pika</strong>:</p><ul><li>Large datasets exceeding memory limits</li><li>Persistent key-value storage</li><li>Write-heavy workloads</li></ul></li><li><p><strong>Codis</strong>:</p><ul><li>Large-scale Redis deployments</li><li>Need for horizontal scaling</li><li>High availability requirements</li></ul></li></ol><h3 id=scalability-and-reliability-comparison>Scalability and Reliability Comparison<a hidden class=anchor aria-hidden=true href=#scalability-and-reliability-comparison>#</a></h3><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>Redis</th><th style=text-align:left>Pika</th><th style=text-align:left>Codis</th></tr></thead><tbody><tr><td style=text-align:left>Vertical Scaling</td><td style=text-align:left>Excellent</td><td style=text-align:left>Good</td><td style=text-align:left>Good</td></tr><tr><td style=text-align:left>Horizontal Scaling</td><td style=text-align:left>Limited (Redis Cluster)</td><td style=text-align:left>Limited</td><td style=text-align:left>Excellent</td></tr><tr><td style=text-align:left>Data Persistence</td><td style=text-align:left>Optional (RDB/AOF)</td><td style=text-align:left>Always On (RocksDB)</td><td style=text-align:left>Inherited from Redis</td></tr><tr><td style=text-align:left>High Availability</td><td style=text-align:left>Through Sentinel</td><td style=text-align:left>Master-Slave</td><td style=text-align:left>Built-in</td></tr><tr><td style=text-align:left>Automatic Failover</td><td style=text-align:left>Yes (with Sentinel)</td><td style=text-align:left>Manual</td><td style=text-align:left>Yes</td></tr><tr><td style=text-align:left>Online Scaling</td><td style=text-align:left>Limited</td><td style=text-align:left>Limited</td><td style=text-align:left>Yes</td></tr></tbody></table><h3 id=operational-complexity>Operational Complexity<a hidden class=anchor aria-hidden=true href=#operational-complexity>#</a></h3><ol><li><p><strong>Redis</strong>:</p><ul><li>Simple for single instance</li><li>Moderate complexity for Redis Cluster</li></ul></li><li><p><strong>Pika</strong>:</p><ul><li>Moderate complexity</li><li>Requires RocksDB tuning for optimal performance</li></ul></li><li><p><strong>Codis</strong>:</p><ul><li>Higher complexity</li><li>Requires management of multiple components</li></ul></li></ol><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Redis, Pika, and Codis each offer unique solutions to different data storage and caching challenges:</p><ul><li><strong>Redis</strong> excels in high-performance, in-memory operations and is ideal for scenarios where data fits in memory.</li><li><strong>Pika</strong> offers a good balance between performance and large dataset support, making it suitable for applications that need to persist data larger than available memory.</li><li><strong>Codis</strong> provides a scalable Redis cluster solution, ideal for large-scale deployments that require horizontal scaling and high availability.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/redis/>Redis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> 
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>