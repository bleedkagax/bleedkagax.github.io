<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis Interview | Kaga Blog</title>
<meta name=keywords content="Redis"><meta name=description content="What is Redis pipelining?
Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.
Explain Redis transactions.
Redis transactions allow the execution of a group of commands in a single step. Key properties:

All commands in a transaction are serialized and executed sequentially
Either all or none of the commands are processed
Redis transactions are atomic

How does Redis implement master-slave replication?
Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_redis_interview/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_redis_interview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis Interview"><meta property="og:description" content="What is Redis pipelining?
Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.
Explain Redis transactions.
Redis transactions allow the execution of a group of commands in a single step. Key properties:

All commands in a transaction are serialized and executed sequentially
Either all or none of the commands are processed
Redis transactions are atomic

How does Redis implement master-slave replication?
Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_redis_interview/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis Interview"><meta name=twitter:description content="What is Redis pipelining?
Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.
Explain Redis transactions.
Redis transactions allow the execution of a group of commands in a single step. Key properties:

All commands in a transaction are serialized and executed sequentially
Either all or none of the commands are processed
Redis transactions are atomic

How does Redis implement master-slave replication?
Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Redis Interview","item":"https://bleedkagax.github.io/post/0_redis_interview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis Interview","name":"Redis Interview","description":"What is Redis pipelining? Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.\nExplain Redis transactions. Redis transactions allow the execution of a group of commands in a single step. Key properties:\nAll commands in a transaction are serialized and executed sequentially Either all or none of the commands are processed Redis transactions are atomic How does Redis implement master-slave replication? Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure.\n","keywords":["Redis"],"articleBody":"What is Redis pipelining? Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.\nExplain Redis transactions. Redis transactions allow the execution of a group of commands in a single step. Key properties:\nAll commands in a transaction are serialized and executed sequentially Either all or none of the commands are processed Redis transactions are atomic How does Redis implement master-slave replication? Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure.\nWhat is Redis Sentinel? Redis Sentinel is a system designed to help manage Redis instances. It provides:\nMonitoring: Sentinel constantly checks if master and slave instances are working as expected Notification: Sentinel can notify the system administrator via an API, about the events happening in the Redis ecosystem Automatic failover: If a master is not working as expected, Sentinel can start a failover process where a slave is promoted to master Explain the concept of Redis Cluster. Redis Cluster is a distributed implementation of Redis with the following goals:\nHigh performance and linear scalability up to 1000 nodes No-single-point-of-failure Automatic split of dataset among multiple nodes Automatic rebalancing and migration of data when nodes are added or removed What is the purpose of Redis pub/sub? Redis Pub/Sub (Publish/Subscribe) is a messaging paradigm where senders (publishers) send messages to channels, without knowledge of what subscribers (if any) there may be. Subscribers express interest in one or more channels and only receive messages that are of interest, without knowledge of what publishers (if any) there are.\nCore Principles In-memory data storage: Redis keeps all data in RAM for fast access and manipulation. Single-threaded architecture: Ensures atomic operations without the need for complex locking mechanisms. Asynchronous operations: Allows for non-blocking I/O operations. Persistence options: Provides durability through snapshots and append-only files. Replication: Supports master-slave replication for high availability and data redundancy. Data Structures Strings: Binary-safe strings up to 512MB in size. Lists: Collections of string elements sorted by insertion order. Sets: Unordered collections of unique strings. Sorted Sets: Sets ordered by a score, allowing for range queries. Hashes: Maps between string fields and string values. Bitmaps: String data type with bit-level operations. HyperLogLogs: Probabilistic data structure for cardinality estimation. Geospatial indexes: Store and query geospatial data. Streams: Append-only log-like data structures. Single-Threaded Model Redis employs a single-threaded event loop model, which offers several advantages:\nSimplicity: No need for complex locking mechanisms. Atomic operations: Commands are executed sequentially without interruption. Predictable performance: Easier to reason about and optimize. Efficient memory usage: Avoids overhead of thread management. However, this model also has limitations:\nCPU-bound operations can block the entire server. Cannot fully utilize multi-core processors without running multiple Redis instances. Persistence RDB (Redis Database):\nPoint-in-time snapshots of the dataset. Compact single-file format. Perfect for backups and disaster recovery. Allows faster restarts with big datasets compared to AOF. AOF (Append-Only File):\nLogs every write operation received by the server. Higher durability (can be configured to fsync every second or on every query). Automatically rewrites in the background when the file gets too big. More durable than RDB in case of server crashes. Replication Redis supports master-slave replication, which allows slave Redis servers to be exact copies of master servers. Key features include:\nAsynchronous replication: Slaves acknowledge the amount of data processed from the master. Multiple slaves can be configured for a single master. Slaves can accept connections from other slaves, creating a cascading-like structure. Replication is non-blocking on the master side. Memory Optimization Use appropriate data structures:\nHashes for objects with few fields. Sorted sets for leaderboards or priority queues. Bitmaps for boolean data or counters for limited set of states. Implement key expiration policies:\nUse TTL (Time To Live) for volatile data. Implement LRU (Least Recently Used) eviction for caches. Enable compression for large objects:\nUse the compression configuration option for values above a certain size. Use Redis object sharing:\nEnable maxmemory-policy allkeys-lru to automatically evict least recently used keys. Monitor memory usage:\nUse the INFO memory command to get detailed memory usage statistics. Implement external monitoring tools to track memory usage over time. Optimize string usage:\nUse integer encoding for string values when possible. Avoid storing large strings; consider splitting them into smaller chunks. Use Redis Modules for specialized data structures:\nRedisBloom for probabilistic data structures. RedisTimeSeries for time series data. Performance Optimization Use pipelining for bulk operations:\nSend multiple commands in a single request to reduce network round trips. Implement connection pooling:\nReuse connections to avoid the overhead of creating new ones. Utilize Redis benchmarking tools:\nUse redis-benchmark to test performance under various scenarios. Implement custom benchmarks for specific use cases. Optimize network settings:\nIncrease the tcp-backlog value for high-concurrency scenarios. Tune kernel parameters like net.core.somaxconn and net.ipv4.tcp_max_syn_backlog. Use proper sharding techniques:\nImplement client-side sharding or use Redis Cluster for distributing data across multiple nodes. Optimize command usage:\nUse SCAN instead of KEYS for iterating over large key spaces. Use HMGET instead of multiple GET operations for retrieving multiple hash fields. Implement read-through and write-through caching:\nUse Redis as a cache in front of a slower data store. Utilize Redis Modules for specialized operations:\nRediSearch for full-text search capabilities. RedisGraph for graph-based queries. Persistence Optimization Tune RDB and AOF settings:\nAdjust the frequency of RDB snapshots based on your durability requirements. Configure AOF fsync policy (always, everysec, or no) based on performance needs. Use background saving for RDB snapshots:\nEnable rdb-save-incremental-fsync for smoother I/O operations during saves. Implement AOF rewrite thresholds:\nAdjust auto-aof-rewrite-percentage and auto-aof-rewrite-min-size for optimal AOF rewrites. Consider using both RDB and AOF:\nCombine the fast restarts of RDB with the durability of AOF. Use diskless replication:\nEnable repl-diskless-sync to send RDB files to slaves without using the disk. Optimize storage hardware:\nUse SSDs for better I/O performance. Consider using battery-backed RAID controllers for improved write performance. Replication Optimization Use asynchronous replication:\nConfigure an appropriate repl-backlog-size to handle temporary disconnections. Implement read-only replicas:\nDistribute read operations across multiple replicas to reduce load on the master. Configure appropriate timeout settings:\nAdjust repl-timeout and repl-ping-replica-period based on network conditions. Monitor replication lag:\nUse the INFO replication command to track replication offset and lag. Implement replica priority:\nSet replica-priority to control failover behavior in Redis Sentinel. Use PSYNC for efficient replication:\nEnsure partial resynchronization is possible after short disconnections. Implement a good topology:\nUse cascading replication for large numbers of replicas. Distributed Locks Acquire lock:\nSET resource_name my_random_value NX PX 30000 This sets the key if it doesn’t exist (NX) with an expiry of 30000 milliseconds (PX).\nPerform critical section operations.\nRelease lock using a Lua script:\nif redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end Pipelining Pipelining is a technique to send multiple commands to the server without waiting for individual replies, then reading all replies in a single step.\nBenefits:\nReduced network round trips. Increased throughput, especially for high-latency connections. Example using Python:\nimport redis r = redis.Redis(host='localhost', port=6379, db=0) pipe = r.pipeline() for i in range(10000): pipe.set(f'key:{i}', f'value:{i}') pipe.expire(f'key:{i}', 3600) pipe.execute() Best practices:\nGroup related commands in a single pipeline. Balance pipeline size with memory usage and network packet size. Use pipelining in combination with transactions for atomic operations. Transactions All commands in a transaction are serialized and executed sequentially. Either all commands or none are processed, ensuring atomicity. No rollback mechanism; if a command fails, others are still executed. WATCH command:\nProvides check-and-set (CAS) behavior. Allows for optimistic locking scenarios. Example with WATCH:\nWATCH account:1:balance VAL = GET account:1:balance MULTI SET account:1:balance EXEC Pub/Sub Messaging Key commands:\nSUBSCRIBE: Listen for messages on one or more channels. PUBLISH: Send a message to a channel. PSUBSCRIBE: Subscribe to channels matching a pattern. Example:\nSUBSCRIBE news:sports PUBLISH news:sports \"Lakers win the championship!\" Use cases:\nReal-time notifications Chat systems Distributed system event propagation Limitations:\nAt-most-once delivery semantics No persistence of messages Lua Scripting Redis allows executing Lua scripts for complex operations, offering several advantages:\nReduced network overhead for complex operations. Atomic execution of multiple commands. Ability to create new “commands” as Lua scripts. Example:\nredis.call('SET', KEYS[1], ARGV[1]) redis.call('EXPIRE', KEYS[1], ARGV[2]) return redis.call('GET', KEYS[1]) Execute with:\nEVAL \"redis.call('SET', KEYS[1], ARGV[1]); redis.call('EXPIRE', KEYS[1], ARGV[2]); return redis.call('GET', KEYS[1])\" 1 mykey \"Hello\" 10 Best practices:\nUse EVALSHA for better performance with frequently used scripts. Implement script load command to preload scripts. Be cautious with long-running scripts as they can block the Redis server. Redis Modules Redis modules extend Redis functionality with custom commands and data types. Popular modules include:\nRediSearch: Full-text search engine\nSupports complex queries and aggregations Provides real-time indexing RedisJSON: Native JSON support\nAllows storing, updating, and retrieving JSON values Supports JSONPath-like syntax for querying RedisTimeSeries: Time series database\nEfficient storage and retrieval of time series data Supports downsampling and aggregation RedisAI: Machine learning model serving\nSupports TensorFlow, PyTorch, and ONNX models Enables real-time inferencing RedisGraph: Graph database module\nImplements property graph model Supports Cypher query language Redis Cluster Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.\nKey features:\nAutomatic partitioning: Uses hash slots for distributing keys. High availability: Supports master-slave replication with automatic failover. Linear scalability: Add or remove nodes without downtime. Cluster topology:\nMinimum of 3 master nodes recommended. Each master can have multiple replicas. Client-side sharding:\nClients must be cluster-aware to route requests to the correct node. Libraries like redis-py-cluster handle this transparently. Redis Sentinel Redis Sentinel provides high availability for Redis through automatic failover and monitoring.\nKey features:\nMonitoring: Constantly checks if master and slave instances are working as expected. Notification: Can notify system administrators or other programs about events. Automatic failover: Promotes a slave to master when the master fails. Configuration provider: Clients connect to Sentinels to ask for the address of the current master. Sentinel topology:\nRecommended to run at least 3 Sentinel instances for robust deployments. Sentinel instances should be placed on separate machines or virtual machines. Redis Streams Redis Streams is a log-like data structure that allows for efficient message queuing and real-time data processing.\nKey operations:\nXADD: Add new entries to a stream. XREAD: Read data from streams. XRANGE: Retrieve a range of entries from a stream. XGROUP: Manage consumer groups for parallel processing. Use cases:\nEvent sourcing Activity feeds Real-time analytics Example:\nXADD mystream * sensor-id 1234 temperature 19.8 XREAD COUNT 2 STREAMS mystream 0-0 Geospatial Indexing Redis supports geospatial operations for location-based services.\nKey commands:\nGEOADD: Add geospatial items to a sorted set. GEORADIUS: Query items within a given radius. GEODIST: Calculate distance between points. Example:\nGEOADD cities 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\" GEORADIUS cities 15 37 100 km Use cases:\nNearby point-of-interest search Geofencing applications Location-based analytics Redis Monitoring and Debugging Use Redis INFO command for real-time statistics:\nMonitor memory usage, client connections, and command statistics. Implement monitoring tools:\nUse Redis Exporter for Prometheus integration. Set up Grafana dashboards for visualization. Utilize Redis Slowlog:\nIdentify and optimize slow commands. Adjust slowlog-log-slower-than and slowlog-max-len configurations. Use Redis MONITOR command for real-time command monitoring:\nUseful for debugging, but use cautiously in production due to performance impact. Implement proper logging and alerting mechanisms:\nSet up alerts for critical metrics (e.g., memory usage, replication lag). Use log aggregation tools for centralized logging. Use Redis MEMORY DOCTOR for memory analysis:\nIdentify memory-related issues and optimization opportunities. Implement distributed tracing:\nUse tools like Jaeger or Zipkin for tracing Redis operations in microservices architectures. Utilize Redis Latency Monitoring:\nUse the LATENCY command to identify sources of latency. Implement Redis Sentinel monitoring:\nMonitor master-slave relationships and failover events. Use Redis Cluster monitoring tools:\nMonitor cluster state, resharding operations, and node health. Implement application-level monitoring: Track cache hit rates, key distribution, and access patterns. Use Redis profiling tools: Leverage tools like redis-cli –latency or redis-cli –stat for performance insights. ","wordCount":"1994","inLanguage":"en","datePublished":"2024-09-01T00:00:00Z","dateModified":"2024-09-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_redis_interview/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redis Interview</h1><div class=post-meta><span title='2024-09-01 00:00:00 +0000 UTC'>September 1, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-redis-pipelining aria-label="What is Redis pipelining?">What is Redis pipelining?</a></li><li><a href=#explain-redis-transactions aria-label="Explain Redis transactions.">Explain Redis transactions.</a></li><li><a href=#how-does-redis-implement-master-slave-replication aria-label="How does Redis implement master-slave replication?">How does Redis implement master-slave replication?</a></li><li><a href=#what-is-redis-sentinel aria-label="What is Redis Sentinel?">What is Redis Sentinel?</a></li><li><a href=#explain-the-concept-of-redis-cluster aria-label="Explain the concept of Redis Cluster.">Explain the concept of Redis Cluster.</a></li><li><a href=#what-is-the-purpose-of-redis-pubsub aria-label="What is the purpose of Redis pub/sub?">What is the purpose of Redis pub/sub?</a></li><li><a href=#core-principles aria-label="Core Principles">Core Principles</a></li><li><a href=#data-structures aria-label="Data Structures">Data Structures</a></li><li><a href=#single-threaded-model aria-label="Single-Threaded Model">Single-Threaded Model</a></li><li><a href=#persistence aria-label=Persistence>Persistence</a></li><li><a href=#replication aria-label=Replication>Replication</a></li><li><a href=#memory-optimization aria-label="Memory Optimization">Memory Optimization</a></li><li><a href=#performance-optimization aria-label="Performance Optimization">Performance Optimization</a></li><li><a href=#persistence-optimization aria-label="Persistence Optimization">Persistence Optimization</a></li><li><a href=#replication-optimization aria-label="Replication Optimization">Replication Optimization</a></li><li><a href=#distributed-locks aria-label="Distributed Locks">Distributed Locks</a></li><li><a href=#pipelining aria-label=Pipelining>Pipelining</a></li><li><a href=#transactions aria-label=Transactions>Transactions</a></li><li><a href=#pubsub-messaging aria-label="Pub/Sub Messaging">Pub/Sub Messaging</a></li><li><a href=#lua-scripting aria-label="Lua Scripting">Lua Scripting</a></li><li><a href=#redis-modules aria-label="Redis Modules">Redis Modules</a></li><li><a href=#redis-cluster aria-label="Redis Cluster">Redis Cluster</a></li><li><a href=#redis-sentinel aria-label="Redis Sentinel">Redis Sentinel</a></li><li><a href=#redis-streams aria-label="Redis Streams">Redis Streams</a></li><li><a href=#geospatial-indexing aria-label="Geospatial Indexing">Geospatial Indexing</a></li><li><a href=#redis-monitoring-and-debugging aria-label="Redis Monitoring and Debugging">Redis Monitoring and Debugging</a></li></ul></div></details></div><div class=post-content><h2 id=what-is-redis-pipelining>What is Redis pipelining?<a hidden class=anchor aria-hidden=true href=#what-is-redis-pipelining>#</a></h2><p>Pipelining is a technique used to send multiple commands to the server without waiting for the replies, and then reading the replies in a single step.</p><h2 id=explain-redis-transactions>Explain Redis transactions.<a hidden class=anchor aria-hidden=true href=#explain-redis-transactions>#</a></h2><p>Redis transactions allow the execution of a group of commands in a single step. Key properties:</p><ul><li>All commands in a transaction are serialized and executed sequentially</li><li>Either all or none of the commands are processed</li><li>Redis transactions are atomic</li></ul><h2 id=how-does-redis-implement-master-slave-replication>How does Redis implement master-slave replication?<a hidden class=anchor aria-hidden=true href=#how-does-redis-implement-master-slave-replication>#</a></h2><p>Redis uses asynchronous replication, where a master can have multiple slaves. The replication is non-blocking on the master side, so the master can continue serving queries while slaves are synchronizing. Slaves can also be configured to accept connections from other slaves, creating a graph-like structure.</p><h2 id=what-is-redis-sentinel>What is Redis Sentinel?<a hidden class=anchor aria-hidden=true href=#what-is-redis-sentinel>#</a></h2><p>Redis Sentinel is a system designed to help manage Redis instances. It provides:</p><ul><li>Monitoring: Sentinel constantly checks if master and slave instances are working as expected</li><li>Notification: Sentinel can notify the system administrator via an API, about the events happening in the Redis ecosystem</li><li>Automatic failover: If a master is not working as expected, Sentinel can start a failover process where a slave is promoted to master</li></ul><h2 id=explain-the-concept-of-redis-cluster>Explain the concept of Redis Cluster.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-redis-cluster>#</a></h2><p>Redis Cluster is a distributed implementation of Redis with the following goals:</p><ul><li>High performance and linear scalability up to 1000 nodes</li><li>No-single-point-of-failure</li><li>Automatic split of dataset among multiple nodes</li><li>Automatic rebalancing and migration of data when nodes are added or removed</li></ul><h2 id=what-is-the-purpose-of-redis-pubsub>What is the purpose of Redis pub/sub?<a hidden class=anchor aria-hidden=true href=#what-is-the-purpose-of-redis-pubsub>#</a></h2><p>Redis Pub/Sub (Publish/Subscribe) is a messaging paradigm where senders (publishers) send messages to channels, without knowledge of what subscribers (if any) there may be. Subscribers express interest in one or more channels and only receive messages that are of interest, without knowledge of what publishers (if any) there are.</p><h2 id=core-principles>Core Principles<a hidden class=anchor aria-hidden=true href=#core-principles>#</a></h2><ol><li>In-memory data storage: Redis keeps all data in RAM for fast access and manipulation.</li><li>Single-threaded architecture: Ensures atomic operations without the need for complex locking mechanisms.</li><li>Asynchronous operations: Allows for non-blocking I/O operations.</li><li>Persistence options: Provides durability through snapshots and append-only files.</li><li>Replication: Supports master-slave replication for high availability and data redundancy.</li></ol><h2 id=data-structures>Data Structures<a hidden class=anchor aria-hidden=true href=#data-structures>#</a></h2><ol><li>Strings: Binary-safe strings up to 512MB in size.</li><li>Lists: Collections of string elements sorted by insertion order.</li><li>Sets: Unordered collections of unique strings.</li><li>Sorted Sets: Sets ordered by a score, allowing for range queries.</li><li>Hashes: Maps between string fields and string values.</li><li>Bitmaps: String data type with bit-level operations.</li><li>HyperLogLogs: Probabilistic data structure for cardinality estimation.</li><li>Geospatial indexes: Store and query geospatial data.</li><li>Streams: Append-only log-like data structures.</li></ol><h2 id=single-threaded-model>Single-Threaded Model<a hidden class=anchor aria-hidden=true href=#single-threaded-model>#</a></h2><p>Redis employs a single-threaded event loop model, which offers several advantages:</p><ol><li>Simplicity: No need for complex locking mechanisms.</li><li>Atomic operations: Commands are executed sequentially without interruption.</li><li>Predictable performance: Easier to reason about and optimize.</li><li>Efficient memory usage: Avoids overhead of thread management.</li></ol><p>However, this model also has limitations:</p><ol><li>CPU-bound operations can block the entire server.</li><li>Cannot fully utilize multi-core processors without running multiple Redis instances.</li></ol><h2 id=persistence>Persistence<a hidden class=anchor aria-hidden=true href=#persistence>#</a></h2><ol><li><p>RDB (Redis Database):</p><ul><li>Point-in-time snapshots of the dataset.</li><li>Compact single-file format.</li><li>Perfect for backups and disaster recovery.</li><li>Allows faster restarts with big datasets compared to AOF.</li></ul></li><li><p>AOF (Append-Only File):</p><ul><li>Logs every write operation received by the server.</li><li>Higher durability (can be configured to fsync every second or on every query).</li><li>Automatically rewrites in the background when the file gets too big.</li><li>More durable than RDB in case of server crashes.</li></ul></li></ol><h2 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h2><p>Redis supports master-slave replication, which allows slave Redis servers to be exact copies of master servers. Key features include:</p><ol><li>Asynchronous replication: Slaves acknowledge the amount of data processed from the master.</li><li>Multiple slaves can be configured for a single master.</li><li>Slaves can accept connections from other slaves, creating a cascading-like structure.</li><li>Replication is non-blocking on the master side.</li></ol><h2 id=memory-optimization>Memory Optimization<a hidden class=anchor aria-hidden=true href=#memory-optimization>#</a></h2><ol><li><p>Use appropriate data structures:</p><ul><li>Hashes for objects with few fields.</li><li>Sorted sets for leaderboards or priority queues.</li><li>Bitmaps for boolean data or counters for limited set of states.</li></ul></li><li><p>Implement key expiration policies:</p><ul><li>Use TTL (Time To Live) for volatile data.</li><li>Implement LRU (Least Recently Used) eviction for caches.</li></ul></li><li><p>Enable compression for large objects:</p><ul><li>Use the <code>compression</code> configuration option for values above a certain size.</li></ul></li><li><p>Use Redis object sharing:</p><ul><li>Enable <code>maxmemory-policy allkeys-lru</code> to automatically evict least recently used keys.</li></ul></li><li><p>Monitor memory usage:</p><ul><li>Use the <code>INFO memory</code> command to get detailed memory usage statistics.</li><li>Implement external monitoring tools to track memory usage over time.</li></ul></li><li><p>Optimize string usage:</p><ul><li>Use integer encoding for string values when possible.</li><li>Avoid storing large strings; consider splitting them into smaller chunks.</li></ul></li><li><p>Use Redis Modules for specialized data structures:</p><ul><li>RedisBloom for probabilistic data structures.</li><li>RedisTimeSeries for time series data.</li></ul></li></ol><h2 id=performance-optimization>Performance Optimization<a hidden class=anchor aria-hidden=true href=#performance-optimization>#</a></h2><ol><li><p>Use pipelining for bulk operations:</p><ul><li>Send multiple commands in a single request to reduce network round trips.</li></ul></li><li><p>Implement connection pooling:</p><ul><li>Reuse connections to avoid the overhead of creating new ones.</li></ul></li><li><p>Utilize Redis benchmarking tools:</p><ul><li>Use redis-benchmark to test performance under various scenarios.</li><li>Implement custom benchmarks for specific use cases.</li></ul></li><li><p>Optimize network settings:</p><ul><li>Increase the <code>tcp-backlog</code> value for high-concurrency scenarios.</li><li>Tune kernel parameters like <code>net.core.somaxconn</code> and <code>net.ipv4.tcp_max_syn_backlog</code>.</li></ul></li><li><p>Use proper sharding techniques:</p><ul><li>Implement client-side sharding or use Redis Cluster for distributing data across multiple nodes.</li></ul></li><li><p>Optimize command usage:</p><ul><li>Use SCAN instead of KEYS for iterating over large key spaces.</li><li>Use HMGET instead of multiple GET operations for retrieving multiple hash fields.</li></ul></li><li><p>Implement read-through and write-through caching:</p><ul><li>Use Redis as a cache in front of a slower data store.</li></ul></li><li><p>Utilize Redis Modules for specialized operations:</p><ul><li>RediSearch for full-text search capabilities.</li><li>RedisGraph for graph-based queries.</li></ul></li></ol><h2 id=persistence-optimization>Persistence Optimization<a hidden class=anchor aria-hidden=true href=#persistence-optimization>#</a></h2><ol><li><p>Tune RDB and AOF settings:</p><ul><li>Adjust the frequency of RDB snapshots based on your durability requirements.</li><li>Configure AOF fsync policy (always, everysec, or no) based on performance needs.</li></ul></li><li><p>Use background saving for RDB snapshots:</p><ul><li>Enable <code>rdb-save-incremental-fsync</code> for smoother I/O operations during saves.</li></ul></li><li><p>Implement AOF rewrite thresholds:</p><ul><li>Adjust <code>auto-aof-rewrite-percentage</code> and <code>auto-aof-rewrite-min-size</code> for optimal AOF rewrites.</li></ul></li><li><p>Consider using both RDB and AOF:</p><ul><li>Combine the fast restarts of RDB with the durability of AOF.</li></ul></li><li><p>Use diskless replication:</p><ul><li>Enable <code>repl-diskless-sync</code> to send RDB files to slaves without using the disk.</li></ul></li><li><p>Optimize storage hardware:</p><ul><li>Use SSDs for better I/O performance.</li><li>Consider using battery-backed RAID controllers for improved write performance.</li></ul></li></ol><h2 id=replication-optimization>Replication Optimization<a hidden class=anchor aria-hidden=true href=#replication-optimization>#</a></h2><ol><li><p>Use asynchronous replication:</p><ul><li>Configure an appropriate <code>repl-backlog-size</code> to handle temporary disconnections.</li></ul></li><li><p>Implement read-only replicas:</p><ul><li>Distribute read operations across multiple replicas to reduce load on the master.</li></ul></li><li><p>Configure appropriate timeout settings:</p><ul><li>Adjust <code>repl-timeout</code> and <code>repl-ping-replica-period</code> based on network conditions.</li></ul></li><li><p>Monitor replication lag:</p><ul><li>Use the <code>INFO replication</code> command to track replication offset and lag.</li></ul></li><li><p>Implement replica priority:</p><ul><li>Set <code>replica-priority</code> to control failover behavior in Redis Sentinel.</li></ul></li><li><p>Use PSYNC for efficient replication:</p><ul><li>Ensure partial resynchronization is possible after short disconnections.</li></ul></li><li><p>Implement a good topology:</p><ul><li>Use cascading replication for large numbers of replicas.</li></ul></li></ol><h2 id=distributed-locks>Distributed Locks<a hidden class=anchor aria-hidden=true href=#distributed-locks>#</a></h2><ol><li><p>Acquire lock:</p><pre tabindex=0><code>SET resource_name my_random_value NX PX 30000
</code></pre><p>This sets the key if it doesn&rsquo;t exist (NX) with an expiry of 30000 milliseconds (PX).</p></li><li><p>Perform critical section operations.</p></li><li><p>Release lock using a Lua script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>if</span> redis.call(<span style=color:#e6db74>&#34;get&#34;</span>,KEYS[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>==</span> ARGV[<span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> redis.call(<span style=color:#e6db74>&#34;del&#34;</span>,KEYS[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div></li></ol><h2 id=pipelining>Pipelining<a hidden class=anchor aria-hidden=true href=#pipelining>#</a></h2><p>Pipelining is a technique to send multiple commands to the server without waiting for individual replies, then reading all replies in a single step.</p><p>Benefits:</p><ul><li>Reduced network round trips.</li><li>Increased throughput, especially for high-latency connections.</li></ul><p>Example using Python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> redis
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>r <span style=color:#f92672>=</span> redis<span style=color:#f92672>.</span>Redis(host<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;localhost&#39;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>6379</span>, db<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>pipe <span style=color:#f92672>=</span> r<span style=color:#f92672>.</span>pipeline()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10000</span>):
</span></span><span style=display:flex><span>    pipe<span style=color:#f92672>.</span>set(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;key:</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>, <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;value:</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    pipe<span style=color:#f92672>.</span>expire(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;key:</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>, <span style=color:#ae81ff>3600</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pipe<span style=color:#f92672>.</span>execute()
</span></span></code></pre></div><p>Best practices:</p><ul><li>Group related commands in a single pipeline.</li><li>Balance pipeline size with memory usage and network packet size.</li><li>Use pipelining in combination with transactions for atomic operations.</li></ul><h2 id=transactions>Transactions<a hidden class=anchor aria-hidden=true href=#transactions>#</a></h2><ul><li>All commands in a transaction are serialized and executed sequentially.</li><li>Either all commands or none are processed, ensuring atomicity.</li><li>No rollback mechanism; if a command fails, others are still executed.</li></ul><p>WATCH command:</p><ul><li>Provides check-and-set (CAS) behavior.</li><li>Allows for optimistic locking scenarios.</li></ul><p>Example with WATCH:</p><pre tabindex=0><code>WATCH account:1:balance
VAL = GET account:1:balance
MULTI
SET account:1:balance &lt;new-value&gt;
EXEC
</code></pre><h2 id=pubsub-messaging>Pub/Sub Messaging<a hidden class=anchor aria-hidden=true href=#pubsub-messaging>#</a></h2><p>Key commands:</p><ul><li>SUBSCRIBE: Listen for messages on one or more channels.</li><li>PUBLISH: Send a message to a channel.</li><li>PSUBSCRIBE: Subscribe to channels matching a pattern.</li></ul><p>Example:</p><pre tabindex=0><code>SUBSCRIBE news:sports
PUBLISH news:sports &#34;Lakers win the championship!&#34;
</code></pre><p>Use cases:</p><ul><li>Real-time notifications</li><li>Chat systems</li><li>Distributed system event propagation</li></ul><p>Limitations:</p><ul><li>At-most-once delivery semantics</li><li>No persistence of messages</li></ul><h2 id=lua-scripting>Lua Scripting<a hidden class=anchor aria-hidden=true href=#lua-scripting>#</a></h2><p>Redis allows executing Lua scripts for complex operations, offering several advantages:</p><ol><li>Reduced network overhead for complex operations.</li><li>Atomic execution of multiple commands.</li><li>Ability to create new &ldquo;commands&rdquo; as Lua scripts.</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>redis.call(<span style=color:#e6db74>&#39;SET&#39;</span>, KEYS[<span style=color:#ae81ff>1</span>], ARGV[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>redis.call(<span style=color:#e6db74>&#39;EXPIRE&#39;</span>, KEYS[<span style=color:#ae81ff>1</span>], ARGV[<span style=color:#ae81ff>2</span>])
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> redis.call(<span style=color:#e6db74>&#39;GET&#39;</span>, KEYS[<span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><p>Execute with:</p><pre tabindex=0><code>EVAL &#34;redis.call(&#39;SET&#39;, KEYS[1], ARGV[1]); redis.call(&#39;EXPIRE&#39;, KEYS[1], ARGV[2]); return redis.call(&#39;GET&#39;, KEYS[1])&#34; 1 mykey &#34;Hello&#34; 10
</code></pre><p>Best practices:</p><ul><li>Use EVALSHA for better performance with frequently used scripts.</li><li>Implement script load command to preload scripts.</li><li>Be cautious with long-running scripts as they can block the Redis server.</li></ul><h2 id=redis-modules>Redis Modules<a hidden class=anchor aria-hidden=true href=#redis-modules>#</a></h2><p>Redis modules extend Redis functionality with custom commands and data types. Popular modules include:</p><ol><li><p>RediSearch: Full-text search engine</p><ul><li>Supports complex queries and aggregations</li><li>Provides real-time indexing</li></ul></li><li><p>RedisJSON: Native JSON support</p><ul><li>Allows storing, updating, and retrieving JSON values</li><li>Supports JSONPath-like syntax for querying</li></ul></li><li><p>RedisTimeSeries: Time series database</p><ul><li>Efficient storage and retrieval of time series data</li><li>Supports downsampling and aggregation</li></ul></li><li><p>RedisAI: Machine learning model serving</p><ul><li>Supports TensorFlow, PyTorch, and ONNX models</li><li>Enables real-time inferencing</li></ul></li><li><p>RedisGraph: Graph database module</p><ul><li>Implements property graph model</li><li>Supports Cypher query language</li></ul></li></ol><h2 id=redis-cluster>Redis Cluster<a hidden class=anchor aria-hidden=true href=#redis-cluster>#</a></h2><p>Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.</p><p>Key features:</p><ol><li>Automatic partitioning: Uses hash slots for distributing keys.</li><li>High availability: Supports master-slave replication with automatic failover.</li><li>Linear scalability: Add or remove nodes without downtime.</li></ol><p>Cluster topology:</p><ul><li>Minimum of 3 master nodes recommended.</li><li>Each master can have multiple replicas.</li></ul><p>Client-side sharding:</p><ul><li>Clients must be cluster-aware to route requests to the correct node.</li><li>Libraries like redis-py-cluster handle this transparently.</li></ul><h2 id=redis-sentinel>Redis Sentinel<a hidden class=anchor aria-hidden=true href=#redis-sentinel>#</a></h2><p>Redis Sentinel provides high availability for Redis through automatic failover and monitoring.</p><p>Key features:</p><ol><li>Monitoring: Constantly checks if master and slave instances are working as expected.</li><li>Notification: Can notify system administrators or other programs about events.</li><li>Automatic failover: Promotes a slave to master when the master fails.</li><li>Configuration provider: Clients connect to Sentinels to ask for the address of the current master.</li></ol><p>Sentinel topology:</p><ul><li>Recommended to run at least 3 Sentinel instances for robust deployments.</li><li>Sentinel instances should be placed on separate machines or virtual machines.</li></ul><h2 id=redis-streams>Redis Streams<a hidden class=anchor aria-hidden=true href=#redis-streams>#</a></h2><p>Redis Streams is a log-like data structure that allows for efficient message queuing and real-time data processing.</p><p>Key operations:</p><ul><li>XADD: Add new entries to a stream.</li><li>XREAD: Read data from streams.</li><li>XRANGE: Retrieve a range of entries from a stream.</li><li>XGROUP: Manage consumer groups for parallel processing.</li></ul><p>Use cases:</p><ul><li>Event sourcing</li><li>Activity feeds</li><li>Real-time analytics</li></ul><p>Example:</p><pre tabindex=0><code>XADD mystream * sensor-id 1234 temperature 19.8
XREAD COUNT 2 STREAMS mystream 0-0
</code></pre><h2 id=geospatial-indexing>Geospatial Indexing<a hidden class=anchor aria-hidden=true href=#geospatial-indexing>#</a></h2><p>Redis supports geospatial operations for location-based services.</p><p>Key commands:</p><ul><li>GEOADD: Add geospatial items to a sorted set.</li><li>GEORADIUS: Query items within a given radius.</li><li>GEODIST: Calculate distance between points.</li></ul><p>Example:</p><pre tabindex=0><code>GEOADD cities 13.361389 38.115556 &#34;Palermo&#34; 15.087269 37.502669 &#34;Catania&#34;
GEORADIUS cities 15 37 100 km
</code></pre><p>Use cases:</p><ul><li>Nearby point-of-interest search</li><li>Geofencing applications</li><li>Location-based analytics</li></ul><h2 id=redis-monitoring-and-debugging>Redis Monitoring and Debugging<a hidden class=anchor aria-hidden=true href=#redis-monitoring-and-debugging>#</a></h2><ol><li><p>Use Redis INFO command for real-time statistics:</p><ul><li>Monitor memory usage, client connections, and command statistics.</li></ul></li><li><p>Implement monitoring tools:</p><ul><li>Use Redis Exporter for Prometheus integration.</li><li>Set up Grafana dashboards for visualization.</li></ul></li><li><p>Utilize Redis Slowlog:</p><ul><li>Identify and optimize slow commands.</li><li>Adjust <code>slowlog-log-slower-than</code> and <code>slowlog-max-len</code> configurations.</li></ul></li><li><p>Use Redis MONITOR command for real-time command monitoring:</p><ul><li>Useful for debugging, but use cautiously in production due to performance impact.</li></ul></li><li><p>Implement proper logging and alerting mechanisms:</p><ul><li>Set up alerts for critical metrics (e.g., memory usage, replication lag).</li><li>Use log aggregation tools for centralized logging.</li></ul></li><li><p>Use Redis MEMORY DOCTOR for memory analysis:</p><ul><li>Identify memory-related issues and optimization opportunities.</li></ul></li><li><p>Implement distributed tracing:</p><ul><li>Use tools like Jaeger or Zipkin for tracing Redis operations in microservices architectures.</li></ul></li><li><p>Utilize Redis Latency Monitoring:</p><ul><li>Use the LATENCY command to identify sources of latency.</li></ul></li><li><p>Implement Redis Sentinel monitoring:</p><ul><li>Monitor master-slave relationships and failover events.</li></ul></li><li><p>Use Redis Cluster monitoring tools:</p></li></ol><ul><li>Monitor cluster state, resharding operations, and node health.</li></ul><ol start=11><li>Implement application-level monitoring:</li></ol><ul><li>Track cache hit rates, key distribution, and access patterns.</li></ul><ol start=12><li>Use Redis profiling tools:</li></ol><ul><li>Leverage tools like redis-cli &ndash;latency or redis-cli &ndash;stat for performance insights.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/redis/>Redis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>