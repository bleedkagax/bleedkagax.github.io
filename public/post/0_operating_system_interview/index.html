<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operating System Interview | Kaga Blog</title>
<meta name=keywords content="OperatingSystem"><meta name=description content="Explain the difference between a process and a thread.


Process:

Independent execution unit
Has its own memory space
Heavyweight, more resources
Isolated from other processes



Thread:

Lightweight unit of execution within a process
Shares memory space with other threads in the same process
Less resource-intensive
Can communicate easily with other threads in the same process



How do processes and threads communicate
Process communication methods:"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_operating_system_interview/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_operating_system_interview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Operating System Interview"><meta property="og:description" content="Explain the difference between a process and a thread.


Process:

Independent execution unit
Has its own memory space
Heavyweight, more resources
Isolated from other processes



Thread:

Lightweight unit of execution within a process
Shares memory space with other threads in the same process
Less resource-intensive
Can communicate easily with other threads in the same process



How do processes and threads communicate
Process communication methods:"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_operating_system_interview/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-04T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Operating System Interview"><meta name=twitter:description content="Explain the difference between a process and a thread.


Process:

Independent execution unit
Has its own memory space
Heavyweight, more resources
Isolated from other processes



Thread:

Lightweight unit of execution within a process
Shares memory space with other threads in the same process
Less resource-intensive
Can communicate easily with other threads in the same process



How do processes and threads communicate
Process communication methods:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Operating System Interview","item":"https://bleedkagax.github.io/post/0_operating_system_interview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Operating System Interview","name":"Operating System Interview","description":"Explain the difference between a process and a thread. Process:\nIndependent execution unit Has its own memory space Heavyweight, more resources Isolated from other processes Thread:\nLightweight unit of execution within a process Shares memory space with other threads in the same process Less resource-intensive Can communicate easily with other threads in the same process How do processes and threads communicate Process communication methods:\n","keywords":["OperatingSystem"],"articleBody":"Explain the difference between a process and a thread. Process:\nIndependent execution unit Has its own memory space Heavyweight, more resources Isolated from other processes Thread:\nLightweight unit of execution within a process Shares memory space with other threads in the same process Less resource-intensive Can communicate easily with other threads in the same process How do processes and threads communicate Process communication methods:\nPipes and named pipes Shared memory Message queues Sockets Signals Thread communication methods:\nShared memory within the same process Mutex and semaphores for synchronization Condition variables Explain the concept of deadlock and its four necessary conditions. Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting to acquire a resource held by another process.\nFour necessary conditions (Coffman conditions):\nMutual Exclusion: At least one resource must be held in a non-sharable mode Hold and Wait: A process must be holding at least one resource while waiting to acquire additional resources held by other processes No Preemption: Resources cannot be forcibly taken away from a process; they must be released voluntarily Circular Wait: A circular chain of two or more processes, each waiting for a resource held by the next member in the chain What is the purpose of paging in an operating system? Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. It allows the physical address space of a process to be non-contiguous.\nBenefits:\nEfficient use of memory Supports virtual memory Simplifies memory allocation Paging Overview\n[Logical Address Space] [Page Table] [Physical Address Space] +------------------+ +----------+ +------------------+ | Page 0 | -----\u003e | Frame 2 | --\u003e | Frame 0 | +------------------+ +----------+ +------------------+ | Page 1 | -----\u003e | Frame 4 | --\u003e | Frame 1 | +------------------+ +----------+ +------------------+ | Page 2 | -----\u003e | Frame 1 | --\u003e | Frame 2 | +------------------+ +----------+ +------------------+ | Page 3 | -----\u003e | Frame 7 | --\u003e | Frame 3 | +------------------+ +----------+ +------------------+ | Frame 4 | +------------------+ | Frame 5 | +------------------+ | Frame 6 | +------------------+ | Frame 7 | +------------------+ Logical pages are mapped to physical frames through a page table. Note that pages can be stored in non-contiguous frames.\nAddress Translation\n[Logical Address] +----------------+----------------+ | Page No. | Offset | +----------------+----------------+ | | | | V | [Page Table] | +----------------+ | | Frame Number | | +----------------+ | | | | | V V +----------------+----------------+ | Frame Number | Offset | +----------------+----------------+ [Physical Address] Virtual Memory with Paging\n[Virtual Address Space] [Physical Memory] [Disk Storage] +------------------+ +---------------+ +-------------+ | Page 0 | ---\u003e | Frame 0 | | Page 3 | +------------------+ +---------------+ +-------------+ | Page 1 | ---\u003e | Frame 2 | | Page 5 | +------------------+ +---------------+ +-------------+ | Page 2 | ---\u003e | Frame 1 | | Page 6 | +------------------+ +---------------+ +-------------+ | Page 3 | --. | Frame 3 | | ... | +------------------+ | +---------------+ +-------------+ | Page 4 | ---\u003e | Frame 4 | +------------------+ +---------------+ | Page 5 | --. +------------------+ | | Page 6 | --. +------------------+ Paging supports virtual memory. Some pages are in physical memory, while others are stored on disk and can be swapped in when needed.\nExplain the difference between preemptive and non-preemptive scheduling. Preemptive Scheduling:\nThe CPU can be taken away from a process before it finishes its burst time Better for time-sharing systems Can lead to race conditions if not properly managed Non-preemptive Scheduling:\nOnce the CPU has been allocated to a process, the process keeps it until it releases the CPU either by terminating or by switching to the waiting state Simpler to implement Can lead to poor response time for interactive processes What is a system call? A system call is the programmatic way in which a computer program requests a service from the kernel of the operating system. System calls provide an essential interface between a process and the operating system.\nExamples of system calls:\nFile operations (open, read, write, close) Process control (fork, exec, exit) Device management Information maintenance Communication Explain the concept of thrashing. Thrashing is a condition where excessive paging operations are taking place. It occurs when a computer’s virtual memory subsystem is in a constant state of paging, rapidly exchanging data in memory for data on disk, to the exclusion of most application-level processing.\nCauses:\nInsufficient physical memory Poor page replacement algorithms Large working sets What is the purpose of a semaphore? A semaphore is a variable or abstract data type used to control access to a common resource by multiple processes in a concurrent system. It’s used for process synchronization and to solve critical section problems.\nTypes:\nBinary Semaphore (mutex): Can have only 0 or 1 as value Counting Semaphore: Can have any non-negative value What is memory fragmentation, how does it occur, and how is it solved? Memory fragmentation refers to the condition where memory space is broken into small, unusable blocks, reducing overall memory utilization efficiency.\nHow it occurs:\nExternal fragmentation: Frequent allocation and deallocation of memory blocks leaves small, unusable gaps between allocated blocks Internal fragmentation: Fixed-size memory allocation schemes may allocate more memory than required, leaving unused space within allocated blocks Solutions:\nCompaction: Relocating allocated memory blocks to create larger contiguous free spaces Paging: Dividing memory into fixed-size pages, eliminating external fragmentation Memory pools: Pre-allocating fixed-size memory blocks for specific uses Garbage collection: Automatically freeing unused memory and reorganizing remaining objects What are virtual memory and physical memory in operating systems? Virtual memory is an abstraction of physical memory that provides each process with the illusion of having its own large, contiguous address space.\nPhysical memory refers to the actual RAM(Random-access memory) installed in a computer.\nKey points:\nVirtual memory allows programs to use more memory than physically available It maps virtual addresses to physical addresses or disk storage Enables memory protection between processes Simplifies memory management for programmers Explain kernel mode and user mode in operating systems Kernel mode and user mode are privilege levels in which code executes:\nKernel mode:\nHas unrestricted access to hardware and system resources Can execute privileged instructions Used by the operating system kernel and device drivers User mode:\nHas limited access to system resources Cannot execute privileged instructions directly Used by application programs Switching between modes:\nSystem calls trigger a switch from user mode to kernel mode Return from system calls switches back to user mode ","wordCount":"1079","inLanguage":"en","datePublished":"2024-10-04T00:00:00Z","dateModified":"2024-10-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_operating_system_interview/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Operating System Interview</h1><div class=post-meta><span title='2024-10-04 00:00:00 +0000 UTC'>October 4, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#explain-the-difference-between-a-process-and-a-thread aria-label="Explain the difference between a process and a thread.">Explain the difference between a process and a thread.</a></li><li><a href=#how-do-processes-and-threads-communicate aria-label="How do processes and threads communicate">How do processes and threads communicate</a></li><li><a href=#explain-the-concept-of-deadlock-and-its-four-necessary-conditions aria-label="Explain the concept of deadlock and its four necessary conditions.">Explain the concept of deadlock and its four necessary conditions.</a></li><li><a href=#what-is-the-purpose-of-paging-in-an-operating-system aria-label="What is the purpose of paging in an operating system?">What is the purpose of paging in an operating system?</a></li><li><a href=#explain-the-difference-between-preemptive-and-non-preemptive-scheduling aria-label="Explain the difference between preemptive and non-preemptive scheduling.">Explain the difference between preemptive and non-preemptive scheduling.</a></li><li><a href=#what-is-a-system-call aria-label="What is a system call?">What is a system call?</a></li><li><a href=#explain-the-concept-of-thrashing aria-label="Explain the concept of thrashing.">Explain the concept of thrashing.</a></li><li><a href=#what-is-the-purpose-of-a-semaphore aria-label="What is the purpose of a semaphore?">What is the purpose of a semaphore?</a></li><li><a href=#what-is-memory-fragmentation-how-does-it-occur-and-how-is-it-solved aria-label="What is memory fragmentation, how does it occur, and how is it solved?">What is memory fragmentation, how does it occur, and how is it solved?</a></li><li><a href=#what-are-virtual-memory-and-physical-memory-in-operating-systems aria-label="What are virtual memory and physical memory in operating systems?">What are virtual memory and physical memory in operating systems?</a></li><li><a href=#explain-kernel-mode-and-user-mode-in-operating-systems aria-label="Explain kernel mode and user mode in operating systems">Explain kernel mode and user mode in operating systems</a></li></ul></div></details></div><div class=post-content><h2 id=explain-the-difference-between-a-process-and-a-thread>Explain the difference between a process and a thread.<a hidden class=anchor aria-hidden=true href=#explain-the-difference-between-a-process-and-a-thread>#</a></h2><ul><li><p>Process:</p><ul><li>Independent execution unit</li><li>Has its own memory space</li><li>Heavyweight, more resources</li><li>Isolated from other processes</li></ul></li><li><p>Thread:</p><ul><li>Lightweight unit of execution within a process</li><li>Shares memory space with other threads in the same process</li><li>Less resource-intensive</li><li>Can communicate easily with other threads in the same process</li></ul></li></ul><h2 id=how-do-processes-and-threads-communicate>How do processes and threads communicate<a hidden class=anchor aria-hidden=true href=#how-do-processes-and-threads-communicate>#</a></h2><p>Process communication methods:</p><ul><li>Pipes and named pipes</li><li>Shared memory</li><li>Message queues</li><li>Sockets</li><li>Signals</li></ul><p>Thread communication methods:</p><ul><li>Shared memory within the same process</li><li>Mutex and semaphores for synchronization</li><li>Condition variables</li></ul><h2 id=explain-the-concept-of-deadlock-and-its-four-necessary-conditions>Explain the concept of deadlock and its four necessary conditions.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-deadlock-and-its-four-necessary-conditions>#</a></h2><p>Deadlock is a situation where a set of processes are blocked because each process is holding a resource and waiting to acquire a resource held by another process.</p><p>Four necessary conditions (Coffman conditions):</p><ol><li>Mutual Exclusion: At least one resource must be held in a non-sharable mode</li><li>Hold and Wait: A process must be holding at least one resource while waiting to acquire additional resources held by other processes</li><li>No Preemption: Resources cannot be forcibly taken away from a process; they must be released voluntarily</li><li>Circular Wait: A circular chain of two or more processes, each waiting for a resource held by the next member in the chain</li></ol><h2 id=what-is-the-purpose-of-paging-in-an-operating-system>What is the purpose of paging in an operating system?<a hidden class=anchor aria-hidden=true href=#what-is-the-purpose-of-paging-in-an-operating-system>#</a></h2><p>Paging is a memory management scheme that eliminates the need for contiguous allocation of physical memory. It allows the physical address space of a process to be non-contiguous.</p><p>Benefits:</p><ul><li>Efficient use of memory</li><li>Supports virtual memory</li><li>Simplifies memory allocation</li></ul><p>Paging Overview</p><pre tabindex=0><code>[Logical Address Space]     [Page Table]     [Physical Address Space]
+------------------+        +----------+     +------------------+
|      Page 0      | -----&gt; | Frame 2  | --&gt; |     Frame 0      |
+------------------+        +----------+     +------------------+
|      Page 1      | -----&gt; | Frame 4  | --&gt; |     Frame 1      |
+------------------+        +----------+     +------------------+
|      Page 2      | -----&gt; | Frame 1  | --&gt; |     Frame 2      |
+------------------+        +----------+     +------------------+
|      Page 3      | -----&gt; | Frame 7  | --&gt; |     Frame 3      |
+------------------+        +----------+     +------------------+
                                             |     Frame 4      |
                                             +------------------+
                                             |     Frame 5      |
                                             +------------------+
                                             |     Frame 6      |
                                             +------------------+
                                             |     Frame 7      |
                                             +------------------+
</code></pre><p>Logical pages are mapped to physical frames through a page table. Note that pages can be stored in non-contiguous frames.</p><p>Address Translation</p><pre tabindex=0><code>[Logical Address]
+----------------+----------------+
|    Page No.    |    Offset      |
+----------------+----------------+
       |                 |
       |                 |
       V                 |
 [Page Table]            |
+----------------+       |
| Frame Number   |       |
+----------------+       |
       |                 |
       |                 |
       V                 V
+----------------+----------------+
|  Frame Number  |    Offset      |
+----------------+----------------+
[Physical Address]
</code></pre><p>Virtual Memory with Paging</p><pre tabindex=0><code>[Virtual Address Space]   [Physical Memory]   [Disk Storage]
+------------------+      +---------------+   +-------------+
|      Page 0      | ---&gt; |    Frame 0    |   |   Page 3    |
+------------------+      +---------------+   +-------------+
|      Page 1      | ---&gt; |    Frame 2    |   |   Page 5    |
+------------------+      +---------------+   +-------------+
|      Page 2      | ---&gt; |    Frame 1    |   |   Page 6    |
+------------------+      +---------------+   +-------------+
|      Page 3      | --.  |    Frame 3    |   |    ...      |
+------------------+   |  +---------------+   +-------------+
|      Page 4      | ---&gt; |    Frame 4    |
+------------------+      +---------------+
|      Page 5      | --.
+------------------+   |
|      Page 6      | --.
+------------------+
</code></pre><p>Paging supports virtual memory. Some pages are in physical memory, while others are stored on disk and can be swapped in when needed.</p><h2 id=explain-the-difference-between-preemptive-and-non-preemptive-scheduling>Explain the difference between preemptive and non-preemptive scheduling.<a hidden class=anchor aria-hidden=true href=#explain-the-difference-between-preemptive-and-non-preemptive-scheduling>#</a></h2><ul><li><p>Preemptive Scheduling:</p><ul><li>The CPU can be taken away from a process before it finishes its burst time</li><li>Better for time-sharing systems</li><li>Can lead to race conditions if not properly managed</li></ul></li><li><p>Non-preemptive Scheduling:</p><ul><li>Once the CPU has been allocated to a process, the process keeps it until it releases the CPU either by terminating or by switching to the waiting state</li><li>Simpler to implement</li><li>Can lead to poor response time for interactive processes</li></ul></li></ul><h2 id=what-is-a-system-call>What is a system call?<a hidden class=anchor aria-hidden=true href=#what-is-a-system-call>#</a></h2><p>A system call is the programmatic way in which a computer program requests a service from the kernel of the operating system. System calls provide an essential interface between a process and the operating system.</p><p>Examples of system calls:</p><ul><li>File operations (open, read, write, close)</li><li>Process control (fork, exec, exit)</li><li>Device management</li><li>Information maintenance</li><li>Communication</li></ul><h2 id=explain-the-concept-of-thrashing>Explain the concept of thrashing.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-thrashing>#</a></h2><p>Thrashing is a condition where excessive paging operations are taking place. It occurs when a computer&rsquo;s virtual memory subsystem is in a constant state of paging, rapidly exchanging data in memory for data on disk, to the exclusion of most application-level processing.</p><p>Causes:</p><ul><li>Insufficient physical memory</li><li>Poor page replacement algorithms</li><li>Large working sets</li></ul><h2 id=what-is-the-purpose-of-a-semaphore>What is the purpose of a semaphore?<a hidden class=anchor aria-hidden=true href=#what-is-the-purpose-of-a-semaphore>#</a></h2><p>A semaphore is a variable or abstract data type used to control access to a common resource by multiple processes in a concurrent system. It&rsquo;s used for process synchronization and to solve critical section problems.</p><p>Types:</p><ul><li>Binary Semaphore (mutex): Can have only 0 or 1 as value</li><li>Counting Semaphore: Can have any non-negative value</li></ul><h2 id=what-is-memory-fragmentation-how-does-it-occur-and-how-is-it-solved>What is memory fragmentation, how does it occur, and how is it solved?<a hidden class=anchor aria-hidden=true href=#what-is-memory-fragmentation-how-does-it-occur-and-how-is-it-solved>#</a></h2><p>Memory fragmentation refers to the condition where memory space is broken into small, unusable blocks, reducing overall memory utilization efficiency.</p><p>How it occurs:</p><ul><li>External fragmentation: Frequent allocation and deallocation of memory blocks leaves small, unusable gaps between allocated blocks</li><li>Internal fragmentation: Fixed-size memory allocation schemes may allocate more memory than required, leaving unused space within allocated blocks</li></ul><p>Solutions:</p><ul><li>Compaction: Relocating allocated memory blocks to create larger contiguous free spaces</li><li>Paging: Dividing memory into fixed-size pages, eliminating external fragmentation</li><li>Memory pools: Pre-allocating fixed-size memory blocks for specific uses</li><li>Garbage collection: Automatically freeing unused memory and reorganizing remaining objects</li></ul><h2 id=what-are-virtual-memory-and-physical-memory-in-operating-systems>What are virtual memory and physical memory in operating systems?<a hidden class=anchor aria-hidden=true href=#what-are-virtual-memory-and-physical-memory-in-operating-systems>#</a></h2><p>Virtual memory is an abstraction of physical memory that provides each process with the illusion of having its own large, contiguous address space.</p><p>Physical memory refers to the actual RAM(Random-access memory) installed in a computer.</p><p>Key points:</p><ul><li>Virtual memory allows programs to use more memory than physically available</li><li>It maps virtual addresses to physical addresses or disk storage</li><li>Enables memory protection between processes</li><li>Simplifies memory management for programmers</li></ul><h2 id=explain-kernel-mode-and-user-mode-in-operating-systems>Explain kernel mode and user mode in operating systems<a hidden class=anchor aria-hidden=true href=#explain-kernel-mode-and-user-mode-in-operating-systems>#</a></h2><p>Kernel mode and user mode are privilege levels in which code executes:</p><p>Kernel mode:</p><ul><li>Has unrestricted access to hardware and system resources</li><li>Can execute privileged instructions</li><li>Used by the operating system kernel and device drivers</li></ul><p>User mode:</p><ul><li>Has limited access to system resources</li><li>Cannot execute privileged instructions directly</li><li>Used by application programs</li></ul><p>Switching between modes:</p><ul><li>System calls trigger a switch from user mode to kernel mode</li><li>Return from system calls switches back to user mode</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/operatingsystem/>OperatingSystem</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>