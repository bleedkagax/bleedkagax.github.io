<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go's Common Data Structures | Kaga Blog</title>
<meta name=keywords content="Golang"><meta name=description content="1. Strings
Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.
Structure
type stringStruct struct {
    str unsafe.Pointer
    len int
}
Memory Layout
stringStruct
+----------------+
| str (uintptr)  | ---> [byte array]
| len (int)      |
+----------------+
"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/1_go_data_structure/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/1_go_data_structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go's Common Data Structures"><meta property="og:description" content="1. Strings
Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.
Structure
type stringStruct struct {
    str unsafe.Pointer
    len int
}
Memory Layout
stringStruct
+----------------+
| str (uintptr)  | ---> [byte array]
| len (int)      |
+----------------+
"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/1_go_data_structure/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-11T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go's Common Data Structures"><meta name=twitter:description content="1. Strings
Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.
Structure
type stringStruct struct {
    str unsafe.Pointer
    len int
}
Memory Layout
stringStruct
+----------------+
| str (uintptr)  | ---> [byte array]
| len (int)      |
+----------------+
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Go's Common Data Structures","item":"https://bleedkagax.github.io/post/1_go_data_structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go's Common Data Structures","name":"Go\u0027s Common Data Structures","description":"1. Strings Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.\nStructure type stringStruct struct { str unsafe.Pointer len int } Memory Layout stringStruct +----------------+ | str (uintptr) | ---\u0026gt; [byte array] | len (int) | +----------------+ ","keywords":["Golang"],"articleBody":"1. Strings Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.\nStructure type stringStruct struct { str unsafe.Pointer len int } Memory Layout stringStruct +----------------+ | str (uintptr) | ---\u003e [byte array] | len (int) | +----------------+ Detailed Implementation Creation When a string literal is used, the compiler allocates the bytes in read-only memory. Runtime string creation (e.g., string concatenation) allocates new memory and copies bytes. Operations Substring: Creates a new stringStruct pointing to the same byte array, with adjusted str and len. Concatenation: Allocates a new byte array and copies contents from both strings. Comparison: Compares bytes lexicographically. Runtime Behavior Immutability: String contents cannot be changed after creation. This allows for safe concurrent access and efficient substring operations. UTF-8: Go source code is UTF-8, and string literals are interpreted as UTF-8. However, a string can contain arbitrary bytes. Conversion: Converting between strings and byte slices involves copying data. 2. Slices Slices provide a flexible, dynamic array-like interface.\nStructure type slice struct { array unsafe.Pointer len int cap int } Memory Layout slice +-------------------+ | array (uintptr) | ---\u003e [underlying array] | len (int) | | cap (int) | +-------------------+ Detailed Implementation Creation make: Allocates a new array and sets up the slice structure. Literal: Compiler creates an array and sets up the slice structure. Slicing existing array/slice: Creates a new slice header pointing to the same array. Growth Algorithm When appending to a slice that exceeds its capacity:\nIf capacity \u003c 1024, double the capacity. If capacity ≥ 1024, grow by 25%. Round up to the next size class (for better memory allocation). Append Operation Check if there’s enough capacity. If not, grow the slice (allocate new array, copy data). Copy new elements to the end of the slice. Update len (and possibly cap and array pointer). Runtime Behavior Bounds Checking: Go performs runtime bounds checking for all slice accesses. Copy: Uses optimized memory copy functions (potentially using SIMD instructions). GC Interaction: The garbage collector considers the entire capacity of a slice, not just its length. 3. Maps Maps in Go are implemented as hash tables with separate chaining for collision resolution.\nStructure type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra } type bmap struct { tophash [8]uint8 // followed by keys // followed by values // followed by an overflow pointer } Memory Layout hmap +-------------------+ | count | | flags | | B | | noverflow | | hash0 | | buckets -------|---\u003e [array of 2^B pointers to bmap] | oldbuckets | | nevacuate | | extra | +-------------------+ bmap (bucket) +------------------+ | tophash [8]uint8 | +------------------+ | keys [8]KeyType| +------------------+ | values [8]ValType| +------------------+ | overflow *bmap | +------------------+ Detailed Implementation Hashing Each key type has a specific hash function. The hash is seeded with hash0 to prevent collision attacks. Lower B bits of the hash are used to select the bucket. Upper 8 bits are stored in tophash for quick comparisons. Lookup Compute the hash of the key. Use lower bits to find the bucket. Search the bucket (and overflow buckets) for matching tophash and key. Insertion Find the appropriate bucket. If the bucket is full, allocate an overflow bucket. Insert the key-value pair and update count. Deletion Find the key-value pair. Zero out the tophash, key, and value. Update count during the next map growth. Growth Triggered when load factor \u003e 6.5 or too many overflow buckets. Allocate a new bucket array with 2^(B+1) buckets. Gradually move items from old buckets to new ones during subsequent operations. Runtime Behavior Concurrency: Maps are not safe for concurrent read/write access. Iteration: Map iteration order is randomized. Load Factor: Maintained around 6.5 items per bucket for performance. 4. Channels Channels provide a way for goroutines to communicate and synchronize.\nStructure type hchan struct { qcount uint dataqsiz uint buf unsafe.Pointer elemsize uint16 closed uint32 elemtype *_type sendx uint recvx uint recvq waitq sendq waitq lock mutex } Memory Layout hchan +-------------------+ | qcount | | dataqsiz | | buf ------|---\u003e [circular buffer] | elemsize | | closed | | elemtype | | sendx | | recvx | | recvq ------|---\u003e [waiting receivers] | sendq ------|---\u003e [waiting senders] | lock | +-------------------+ Detailed Implementation Creation Allocate hchan struct. For buffered channels, allocate buffer. Send Operation Lock the channel. If channel is closed, panic. If receiver is waiting, transfer data directly. Else if buffer not full, copy data to buffer. Else park the goroutine in sendq. Unlock the channel. Receive Operation Lock the channel. If channel is empty and closed, return zero value. If sender is waiting, receive directly or from buffer. Else if data in buffer, receive from buffer. Else park the goroutine in recvq. Unlock the channel. Close Operation Lock the channel. Set closed to 1. Release all waiting goroutines. Unlock the channel. Runtime Behavior Blocking: Channel operations may cause goroutine scheduling. Fairness: Generally FIFO, but not guaranteed. Select: Uses special cases for efficiency (e.g., 2-case select). 5. Interfaces Interfaces in Go provide a way to specify behavior of types.\nStructure type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter *interfacetype _type *_type hash uint32 _ [4]byte fun [1]uintptr } Memory Layout iface +----------------+ | tab *itab | ---\u003e itab | data unsafe.Ptr| ---\u003e concrete data +----------------+ itab +------------------+ | inter | | _type | | hash | | _ | | fun [1]uintptr | ---\u003e [method table] +------------------+ Detailed Implementation Interface Assignment Check if type implements interface. Create or retrieve itab. Set up iface with itab and pointer to data. Method Call Access function pointer from itab.fun. Call function with data as receiver. Type Assertions Check _type in itab. If match, return data; else panic or return false. Runtime Behavior Dynamic Dispatch: Method calls use indirect function calls. Type Switch: Optimized for common cases. Empty Interface: Special fast-path for interface{}. ","wordCount":"989","inLanguage":"en","datePublished":"2024-10-11T00:00:00Z","dateModified":"2024-10-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/1_go_data_structure/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go's Common Data Structures</h1><div class=post-meta><span title='2024-10-11 00:00:00 +0000 UTC'>October 11, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-strings aria-label="1. Strings">1. Strings</a><ul><li><a href=#structure aria-label=Structure>Structure</a></li><li><a href=#memory-layout aria-label="Memory Layout">Memory Layout</a></li><li><a href=#detailed-implementation aria-label="Detailed Implementation">Detailed Implementation</a><ul><li><a href=#creation aria-label=Creation>Creation</a></li><li><a href=#operations aria-label=Operations>Operations</a></li></ul></li><li><a href=#runtime-behavior aria-label="Runtime Behavior">Runtime Behavior</a></li></ul></li><li><a href=#2-slices aria-label="2. Slices">2. Slices</a><ul><li><a href=#structure-1 aria-label=Structure>Structure</a></li><li><a href=#memory-layout-1 aria-label="Memory Layout">Memory Layout</a></li><li><a href=#detailed-implementation-1 aria-label="Detailed Implementation">Detailed Implementation</a><ul><li><a href=#creation-1 aria-label=Creation>Creation</a></li><li><a href=#growth-algorithm aria-label="Growth Algorithm">Growth Algorithm</a></li><li><a href=#append-operation aria-label="Append Operation">Append Operation</a></li></ul></li><li><a href=#runtime-behavior-1 aria-label="Runtime Behavior">Runtime Behavior</a></li></ul></li><li><a href=#3-maps aria-label="3. Maps">3. Maps</a><ul><li><a href=#structure-2 aria-label=Structure>Structure</a></li><li><a href=#memory-layout-2 aria-label="Memory Layout">Memory Layout</a></li><li><a href=#detailed-implementation-2 aria-label="Detailed Implementation">Detailed Implementation</a><ul><li><a href=#hashing aria-label=Hashing>Hashing</a></li><li><a href=#lookup aria-label=Lookup>Lookup</a></li><li><a href=#insertion aria-label=Insertion>Insertion</a></li><li><a href=#deletion aria-label=Deletion>Deletion</a></li><li><a href=#growth aria-label=Growth>Growth</a></li></ul></li><li><a href=#runtime-behavior-2 aria-label="Runtime Behavior">Runtime Behavior</a></li></ul></li><li><a href=#4-channels aria-label="4. Channels">4. Channels</a><ul><li><a href=#structure-3 aria-label=Structure>Structure</a></li><li><a href=#memory-layout-3 aria-label="Memory Layout">Memory Layout</a></li><li><a href=#detailed-implementation-3 aria-label="Detailed Implementation">Detailed Implementation</a><ul><li><a href=#creation-2 aria-label=Creation>Creation</a></li><li><a href=#send-operation aria-label="Send Operation">Send Operation</a></li><li><a href=#receive-operation aria-label="Receive Operation">Receive Operation</a></li><li><a href=#close-operation aria-label="Close Operation">Close Operation</a></li></ul></li><li><a href=#runtime-behavior-3 aria-label="Runtime Behavior">Runtime Behavior</a></li></ul></li><li><a href=#5-interfaces aria-label="5. Interfaces">5. Interfaces</a><ul><li><a href=#structure-4 aria-label=Structure>Structure</a></li><li><a href=#memory-layout-4 aria-label="Memory Layout">Memory Layout</a></li><li><a href=#detailed-implementation-4 aria-label="Detailed Implementation">Detailed Implementation</a><ul><li><a href=#interface-assignment aria-label="Interface Assignment">Interface Assignment</a></li><li><a href=#method-call aria-label="Method Call">Method Call</a></li><li><a href=#type-assertions aria-label="Type Assertions">Type Assertions</a></li></ul></li><li><a href=#runtime-behavior-4 aria-label="Runtime Behavior">Runtime Behavior</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=1-strings>1. Strings<a hidden class=anchor aria-hidden=true href=#1-strings>#</a></h2><p>Strings in Go are immutable sequences of bytes, typically used to represent UTF-8 encoded text.</p><h3 id=structure>Structure<a hidden class=anchor aria-hidden=true href=#structure>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stringStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-layout>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout>#</a></h3><pre tabindex=0><code>stringStruct
+----------------+
| str (uintptr)  | ---&gt; [byte array]
| len (int)      |
+----------------+
</code></pre><h3 id=detailed-implementation>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation>#</a></h3><h4 id=creation>Creation<a hidden class=anchor aria-hidden=true href=#creation>#</a></h4><ol><li>When a string literal is used, the compiler allocates the bytes in read-only memory.</li><li>Runtime string creation (e.g., string concatenation) allocates new memory and copies bytes.</li></ol><h4 id=operations>Operations<a hidden class=anchor aria-hidden=true href=#operations>#</a></h4><ul><li><strong>Substring</strong>: Creates a new <code>stringStruct</code> pointing to the same byte array, with adjusted <code>str</code> and <code>len</code>.</li><li><strong>Concatenation</strong>: Allocates a new byte array and copies contents from both strings.</li><li><strong>Comparison</strong>: Compares bytes lexicographically.</li></ul><h3 id=runtime-behavior>Runtime Behavior<a hidden class=anchor aria-hidden=true href=#runtime-behavior>#</a></h3><ul><li><strong>Immutability</strong>: String contents cannot be changed after creation. This allows for safe concurrent access and efficient substring operations.</li><li><strong>UTF-8</strong>: Go source code is UTF-8, and string literals are interpreted as UTF-8. However, a string can contain arbitrary bytes.</li><li><strong>Conversion</strong>: Converting between strings and byte slices involves copying data.</li></ul><h2 id=2-slices>2. Slices<a hidden class=anchor aria-hidden=true href=#2-slices>#</a></h2><p>Slices provide a flexible, dynamic array-like interface.</p><h3 id=structure-1>Structure<a hidden class=anchor aria-hidden=true href=#structure-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span>   <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-layout-1>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout-1>#</a></h3><pre tabindex=0><code>slice
+-------------------+
| array (uintptr)   | ---&gt; [underlying array]
| len   (int)       |
| cap   (int)       |
+-------------------+
</code></pre><h3 id=detailed-implementation-1>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation-1>#</a></h3><h4 id=creation-1>Creation<a hidden class=anchor aria-hidden=true href=#creation-1>#</a></h4><ol><li><strong>make</strong>: Allocates a new array and sets up the slice structure.</li><li><strong>Literal</strong>: Compiler creates an array and sets up the slice structure.</li><li><strong>Slicing existing array/slice</strong>: Creates a new slice header pointing to the same array.</li></ol><h4 id=growth-algorithm>Growth Algorithm<a hidden class=anchor aria-hidden=true href=#growth-algorithm>#</a></h4><p>When appending to a slice that exceeds its capacity:</p><ol><li>If capacity &lt; 1024, double the capacity.</li><li>If capacity ≥ 1024, grow by 25%.</li><li>Round up to the next size class (for better memory allocation).</li></ol><h4 id=append-operation>Append Operation<a hidden class=anchor aria-hidden=true href=#append-operation>#</a></h4><ol><li>Check if there&rsquo;s enough capacity.</li><li>If not, grow the slice (allocate new array, copy data).</li><li>Copy new elements to the end of the slice.</li><li>Update len (and possibly cap and array pointer).</li></ol><h3 id=runtime-behavior-1>Runtime Behavior<a hidden class=anchor aria-hidden=true href=#runtime-behavior-1>#</a></h3><ul><li><strong>Bounds Checking</strong>: Go performs runtime bounds checking for all slice accesses.</li><li><strong>Copy</strong>: Uses optimized memory copy functions (potentially using SIMD instructions).</li><li><strong>GC Interaction</strong>: The garbage collector considers the entire capacity of a slice, not just its length.</li></ul><h2 id=3-maps>3. Maps<a hidden class=anchor aria-hidden=true href=#3-maps>#</a></h2><p>Maps in Go are implemented as hash tables with separate chaining for collision resolution.</p><h3 id=structure-2>Structure<a hidden class=anchor aria-hidden=true href=#structure-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>buckets</span>   <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tophash</span> [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// followed by keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// followed by values
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// followed by an overflow pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=memory-layout-2>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout-2>#</a></h3><pre tabindex=0><code>hmap
+-------------------+
| count             |
| flags             |
| B                 |
| noverflow         |
| hash0             |
| buckets    -------|---&gt; [array of 2^B pointers to bmap]
| oldbuckets        |
| nevacuate         |
| extra             |
+-------------------+

bmap (bucket)
+------------------+
| tophash [8]uint8 |
+------------------+
| keys   [8]KeyType|
+------------------+
| values [8]ValType|
+------------------+
| overflow *bmap   |
+------------------+
</code></pre><h3 id=detailed-implementation-2>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation-2>#</a></h3><h4 id=hashing>Hashing<a hidden class=anchor aria-hidden=true href=#hashing>#</a></h4><ol><li>Each key type has a specific hash function.</li><li>The hash is seeded with <code>hash0</code> to prevent collision attacks.</li><li>Lower <code>B</code> bits of the hash are used to select the bucket.</li><li>Upper 8 bits are stored in <code>tophash</code> for quick comparisons.</li></ol><h4 id=lookup>Lookup<a hidden class=anchor aria-hidden=true href=#lookup>#</a></h4><ol><li>Compute the hash of the key.</li><li>Use lower bits to find the bucket.</li><li>Search the bucket (and overflow buckets) for matching <code>tophash</code> and key.</li></ol><h4 id=insertion>Insertion<a hidden class=anchor aria-hidden=true href=#insertion>#</a></h4><ol><li>Find the appropriate bucket.</li><li>If the bucket is full, allocate an overflow bucket.</li><li>Insert the key-value pair and update <code>count</code>.</li></ol><h4 id=deletion>Deletion<a hidden class=anchor aria-hidden=true href=#deletion>#</a></h4><ol><li>Find the key-value pair.</li><li>Zero out the <code>tophash</code>, key, and value.</li><li>Update <code>count</code> during the next map growth.</li></ol><h4 id=growth>Growth<a hidden class=anchor aria-hidden=true href=#growth>#</a></h4><ol><li>Triggered when load factor > 6.5 or too many overflow buckets.</li><li>Allocate a new bucket array with 2^(B+1) buckets.</li><li>Gradually move items from old buckets to new ones during subsequent operations.</li></ol><h3 id=runtime-behavior-2>Runtime Behavior<a hidden class=anchor aria-hidden=true href=#runtime-behavior-2>#</a></h3><ul><li><strong>Concurrency</strong>: Maps are not safe for concurrent read/write access.</li><li><strong>Iteration</strong>: Map iteration order is randomized.</li><li><strong>Load Factor</strong>: Maintained around 6.5 items per bucket for performance.</li></ul><h2 id=4-channels>4. Channels<a hidden class=anchor aria-hidden=true href=#4-channels>#</a></h2><p>Channels provide a way for goroutines to communicate and synchronize.</p><h3 id=structure-3>Structure<a hidden class=anchor aria-hidden=true href=#structure-3>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hchan</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>qcount</span>   <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dataqsiz</span> <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>buf</span>      <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>elemsize</span> <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>closed</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>elemtype</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sendx</span>    <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>recvx</span>    <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>recvq</span>    <span style=color:#a6e22e>waitq</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sendq</span>    <span style=color:#a6e22e>waitq</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lock</span>     <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-layout-3>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout-3>#</a></h3><pre tabindex=0><code>hchan
+-------------------+
| qcount            |
| dataqsiz          |
| buf         ------|---&gt; [circular buffer]
| elemsize          |
| closed            |
| elemtype          |
| sendx             |
| recvx             |
| recvq       ------|---&gt; [waiting receivers]
| sendq       ------|---&gt; [waiting senders]
| lock              |
+-------------------+
</code></pre><h3 id=detailed-implementation-3>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation-3>#</a></h3><h4 id=creation-2>Creation<a hidden class=anchor aria-hidden=true href=#creation-2>#</a></h4><ol><li>Allocate <code>hchan</code> struct.</li><li>For buffered channels, allocate buffer.</li></ol><h4 id=send-operation>Send Operation<a hidden class=anchor aria-hidden=true href=#send-operation>#</a></h4><ol><li>Lock the channel.</li><li>If channel is closed, panic.</li><li>If receiver is waiting, transfer data directly.</li><li>Else if buffer not full, copy data to buffer.</li><li>Else park the goroutine in <code>sendq</code>.</li><li>Unlock the channel.</li></ol><h4 id=receive-operation>Receive Operation<a hidden class=anchor aria-hidden=true href=#receive-operation>#</a></h4><ol><li>Lock the channel.</li><li>If channel is empty and closed, return zero value.</li><li>If sender is waiting, receive directly or from buffer.</li><li>Else if data in buffer, receive from buffer.</li><li>Else park the goroutine in <code>recvq</code>.</li><li>Unlock the channel.</li></ol><h4 id=close-operation>Close Operation<a hidden class=anchor aria-hidden=true href=#close-operation>#</a></h4><ol><li>Lock the channel.</li><li>Set <code>closed</code> to 1.</li><li>Release all waiting goroutines.</li><li>Unlock the channel.</li></ol><h3 id=runtime-behavior-3>Runtime Behavior<a hidden class=anchor aria-hidden=true href=#runtime-behavior-3>#</a></h3><ul><li><strong>Blocking</strong>: Channel operations may cause goroutine scheduling.</li><li><strong>Fairness</strong>: Generally FIFO, but not guaranteed.</li><li><strong>Select</strong>: Uses special cases for efficiency (e.g., 2-case select).</li></ul><h2 id=5-interfaces>5. Interfaces<a hidden class=anchor aria-hidden=true href=#5-interfaces>#</a></h2><p>Interfaces in Go provide a way to specify behavior of types.</p><h3 id=structure-4>Structure<a hidden class=anchor aria-hidden=true href=#structure-4>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>iface</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tab</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>itab</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>itab</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>inter</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>interfacetype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_type</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>hash</span>  <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>     [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fun</span>   [<span style=color:#ae81ff>1</span>]<span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=memory-layout-4>Memory Layout<a hidden class=anchor aria-hidden=true href=#memory-layout-4>#</a></h3><pre tabindex=0><code>iface
+----------------+
| tab  *itab     | ---&gt; itab
| data unsafe.Ptr| ---&gt; concrete data
+----------------+

itab
+------------------+
| inter            |
| _type            |
| hash             |
| _                |
| fun [1]uintptr   | ---&gt; [method table]
+------------------+
</code></pre><h3 id=detailed-implementation-4>Detailed Implementation<a hidden class=anchor aria-hidden=true href=#detailed-implementation-4>#</a></h3><h4 id=interface-assignment>Interface Assignment<a hidden class=anchor aria-hidden=true href=#interface-assignment>#</a></h4><ol><li>Check if type implements interface.</li><li>Create or retrieve <code>itab</code>.</li><li>Set up <code>iface</code> with <code>itab</code> and pointer to data.</li></ol><h4 id=method-call>Method Call<a hidden class=anchor aria-hidden=true href=#method-call>#</a></h4><ol><li>Access function pointer from <code>itab.fun</code>.</li><li>Call function with <code>data</code> as receiver.</li></ol><h4 id=type-assertions>Type Assertions<a hidden class=anchor aria-hidden=true href=#type-assertions>#</a></h4><ol><li>Check <code>_type</code> in <code>itab</code>.</li><li>If match, return <code>data</code>; else panic or return false.</li></ol><h3 id=runtime-behavior-4>Runtime Behavior<a hidden class=anchor aria-hidden=true href=#runtime-behavior-4>#</a></h3><ul><li><strong>Dynamic Dispatch</strong>: Method calls use indirect function calls.</li><li><strong>Type Switch</strong>: Optimized for common cases.</li><li><strong>Empty Interface</strong>: Special fast-path for <code>interface{}</code>.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/golang/>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>