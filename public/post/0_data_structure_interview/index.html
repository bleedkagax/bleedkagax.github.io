<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structure Interview | Kaga Blog</title>
<meta name=keywords content="DataStructure"><meta name=description content="What is the difference between an array and a linked list?


Array:

Fixed size (in most languages)
Contiguous memory allocation
Fast random access
Insertion/deletion is expensive (except at the end)



Linked List:

Dynamic size
Non-contiguous memory allocation
Slow random access
Fast insertion/deletion



Explain the difference between a stack and a queue.


Stack:

Last-In-First-Out (LIFO) structure
Push (insert) and pop (remove) operations occur at the same end
Used for function calls, undo mechanisms, expression evaluation



Queue:"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/0_data_structure_interview/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/0_data_structure_interview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Data Structure Interview"><meta property="og:description" content="What is the difference between an array and a linked list?


Array:

Fixed size (in most languages)
Contiguous memory allocation
Fast random access
Insertion/deletion is expensive (except at the end)



Linked List:

Dynamic size
Non-contiguous memory allocation
Slow random access
Fast insertion/deletion



Explain the difference between a stack and a queue.


Stack:

Last-In-First-Out (LIFO) structure
Push (insert) and pop (remove) operations occur at the same end
Used for function calls, undo mechanisms, expression evaluation



Queue:"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/0_data_structure_interview/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Data Structure Interview"><meta name=twitter:description content="What is the difference between an array and a linked list?


Array:

Fixed size (in most languages)
Contiguous memory allocation
Fast random access
Insertion/deletion is expensive (except at the end)



Linked List:

Dynamic size
Non-contiguous memory allocation
Slow random access
Fast insertion/deletion



Explain the difference between a stack and a queue.


Stack:

Last-In-First-Out (LIFO) structure
Push (insert) and pop (remove) operations occur at the same end
Used for function calls, undo mechanisms, expression evaluation



Queue:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Data Structure Interview","item":"https://bleedkagax.github.io/post/0_data_structure_interview/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Data Structure Interview","name":"Data Structure Interview","description":"What is the difference between an array and a linked list? Array:\nFixed size (in most languages) Contiguous memory allocation Fast random access Insertion/deletion is expensive (except at the end) Linked List:\nDynamic size Non-contiguous memory allocation Slow random access Fast insertion/deletion Explain the difference between a stack and a queue. Stack:\nLast-In-First-Out (LIFO) structure Push (insert) and pop (remove) operations occur at the same end Used for function calls, undo mechanisms, expression evaluation Queue:\n","keywords":["DataStructure"],"articleBody":"What is the difference between an array and a linked list? Array:\nFixed size (in most languages) Contiguous memory allocation Fast random access Insertion/deletion is expensive (except at the end) Linked List:\nDynamic size Non-contiguous memory allocation Slow random access Fast insertion/deletion Explain the difference between a stack and a queue. Stack:\nLast-In-First-Out (LIFO) structure Push (insert) and pop (remove) operations occur at the same end Used for function calls, undo mechanisms, expression evaluation Queue:\nFirst-In-First-Out (FIFO) structure Enqueue (insert) at rear, dequeue (remove) from front Used for task scheduling, breadth-first search What is a binary search tree? A binary search tree is a binary tree data structure where each node has at most two children, referred to as the left child and the right child. For each node:\nAll nodes in the left subtree have values less than the node’s value All nodes in the right subtree have values greater than the node’s value This property allows for efficient searching, insertion, and deletion operations.\nExplain the concept of hashing and hash tables. Hashing is a technique used to uniquely identify a specific object from a group of similar objects. It involves using a hash function to map keys to indices of an array (hash table).\nHash Table:\nData structure that implements an associative array abstract data type Uses a hash function to compute an index into an array of buckets or slots What is a balanced tree and why is it important? A balanced tree is a binary tree structure in which the left and right subtrees of every node differ in height by no more than one. Examples include AVL trees and Red-Black trees.\nImportance:\nEnsures O(log n) time complexity for operations like insertion, deletion, and search Prevents degeneration into a linked list, which would result in O(n) time complexity Explain the difference between DFS and BFS. Depth-First Search (DFS):\nExplores as far as possible along each branch before backtracking Uses a stack (or recursion) Memory efficient for trees Can get trapped in infinite loops for graphs Breadth-First Search (BFS):\nExplores all the neighbor nodes at the present depth prior to moving to nodes at the next depth level Uses a queue Finds the shortest path in unweighted graphs Can be memory-intensive What is a heap data structure? A heap is a specialized tree-based data structure that satisfies the heap property:\nIn a max heap, for any given node C, if P is a parent node of C, then the key of P is greater than or equal to the key of C In a min heap, the key of P is less than or equal to the key of C Heaps are commonly used to implement priority queues and in sorting algorithms like heapsort.\nExplain the concept of dynamic programming. Dynamic programming is both a mathematical optimization method and a computer programming method. It works by breaking down a complex problem into simpler subproblems in a recursive manner.\nCharacteristics:\nOverlapping Subproblems Optimal Substructure Common examples:\nFibonacci sequence Longest Common Subsequence Knapsack problem What is a trie and what is it used for? A trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.\nUses:\nAutocomplete Spell checkers IP routing tables Solving word games Explain the concept of a self-balancing tree. A self-balancing tree is a type of binary search tree that automatically keeps its height small in the face of arbitrary insertions and deletions. This ensures that operations like search, insert, and delete take O(log n) time.\nExamples:\nAVL trees Red-Black trees Splay trees These trees use rotations to maintain balance after insertions and deletions.\nWhat is the time complexity of common operations in different data structures? Array:\nAccess: O(1) Search: O(n) Insertion: O(n) Deletion: O(n) Linked List:\nAccess: O(n) Search: O(n) Insertion: O(1) Deletion: O(1) Binary Search Tree (balanced):\nSearch: O(log n) Insertion: O(log n) Deletion: O(log n) Hash Table:\nSearch: O(1) average, O(n) worst Insertion: O(1) average, O(n) worst Deletion: O(1) average, O(n) worst Explain the concept of a graph and its representations. A graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices and the edges are lines or arcs that connect any two nodes in the graph.\nRepresentations:\nAdjacency Matrix: 2D array of size V x V where V is the number of vertices Adjacency List: Array of linked lists Edge List: List of all edges in the graph What is the difference between a min-heap and a max-heap? Min-Heap:\nThe root node has the minimum value For any given node C, if P is a parent node of C, then the key of P is less than or equal to the key of C Max-Heap:\nThe root node has the maximum value For any given node C, if P is a parent node of C, then the key of P is greater than or equal to the key of C Both are commonly used to implement priority queues.\nExplain the concept of a B-tree. A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. It is optimized for systems that read and write large blocks of data.\nProperties:\nAll leaves are at the same level A non-leaf node with k children contains k-1 keys Each node (except root) must contain at least t-1 keys, where t is the minimum degree of B-tree All nodes may contain at most 2t-1 keys B-trees are commonly used in databases and file systems.\nWhat is a skip list? A skip list is a probabilistic data structure that allows O(log n) search complexity as well as O(log n) insertion complexity within an ordered sequence of elements. It is created from a linked list by adding multiple layers of header nodes.\nAdvantages:\nPerforms as well as balanced trees Simpler to implement than balanced tree structures Explain the difference between internal and external sorting. Internal Sorting:\nAll data to be sorted is held in main memory Faster but limited by available RAM Examples: Quicksort, Mergesort, Heapsort External Sorting:\nUsed when data doesn’t fit into main memory and must reside in slower external memory (like a hard drive) Involves multiple steps, often using merge sort Example: External merge sort What is a bloom filter? boom_filters\nExplain the concept of a disjoint-set data structure. A disjoint-set data structure, also called a union-find data structure, keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.\nOperations:\nFind: Determine which subset a particular element is in Union: Join two subsets into a single subset Uses:\nKruskal’s algorithm for finding minimum spanning trees Detecting cycles in graphs Path compression optimization ","wordCount":"1137","inLanguage":"en","datePublished":"2024-10-06T00:00:00Z","dateModified":"2024-10-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/0_data_structure_interview/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Data Structure Interview</h1><div class=post-meta><span title='2024-10-06 00:00:00 +0000 UTC'>October 6, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-the-difference-between-an-array-and-a-linked-list aria-label="What is the difference between an array and a linked list?">What is the difference between an array and a linked list?</a></li><li><a href=#explain-the-difference-between-a-stack-and-a-queue aria-label="Explain the difference between a stack and a queue.">Explain the difference between a stack and a queue.</a></li><li><a href=#what-is-a-binary-search-tree aria-label="What is a binary search tree?">What is a binary search tree?</a></li><li><a href=#explain-the-concept-of-hashing-and-hash-tables aria-label="Explain the concept of hashing and hash tables.">Explain the concept of hashing and hash tables.</a></li><li><a href=#what-is-a-balanced-tree-and-why-is-it-important aria-label="What is a balanced tree and why is it important?">What is a balanced tree and why is it important?</a></li><li><a href=#explain-the-difference-between-dfs-and-bfs aria-label="Explain the difference between DFS and BFS.">Explain the difference between DFS and BFS.</a></li><li><a href=#what-is-a-heap-data-structure aria-label="What is a heap data structure?">What is a heap data structure?</a></li><li><a href=#explain-the-concept-of-dynamic-programming aria-label="Explain the concept of dynamic programming.">Explain the concept of dynamic programming.</a></li><li><a href=#what-is-a-trie-and-what-is-it-used-for aria-label="What is a trie and what is it used for?">What is a trie and what is it used for?</a></li><li><a href=#explain-the-concept-of-a-self-balancing-tree aria-label="Explain the concept of a self-balancing tree.">Explain the concept of a self-balancing tree.</a></li><li><a href=#what-is-the-time-complexity-of-common-operations-in-different-data-structures aria-label="What is the time complexity of common operations in different data structures?">What is the time complexity of common operations in different data structures?</a></li><li><a href=#explain-the-concept-of-a-graph-and-its-representations aria-label="Explain the concept of a graph and its representations.">Explain the concept of a graph and its representations.</a></li><li><a href=#what-is-the-difference-between-a-min-heap-and-a-max-heap aria-label="What is the difference between a min-heap and a max-heap?">What is the difference between a min-heap and a max-heap?</a></li><li><a href=#explain-the-concept-of-a-b-tree aria-label="Explain the concept of a B-tree.">Explain the concept of a B-tree.</a></li><li><a href=#what-is-a-skip-list aria-label="What is a skip list?">What is a skip list?</a></li><li><a href=#explain-the-difference-between-internal-and-external-sorting aria-label="Explain the difference between internal and external sorting.">Explain the difference between internal and external sorting.</a></li><li><a href=#what-is-a-bloom-filter aria-label="What is a bloom filter?">What is a bloom filter?</a></li><li><a href=#explain-the-concept-of-a-disjoint-set-data-structure aria-label="Explain the concept of a disjoint-set data structure.">Explain the concept of a disjoint-set data structure.</a></li></ul></div></details></div><div class=post-content><h2 id=what-is-the-difference-between-an-array-and-a-linked-list>What is the difference between an array and a linked list?<a hidden class=anchor aria-hidden=true href=#what-is-the-difference-between-an-array-and-a-linked-list>#</a></h2><ul><li><p>Array:</p><ul><li>Fixed size (in most languages)</li><li>Contiguous memory allocation</li><li>Fast random access</li><li>Insertion/deletion is expensive (except at the end)</li></ul></li><li><p>Linked List:</p><ul><li>Dynamic size</li><li>Non-contiguous memory allocation</li><li>Slow random access</li><li>Fast insertion/deletion</li></ul></li></ul><h2 id=explain-the-difference-between-a-stack-and-a-queue>Explain the difference between a stack and a queue.<a hidden class=anchor aria-hidden=true href=#explain-the-difference-between-a-stack-and-a-queue>#</a></h2><ul><li><p>Stack:</p><ul><li>Last-In-First-Out (LIFO) structure</li><li>Push (insert) and pop (remove) operations occur at the same end</li><li>Used for function calls, undo mechanisms, expression evaluation</li></ul></li><li><p>Queue:</p><ul><li>First-In-First-Out (FIFO) structure</li><li>Enqueue (insert) at rear, dequeue (remove) from front</li><li>Used for task scheduling, breadth-first search</li></ul></li></ul><h2 id=what-is-a-binary-search-tree>What is a binary search tree?<a hidden class=anchor aria-hidden=true href=#what-is-a-binary-search-tree>#</a></h2><p>A binary search tree is a binary tree data structure where each node has at most two children, referred to as the left child and the right child. For each node:</p><ul><li>All nodes in the left subtree have values less than the node&rsquo;s value</li><li>All nodes in the right subtree have values greater than the node&rsquo;s value</li></ul><p>This property allows for efficient searching, insertion, and deletion operations.</p><h2 id=explain-the-concept-of-hashing-and-hash-tables>Explain the concept of hashing and hash tables.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-hashing-and-hash-tables>#</a></h2><p>Hashing is a technique used to uniquely identify a specific object from a group of similar objects. It involves using a hash function to map keys to indices of an array (hash table).</p><p>Hash Table:</p><ul><li>Data structure that implements an associative array abstract data type</li><li>Uses a hash function to compute an index into an array of buckets or slots</li></ul><h2 id=what-is-a-balanced-tree-and-why-is-it-important>What is a balanced tree and why is it important?<a hidden class=anchor aria-hidden=true href=#what-is-a-balanced-tree-and-why-is-it-important>#</a></h2><p>A balanced tree is a binary tree structure in which the left and right subtrees of every node differ in height by no more than one. Examples include AVL trees and Red-Black trees.</p><p>Importance:</p><ul><li>Ensures O(log n) time complexity for operations like insertion, deletion, and search</li><li>Prevents degeneration into a linked list, which would result in O(n) time complexity</li></ul><h2 id=explain-the-difference-between-dfs-and-bfs>Explain the difference between DFS and BFS.<a hidden class=anchor aria-hidden=true href=#explain-the-difference-between-dfs-and-bfs>#</a></h2><ul><li><p>Depth-First Search (DFS):</p><ul><li>Explores as far as possible along each branch before backtracking</li><li>Uses a stack (or recursion)</li><li>Memory efficient for trees</li><li>Can get trapped in infinite loops for graphs</li></ul></li><li><p>Breadth-First Search (BFS):</p><ul><li>Explores all the neighbor nodes at the present depth prior to moving to nodes at the next depth level</li><li>Uses a queue</li><li>Finds the shortest path in unweighted graphs</li><li>Can be memory-intensive</li></ul></li></ul><h2 id=what-is-a-heap-data-structure>What is a heap data structure?<a hidden class=anchor aria-hidden=true href=#what-is-a-heap-data-structure>#</a></h2><p>A heap is a specialized tree-based data structure that satisfies the heap property:</p><ul><li>In a max heap, for any given node C, if P is a parent node of C, then the key of P is greater than or equal to the key of C</li><li>In a min heap, the key of P is less than or equal to the key of C</li></ul><p>Heaps are commonly used to implement priority queues and in sorting algorithms like heapsort.</p><h2 id=explain-the-concept-of-dynamic-programming>Explain the concept of dynamic programming.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-dynamic-programming>#</a></h2><p>Dynamic programming is both a mathematical optimization method and a computer programming method. It works by breaking down a complex problem into simpler subproblems in a recursive manner.</p><p>Characteristics:</p><ul><li>Overlapping Subproblems</li><li>Optimal Substructure</li></ul><p>Common examples:</p><ul><li>Fibonacci sequence</li><li>Longest Common Subsequence</li><li>Knapsack problem</li></ul><h2 id=what-is-a-trie-and-what-is-it-used-for>What is a trie and what is it used for?<a hidden class=anchor aria-hidden=true href=#what-is-a-trie-and-what-is-it-used-for>#</a></h2><p>A trie, also called digital tree or prefix tree, is a kind of search tree—an ordered tree data structure used to store a dynamic set or associative array where the keys are usually strings.</p><p>Uses:</p><ul><li>Autocomplete</li><li>Spell checkers</li><li>IP routing tables</li><li>Solving word games</li></ul><h2 id=explain-the-concept-of-a-self-balancing-tree>Explain the concept of a self-balancing tree.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-a-self-balancing-tree>#</a></h2><p>A self-balancing tree is a type of binary search tree that automatically keeps its height small in the face of arbitrary insertions and deletions. This ensures that operations like search, insert, and delete take O(log n) time.</p><p>Examples:</p><ul><li>AVL trees</li><li>Red-Black trees</li><li>Splay trees</li></ul><p>These trees use rotations to maintain balance after insertions and deletions.</p><h2 id=what-is-the-time-complexity-of-common-operations-in-different-data-structures>What is the time complexity of common operations in different data structures?<a hidden class=anchor aria-hidden=true href=#what-is-the-time-complexity-of-common-operations-in-different-data-structures>#</a></h2><ul><li><p>Array:</p><ul><li>Access: O(1)</li><li>Search: O(n)</li><li>Insertion: O(n)</li><li>Deletion: O(n)</li></ul></li><li><p>Linked List:</p><ul><li>Access: O(n)</li><li>Search: O(n)</li><li>Insertion: O(1)</li><li>Deletion: O(1)</li></ul></li><li><p>Binary Search Tree (balanced):</p><ul><li>Search: O(log n)</li><li>Insertion: O(log n)</li><li>Deletion: O(log n)</li></ul></li><li><p>Hash Table:</p><ul><li>Search: O(1) average, O(n) worst</li><li>Insertion: O(1) average, O(n) worst</li><li>Deletion: O(1) average, O(n) worst</li></ul></li></ul><h2 id=explain-the-concept-of-a-graph-and-its-representations>Explain the concept of a graph and its representations.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-a-graph-and-its-representations>#</a></h2><p>A graph is a non-linear data structure consisting of nodes and edges. The nodes are sometimes also referred to as vertices and the edges are lines or arcs that connect any two nodes in the graph.</p><p>Representations:</p><ul><li>Adjacency Matrix: 2D array of size V x V where V is the number of vertices</li><li>Adjacency List: Array of linked lists</li><li>Edge List: List of all edges in the graph</li></ul><h2 id=what-is-the-difference-between-a-min-heap-and-a-max-heap>What is the difference between a min-heap and a max-heap?<a hidden class=anchor aria-hidden=true href=#what-is-the-difference-between-a-min-heap-and-a-max-heap>#</a></h2><ul><li><p>Min-Heap:</p><ul><li>The root node has the minimum value</li><li>For any given node C, if P is a parent node of C, then the key of P is less than or equal to the key of C</li></ul></li><li><p>Max-Heap:</p><ul><li>The root node has the maximum value</li><li>For any given node C, if P is a parent node of C, then the key of P is greater than or equal to the key of C</li></ul></li></ul><p>Both are commonly used to implement priority queues.</p><h2 id=explain-the-concept-of-a-b-tree>Explain the concept of a B-tree.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-a-b-tree>#</a></h2><p>A B-tree is a self-balancing tree data structure that maintains sorted data and allows searches, sequential access, insertions, and deletions in logarithmic time. It is optimized for systems that read and write large blocks of data.</p><p>Properties:</p><ul><li>All leaves are at the same level</li><li>A non-leaf node with k children contains k-1 keys</li><li>Each node (except root) must contain at least t-1 keys, where t is the minimum degree of B-tree</li><li>All nodes may contain at most 2t-1 keys</li></ul><p>B-trees are commonly used in databases and file systems.</p><h2 id=what-is-a-skip-list>What is a skip list?<a hidden class=anchor aria-hidden=true href=#what-is-a-skip-list>#</a></h2><p>A skip list is a probabilistic data structure that allows O(log n) search complexity as well as O(log n) insertion complexity within an ordered sequence of elements. It is created from a linked list by adding multiple layers of header nodes.</p><p>Advantages:</p><ul><li>Performs as well as balanced trees</li><li>Simpler to implement than balanced tree structures</li></ul><p><img loading=lazy src=/img/0_data_structure_interview.png alt></p><h2 id=explain-the-difference-between-internal-and-external-sorting>Explain the difference between internal and external sorting.<a hidden class=anchor aria-hidden=true href=#explain-the-difference-between-internal-and-external-sorting>#</a></h2><ul><li><p>Internal Sorting:</p><ul><li>All data to be sorted is held in main memory</li><li>Faster but limited by available RAM</li><li>Examples: Quicksort, Mergesort, Heapsort</li></ul></li><li><p>External Sorting:</p><ul><li>Used when data doesn&rsquo;t fit into main memory and must reside in slower external memory (like a hard drive)</li><li>Involves multiple steps, often using merge sort</li><li>Example: External merge sort</li></ul></li></ul><h2 id=what-is-a-bloom-filter>What is a bloom filter?<a hidden class=anchor aria-hidden=true href=#what-is-a-bloom-filter>#</a></h2><p><a href=computer_science/06_system_design/boom_filters.md>boom_filters</a></p><h2 id=explain-the-concept-of-a-disjoint-set-data-structure>Explain the concept of a disjoint-set data structure.<a hidden class=anchor aria-hidden=true href=#explain-the-concept-of-a-disjoint-set-data-structure>#</a></h2><p>A disjoint-set data structure, also called a union-find data structure, keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.</p><p>Operations:</p><ul><li>Find: Determine which subset a particular element is in</li><li>Union: Join two subsets into a single subset</li></ul><p>Uses:</p><ul><li>Kruskal&rsquo;s algorithm for finding minimum spanning trees</li><li>Detecting cycles in graphs</li></ul><p>Path compression optimization
<img loading=lazy src=/img/0_data_structure_interview-1.png alt></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/datastructure/>DataStructure</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>