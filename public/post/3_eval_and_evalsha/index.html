<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Eval and Evalsha - Kaga Blog</title>
<meta name=theme-color><meta name=description content="Overview
EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server.  They differ primarily in how they handle script loading and execution:


EVAL: This command takes the Lua script as an argument.  Redis parses and hashes the script every time EVAL is called.  This adds overhead, especially for frequently executed scripts.


EVALSHA: This command takes the SHA1 hash of the Lua script as an argument.  Redis retrieves the script from its internal cache using this hash.  If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps.  This results in significantly faster execution times for frequently used scripts."><meta name=author content="Kaga Blog"><link rel="preload stylesheet" as=style href=https://bleedkagax.github.io/main.min.css><link rel=preload as=image href=https://bleedkagax.github.io/theme.png><script defer src=https://bleedkagax.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.0"><meta itemprop=name content="Eval and Evalsha"><meta itemprop=description content="Overview EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:
EVAL: This command takes the Lua script as an argument. Redis parses and hashes the script every time EVAL is called. This adds overhead, especially for frequently executed scripts.
EVALSHA: This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it’s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts."><meta itemprop=datePublished content="2024-10-02T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-02T00:00:00+00:00"><meta itemprop=wordCount content="359"><meta itemprop=keywords content="Redis"><meta property="og:url" content="https://bleedkagax.github.io/post/3_eval_and_evalsha/"><meta property="og:site_name" content="Kaga Blog"><meta property="og:title" content="Eval and Evalsha"><meta property="og:description" content="Overview EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:
EVAL: This command takes the Lua script as an argument. Redis parses and hashes the script every time EVAL is called. This adds overhead, especially for frequently executed scripts.
EVALSHA: This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it’s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-02T00:00:00+00:00"><meta property="article:tag" content="Redis"><meta name=twitter:card content="summary"><meta name=twitter:title content="Eval and Evalsha"><meta name=twitter:description content="Overview EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:
EVAL: This command takes the Lua script as an argument. Redis parses and hashes the script every time EVAL is called. This adds overhead, especially for frequently executed scripts.
EVALSHA: This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it’s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts."><link rel=canonical href=https://bleedkagax.github.io/post/3_eval_and_evalsha/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://bleedkagax.github.io/>Kaga Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Eval and Evalsha</h1><div class="text-xs antialiased opacity-60"><time>Oct 2, 2024</time></div></header><section><h1 id=overview>Overview</h1><p><code>EVAL</code> and <code>EVALSHA</code> are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:</p><ul><li><p><strong><code>EVAL</code>:</strong> This command takes the Lua script as an argument. Redis parses and hashes the script every time <code>EVAL</code> is called. This adds overhead, especially for frequently executed scripts.</p></li><li><p><strong><code>EVALSHA</code>:</strong> This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts.</p></li></ul><h1 id=key-differences-summarized>Key Differences Summarized</h1><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left><code>EVAL</code></th><th style=text-align:left><code>EVALSHA</code></th></tr></thead><tbody><tr><td style=text-align:left>Script Input</td><td style=text-align:left>Lua script as a string</td><td style=text-align:left>SHA1 hash of the Lua script</td></tr><tr><td style=text-align:left>Script Parsing</td><td style=text-align:left>Parses and hashes the script each time</td><td style=text-align:left>Retrieves from cache; no parsing</td></tr><tr><td style=text-align:left>Performance</td><td style=text-align:left>Slower, especially for frequent use</td><td style=text-align:left>Faster for frequently used scripts</td></tr><tr><td style=text-align:left>Script Cache</td><td style=text-align:left>No reliance on script cache</td><td style=text-align:left>Relies on script cache; error if miss</td></tr><tr><td style=text-align:left>Error Handling</td><td style=text-align:left>No specific error for cache miss</td><td style=text-align:left>Returns error if script not in cache</td></tr></tbody></table><h1 id=when-to-use-which>When to Use Which</h1><ul><li><p><strong><code>EVAL</code>:</strong> Use for testing, debugging, or scripts that are executed infrequently. It&rsquo;s simpler to use since you don&rsquo;t need to manage script hashes.</p></li><li><p><strong><code>EVALSHA</code>:</strong> Use for frequently executed scripts to optimize performance. This requires a prior step to load the script using <code>SCRIPT LOAD</code> to obtain its SHA1 hash.</p></li></ul><h1 id=example>Example</h1><p>Let&rsquo;s say you have a Lua script to increment a counter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>redis.call(<span style=color:#e6db74>&#39;INCR&#39;</span>, KEYS[<span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><ol><li><strong>Using <code>EVAL</code>:</strong></li></ol><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>EVAL &#34;redis.call(&#39;INCR&#39;, KEYS[1])&#34; 1 mykey
</code></pre><ol start=2><li><strong>Using <code>EVALSHA</code>:</strong></li></ol><p>a. <strong>Load the script and get the SHA1 hash:</strong></p><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>SCRIPT LOAD &#34;redis.call(&#39;INCR&#39;, KEYS[1])&#34;
</code></pre><p>Redis computes the script&rsquo;s SHA1 hash and stores both the script and its hash in an internal cache.</p><p>This returns the SHA1 hash (e.g., <code>a1b2c3d4e5f6...</code>).</p><p>b. <strong>Execute using the hash:</strong></p><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>EVALSHA a1b2c3d4e5f6... 1 mykey
</code></pre><p>Remember to replace <code>a1b2c3d4e5f6...</code> with the actual SHA1 hash. <code>EVALSHA</code> will be significantly faster if this script is executed repeatedly. However, if the script is not in the cache, <code>EVALSHA</code> will fail. Therefore, robust error handling is crucial in production environments. A common strategy is to use <code>EVALSHA</code> first and fall back to <code>EVAL</code> if it fails.</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://bleedkagax.github.io/tags/redis>Redis</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://bleedkagax.github.io/post/2_mysql_isolation_levels/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>MySQL's Transaction Isolation Levels</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://bleedkagax.github.io/post/8_go_memory_allocation/><span>Go Memory Allocation</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid [&_svg]:block [&_svg]:m-auto">${e.innerHTML}</div>`})</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://bleedkagax.github.io/>Kaga Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>