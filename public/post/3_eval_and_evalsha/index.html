<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Eval and Evalsha | Kaga Blog</title>
<meta name=keywords content="Redis"><meta name=description content="Overview
EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server.  They differ primarily in how they handle script loading and execution:


EVAL: This command takes the Lua script as an argument.  Redis parses and hashes the script every time EVAL is called.  This adds overhead, especially for frequently executed scripts.


EVALSHA: This command takes the SHA1 hash of the Lua script as an argument.  Redis retrieves the script from its internal cache using this hash.  If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps.  This results in significantly faster execution times for frequently used scripts."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/3_eval_and_evalsha/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/3_eval_and_evalsha/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Eval and Evalsha"><meta property="og:description" content="Overview
EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server.  They differ primarily in how they handle script loading and execution:


EVAL: This command takes the Lua script as an argument.  Redis parses and hashes the script every time EVAL is called.  This adds overhead, especially for frequently executed scripts.


EVALSHA: This command takes the SHA1 hash of the Lua script as an argument.  Redis retrieves the script from its internal cache using this hash.  If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps.  This results in significantly faster execution times for frequently used scripts."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/3_eval_and_evalsha/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-02T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Eval and Evalsha"><meta name=twitter:description content="Overview
EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server.  They differ primarily in how they handle script loading and execution:


EVAL: This command takes the Lua script as an argument.  Redis parses and hashes the script every time EVAL is called.  This adds overhead, especially for frequently executed scripts.


EVALSHA: This command takes the SHA1 hash of the Lua script as an argument.  Redis retrieves the script from its internal cache using this hash.  If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps.  This results in significantly faster execution times for frequently used scripts."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Eval and Evalsha","item":"https://bleedkagax.github.io/post/3_eval_and_evalsha/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Eval and Evalsha","name":"Eval and Evalsha","description":"Overview EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:\nEVAL: This command takes the Lua script as an argument. Redis parses and hashes the script every time EVAL is called. This adds overhead, especially for frequently executed scripts.\nEVALSHA: This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it\u0026rsquo;s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts.\n","keywords":["Redis"],"articleBody":"Overview EVAL and EVALSHA are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:\nEVAL: This command takes the Lua script as an argument. Redis parses and hashes the script every time EVAL is called. This adds overhead, especially for frequently executed scripts.\nEVALSHA: This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it’s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts.\nKey Differences Summarized Feature EVAL EVALSHA Script Input Lua script as a string SHA1 hash of the Lua script Script Parsing Parses and hashes the script each time Retrieves from cache; no parsing Performance Slower, especially for frequent use Faster for frequently used scripts Script Cache No reliance on script cache Relies on script cache; error if miss Error Handling No specific error for cache miss Returns error if script not in cache When to Use Which EVAL: Use for testing, debugging, or scripts that are executed infrequently. It’s simpler to use since you don’t need to manage script hashes.\nEVALSHA: Use for frequently executed scripts to optimize performance. This requires a prior step to load the script using SCRIPT LOAD to obtain its SHA1 hash.\nExample Let’s say you have a Lua script to increment a counter:\nredis.call('INCR', KEYS[1]) Using EVAL: EVAL \"redis.call('INCR', KEYS[1])\" 1 mykey Using EVALSHA: a. Load the script and get the SHA1 hash:\nSCRIPT LOAD \"redis.call('INCR', KEYS[1])\" Redis computes the script’s SHA1 hash and stores both the script and its hash in an internal cache.\nThis returns the SHA1 hash (e.g., a1b2c3d4e5f6...).\nb. Execute using the hash:\nEVALSHA a1b2c3d4e5f6... 1 mykey Remember to replace a1b2c3d4e5f6... with the actual SHA1 hash. EVALSHA will be significantly faster if this script is executed repeatedly. However, if the script is not in the cache, EVALSHA will fail. Therefore, robust error handling is crucial in production environments. A common strategy is to use EVALSHA first and fall back to EVAL if it fails.\n","wordCount":"359","inLanguage":"en","datePublished":"2024-10-02T00:00:00Z","dateModified":"2024-10-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/3_eval_and_evalsha/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Eval and Evalsha</h1><div class=post-meta><span title='2024-10-02 00:00:00 +0000 UTC'>October 2, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#overview aria-label=Overview>Overview</a></li><li><a href=#key-differences-summarized aria-label="Key Differences Summarized">Key Differences Summarized</a></li><li><a href=#when-to-use-which aria-label="When to Use Which">When to Use Which</a></li><li><a href=#example aria-label=Example>Example</a></li></ul></div></details></div><div class=post-content><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p><code>EVAL</code> and <code>EVALSHA</code> are Redis commands used to execute Lua scripts within the Redis server. They differ primarily in how they handle script loading and execution:</p><ul><li><p><strong><code>EVAL</code>:</strong> This command takes the Lua script as an argument. Redis parses and hashes the script every time <code>EVAL</code> is called. This adds overhead, especially for frequently executed scripts.</p></li><li><p><strong><code>EVALSHA</code>:</strong> This command takes the SHA1 hash of the Lua script as an argument. Redis retrieves the script from its internal cache using this hash. If the script is found, it&rsquo;s executed directly, bypassing the parsing and hashing steps. This results in significantly faster execution times for frequently used scripts.</p></li></ul><h1 id=key-differences-summarized>Key Differences Summarized<a hidden class=anchor aria-hidden=true href=#key-differences-summarized>#</a></h1><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left><code>EVAL</code></th><th style=text-align:left><code>EVALSHA</code></th></tr></thead><tbody><tr><td style=text-align:left>Script Input</td><td style=text-align:left>Lua script as a string</td><td style=text-align:left>SHA1 hash of the Lua script</td></tr><tr><td style=text-align:left>Script Parsing</td><td style=text-align:left>Parses and hashes the script each time</td><td style=text-align:left>Retrieves from cache; no parsing</td></tr><tr><td style=text-align:left>Performance</td><td style=text-align:left>Slower, especially for frequent use</td><td style=text-align:left>Faster for frequently used scripts</td></tr><tr><td style=text-align:left>Script Cache</td><td style=text-align:left>No reliance on script cache</td><td style=text-align:left>Relies on script cache; error if miss</td></tr><tr><td style=text-align:left>Error Handling</td><td style=text-align:left>No specific error for cache miss</td><td style=text-align:left>Returns error if script not in cache</td></tr></tbody></table><h1 id=when-to-use-which>When to Use Which<a hidden class=anchor aria-hidden=true href=#when-to-use-which>#</a></h1><ul><li><p><strong><code>EVAL</code>:</strong> Use for testing, debugging, or scripts that are executed infrequently. It&rsquo;s simpler to use since you don&rsquo;t need to manage script hashes.</p></li><li><p><strong><code>EVALSHA</code>:</strong> Use for frequently executed scripts to optimize performance. This requires a prior step to load the script using <code>SCRIPT LOAD</code> to obtain its SHA1 hash.</p></li></ul><h1 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h1><p>Let&rsquo;s say you have a Lua script to increment a counter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>redis.call(<span style=color:#e6db74>&#39;INCR&#39;</span>, KEYS[<span style=color:#ae81ff>1</span>])
</span></span></code></pre></div><ol><li><strong>Using <code>EVAL</code>:</strong></li></ol><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>EVAL &#34;redis.call(&#39;INCR&#39;, KEYS[1])&#34; 1 mykey
</code></pre><ol start=2><li><strong>Using <code>EVALSHA</code>:</strong></li></ol><p>a. <strong>Load the script and get the SHA1 hash:</strong></p><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>SCRIPT LOAD &#34;redis.call(&#39;INCR&#39;, KEYS[1])&#34;
</code></pre><p>Redis computes the script&rsquo;s SHA1 hash and stores both the script and its hash in an internal cache.</p><p>This returns the SHA1 hash (e.g., <code>a1b2c3d4e5f6...</code>).</p><p>b. <strong>Execute using the hash:</strong></p><pre tabindex=0><code class=language-redis-cli data-lang=redis-cli>EVALSHA a1b2c3d4e5f6... 1 mykey
</code></pre><p>Remember to replace <code>a1b2c3d4e5f6...</code> with the actual SHA1 hash. <code>EVALSHA</code> will be significantly faster if this script is executed repeatedly. However, if the script is not in the cache, <code>EVALSHA</code> will fail. Therefore, robust error handling is crucial in production environments. A common strategy is to use <code>EVALSHA</code> first and fall back to <code>EVAL</code> if it fails.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/redis/>Redis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>