<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go's GMP Model | Kaga Blog</title>
<meta name=keywords content="Golang"><meta name=description content="What is the GPM model in Go?
GMP Model
The GMP model is the cornerstone of Go&rsquo;s runtime scheduler.


G (Goroutine):

Represents a goroutine, which is a lightweight thread of execution.
Contains the stack, the instruction pointer, and other information important for scheduling.
Many Gs can exist at the same time.



P (Processor):

Represents a logical processor, which can be thought of as a context for scheduling.
Acts as a local scheduler, managing a queue of runnable goroutines.
The number of Ps is typically equal to GOMAXPROCS, which by default is the number of CPU cores available.



M (Machine):"><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/7_go_gmp_model/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/7_go_gmp_model/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go's GMP Model"><meta property="og:description" content="What is the GPM model in Go?
GMP Model
The GMP model is the cornerstone of Go&rsquo;s runtime scheduler.


G (Goroutine):

Represents a goroutine, which is a lightweight thread of execution.
Contains the stack, the instruction pointer, and other information important for scheduling.
Many Gs can exist at the same time.



P (Processor):

Represents a logical processor, which can be thought of as a context for scheduling.
Acts as a local scheduler, managing a queue of runnable goroutines.
The number of Ps is typically equal to GOMAXPROCS, which by default is the number of CPU cores available.



M (Machine):"><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/7_go_gmp_model/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go's GMP Model"><meta name=twitter:description content="What is the GPM model in Go?
GMP Model
The GMP model is the cornerstone of Go&rsquo;s runtime scheduler.


G (Goroutine):

Represents a goroutine, which is a lightweight thread of execution.
Contains the stack, the instruction pointer, and other information important for scheduling.
Many Gs can exist at the same time.



P (Processor):

Represents a logical processor, which can be thought of as a context for scheduling.
Acts as a local scheduler, managing a queue of runnable goroutines.
The number of Ps is typically equal to GOMAXPROCS, which by default is the number of CPU cores available.



M (Machine):"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Go's GMP Model","item":"https://bleedkagax.github.io/post/7_go_gmp_model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go's GMP Model","name":"Go\u0027s GMP Model","description":"What is the GPM model in Go? GMP Model The GMP model is the cornerstone of Go\u0026rsquo;s runtime scheduler.\nG (Goroutine):\nRepresents a goroutine, which is a lightweight thread of execution. Contains the stack, the instruction pointer, and other information important for scheduling. Many Gs can exist at the same time. P (Processor):\nRepresents a logical processor, which can be thought of as a context for scheduling. Acts as a local scheduler, managing a queue of runnable goroutines. The number of Ps is typically equal to GOMAXPROCS, which by default is the number of CPU cores available. M (Machine):\n","keywords":["Golang"],"articleBody":"What is the GPM model in Go? GMP Model The GMP model is the cornerstone of Go’s runtime scheduler.\nG (Goroutine):\nRepresents a goroutine, which is a lightweight thread of execution. Contains the stack, the instruction pointer, and other information important for scheduling. Many Gs can exist at the same time. P (Processor):\nRepresents a logical processor, which can be thought of as a context for scheduling. Acts as a local scheduler, managing a queue of runnable goroutines. The number of Ps is typically equal to GOMAXPROCS, which by default is the number of CPU cores available. M (Machine):\nRepresents an OS thread. The Go runtime manages a pool of Ms. Ms execute the code of runnable goroutines. graph TD G[Goroutine] --\u003e P[Processor] P --\u003e M[Machine] M --\u003e OS[Operating System] subgraph \"GMP Model\" G P M end OS Goroutine Scheduling flowchart TD GRQ[Global Run Queue] --\u003e |schedule| P1[Processor P1] GRQ --\u003e |schedule| P2[Processor P2] P1 --\u003e |run| G1[Goroutine 1] P1 --\u003e |run| G2[Goroutine 2] P2 --\u003e |run| G3[Goroutine 3] P2 --\u003e |run| G4[Goroutine 4] P1 -.-\u003e |work stealing| P2 P2 -.-\u003e |work stealing| P1 M1[Machine M1] --\u003e P1 M2[Machine M2] --\u003e P2 G5[New Goroutine] -.-\u003e |enqueue| GRQ G6[Blocked Goroutine] -.-\u003e |wake up| GRQ Scheduler Data Structures Global Run Queue (GRQ)\nHolds runnable goroutines not assigned to any P Represented by sched.runq in the runtime Used when local run queues are full or during work stealing Implemented as a lock-free ring buffer Local Run Queue (LRQ)\nEach P has its own LRQ Holds goroutines assigned to that P Implemented as a circular queue with a fixed size of 256 When full, half of the goroutines are moved to the GRQ Idle M List\nTracks idle OS threads Managed by the scheduler Used to quickly find an M when a goroutine becomes runnable Idle P List\nMaintains idle P structures Used when allocating P to new M Helps in quick P acquisition for waiting Ms Scheduling Algorithm When a new goroutine is created:\nIf there’s space in the current P’s local run queue, add it there Otherwise, add it to the global run queue When a P needs to find a goroutine to run:\nCheck its local run queue first If empty, check the global run queue If still empty, try to steal work from other Ps When a goroutine blocks (e.g., on I/O or channel operations):\nThe current M will detach from its P Another M will pick up the P and continue running goroutines When a goroutine unblocks:\nIt’s placed back on a run queue (local or global) If there’s an idle P, it may be scheduled immediately Advanced Scheduling Concepts Preemption Go uses a combination of cooperative and preemptive scheduling:\nCooperative Scheduling\nGoroutines yield control at certain points (e.g., function calls, channel operations) Implemented through checks in the compiler-generated code Preemptive Scheduling\nIntroduced in Go 1.14 for long-running goroutines Uses asynchronous preemption via signals (SIGURG on Unix systems) Allows interruption of CPU-bound goroutines Work Stealing Work stealing is a technique used by the Go scheduler to balance load across processors:\nWhen a P’s local run queue is empty, it attempts to steal work from other Ps The stealing process is randomized to avoid contention If stealing fails, the P checks the global run queue and network poller Implementation details:\nUses a random starting point to avoid always stealing from the same P Steals half of the victim’s local run queue to minimize future stealing Syscall Handling When a goroutine makes a syscall, special handling is required to ensure efficient use of resources:\nThe M running the goroutine enters syscall mode The P is detached from the M to allow other goroutines to run If there are no idle Ms, a new M may be created to run the P When the syscall completes, the goroutine is rescheduled Spinning Threads The Go scheduler uses spinning threads to reduce latency:\nSome Ms may spin instead of going to sleep immediately Spinning Ms check for new work frequently This helps in quickly responding to newly runnable goroutines The number of spinning Ms is limited to avoid wasting CPU Spinning states:\nSpinning looking for work Spinning waiting for GRQ lock Runtime Hooks and Tracing Go provides several hooks and tracing capabilities for advanced scheduling analysis:\nRuntime Tracing\nEnabled with runtime/trace package Provides detailed information about goroutine scheduling, GC, and more Scheduler Tracing\nEnabled with GODEBUG=schedtrace=X environment variable Prints scheduler state every X milliseconds Execution Tracing\nUses runtime.Trace() and runtime.StopTrace() functions Allows for custom tracing points in code Example of using runtime tracing:\npackage main import ( \"os\" \"runtime/trace\" ) func main() { // Create a trace file f, err := os.Create(\"trace.out\") if err != nil { panic(err) } defer f.Close() // Start tracing err = trace.Start(f) if err != nil { panic(err) } defer trace.Stop() // Your program logic here for i := 0; i \u003c 10; i++ { go func() { // Some work }() } // Wait for goroutines to finish // ... } To analyze the trace:\ngo tool trace trace.out ","wordCount":"841","inLanguage":"en","datePublished":"2024-10-01T00:00:00Z","dateModified":"2024-10-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/7_go_gmp_model/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go's GMP Model</h1><div class=post-meta><span title='2024-10-01 00:00:00 +0000 UTC'>October 1, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-the-gpm-model-in-go aria-label="What is the GPM model in Go?">What is the GPM model in Go?</a><ul><li><a href=#gmp-model aria-label="GMP Model">GMP Model</a></li><li><a href=#goroutine-scheduling aria-label="Goroutine Scheduling">Goroutine Scheduling</a><ul><li><a href=#scheduler-data-structures aria-label="Scheduler Data Structures">Scheduler Data Structures</a></li><li><a href=#scheduling-algorithm aria-label="Scheduling Algorithm">Scheduling Algorithm</a></li></ul></li><li><a href=#advanced-scheduling-concepts aria-label="Advanced Scheduling Concepts">Advanced Scheduling Concepts</a><ul><li><a href=#preemption aria-label=Preemption>Preemption</a></li><li><a href=#work-stealing aria-label="Work Stealing">Work Stealing</a></li><li><a href=#syscall-handling aria-label="Syscall Handling">Syscall Handling</a></li><li><a href=#spinning-threads aria-label="Spinning Threads">Spinning Threads</a></li></ul></li><li><a href=#runtime-hooks-and-tracing aria-label="Runtime Hooks and Tracing">Runtime Hooks and Tracing</a></li></ul></li></ul></div></details></div><div class=post-content><h3 id=what-is-the-gpm-model-in-go>What is the GPM model in Go?<a hidden class=anchor aria-hidden=true href=#what-is-the-gpm-model-in-go>#</a></h3><h4 id=gmp-model>GMP Model<a hidden class=anchor aria-hidden=true href=#gmp-model>#</a></h4><p>The GMP model is the cornerstone of Go&rsquo;s runtime scheduler.</p><ol><li><p><strong>G (Goroutine)</strong>:</p><ul><li>Represents a goroutine, which is a lightweight thread of execution.</li><li>Contains the stack, the instruction pointer, and other information important for scheduling.</li><li>Many Gs can exist at the same time.</li></ul></li><li><p><strong>P (Processor)</strong>:</p><ul><li>Represents a logical processor, which can be thought of as a context for scheduling.</li><li>Acts as a local scheduler, managing a queue of runnable goroutines.</li><li>The number of Ps is typically equal to <code>GOMAXPROCS</code>, which by default is the number of CPU cores available.</li></ul></li><li><p><strong>M (Machine)</strong>:</p><ul><li>Represents an OS thread.</li><li>The Go runtime manages a pool of Ms.</li><li>Ms execute the code of runnable goroutines.</li></ul></li></ol><pre class=mermaid>
    graph TD
	    G[Goroutine] --&gt; P[Processor]
	    P --&gt; M[Machine]
	    M --&gt; OS[Operating System]
	    
	    subgraph &#34;GMP Model&#34;
	    G
	    P
	    M
	    end
	    
	    OS
</pre><h4 id=goroutine-scheduling>Goroutine Scheduling<a hidden class=anchor aria-hidden=true href=#goroutine-scheduling>#</a></h4><pre class=mermaid>
    flowchart TD
	    GRQ[Global Run Queue] --&gt; |schedule| P1[Processor P1]
	    GRQ --&gt; |schedule| P2[Processor P2]
	    P1 --&gt; |run| G1[Goroutine 1]
	    P1 --&gt; |run| G2[Goroutine 2]
	    P2 --&gt; |run| G3[Goroutine 3]
	    P2 --&gt; |run| G4[Goroutine 4]
	    P1 -.-&gt; |work stealing| P2
	    P2 -.-&gt; |work stealing| P1
	    M1[Machine M1] --&gt; P1
	    M2[Machine M2] --&gt; P2
	    G5[New Goroutine] -.-&gt; |enqueue| GRQ
	    G6[Blocked Goroutine] -.-&gt; |wake up| GRQ
</pre><h5 id=scheduler-data-structures>Scheduler Data Structures<a hidden class=anchor aria-hidden=true href=#scheduler-data-structures>#</a></h5><ol><li><p><strong>Global Run Queue (GRQ)</strong></p><ul><li>Holds runnable goroutines not assigned to any P</li><li>Represented by <code>sched.runq</code> in the runtime</li><li>Used when local run queues are full or during work stealing</li><li>Implemented as a lock-free ring buffer</li></ul></li><li><p><strong>Local Run Queue (LRQ)</strong></p><ul><li>Each P has its own LRQ</li><li>Holds goroutines assigned to that P</li><li>Implemented as a circular queue with a fixed size of 256</li><li>When full, half of the goroutines are moved to the GRQ</li></ul></li><li><p><strong>Idle M List</strong></p><ul><li>Tracks idle OS threads</li><li>Managed by the scheduler</li><li>Used to quickly find an M when a goroutine becomes runnable</li></ul></li><li><p><strong>Idle P List</strong></p><ul><li>Maintains idle P structures</li><li>Used when allocating P to new M</li><li>Helps in quick P acquisition for waiting Ms</li></ul></li></ol><h5 id=scheduling-algorithm>Scheduling Algorithm<a hidden class=anchor aria-hidden=true href=#scheduling-algorithm>#</a></h5><ol><li><p>When a new goroutine is created:</p><ul><li>If there&rsquo;s space in the current P&rsquo;s local run queue, add it there</li><li>Otherwise, add it to the global run queue</li></ul></li><li><p>When a P needs to find a goroutine to run:</p><ul><li>Check its local run queue first</li><li>If empty, check the global run queue</li><li>If still empty, try to steal work from other Ps</li></ul></li><li><p>When a goroutine blocks (e.g., on I/O or channel operations):</p><ul><li>The current M will detach from its P</li><li>Another M will pick up the P and continue running goroutines</li></ul></li><li><p>When a goroutine unblocks:</p><ul><li>It&rsquo;s placed back on a run queue (local or global)</li><li>If there&rsquo;s an idle P, it may be scheduled immediately</li></ul></li></ol><h4 id=advanced-scheduling-concepts>Advanced Scheduling Concepts<a hidden class=anchor aria-hidden=true href=#advanced-scheduling-concepts>#</a></h4><h5 id=preemption>Preemption<a hidden class=anchor aria-hidden=true href=#preemption>#</a></h5><p>Go uses a combination of cooperative and preemptive scheduling:</p><ol><li><p><strong>Cooperative Scheduling</strong></p><ul><li>Goroutines yield control at certain points (e.g., function calls, channel operations)</li><li>Implemented through checks in the compiler-generated code</li></ul></li><li><p><strong>Preemptive Scheduling</strong></p><ul><li>Introduced in Go 1.14 for long-running goroutines</li><li>Uses asynchronous preemption via signals (SIGURG on Unix systems)</li><li>Allows interruption of CPU-bound goroutines</li></ul></li></ol><h5 id=work-stealing>Work Stealing<a hidden class=anchor aria-hidden=true href=#work-stealing>#</a></h5><p>Work stealing is a technique used by the Go scheduler to balance load across processors:</p><ol><li>When a P&rsquo;s local run queue is empty, it attempts to steal work from other Ps</li><li>The stealing process is randomized to avoid contention</li><li>If stealing fails, the P checks the global run queue and network poller</li></ol><p>Implementation details:</p><ul><li>Uses a random starting point to avoid always stealing from the same P</li><li>Steals half of the victim&rsquo;s local run queue to minimize future stealing</li></ul><h5 id=syscall-handling>Syscall Handling<a hidden class=anchor aria-hidden=true href=#syscall-handling>#</a></h5><p>When a goroutine makes a syscall, special handling is required to ensure efficient use of resources:</p><ol><li>The M running the goroutine enters syscall mode</li><li>The P is detached from the M to allow other goroutines to run</li><li>If there are no idle Ms, a new M may be created to run the P</li><li>When the syscall completes, the goroutine is rescheduled</li></ol><h5 id=spinning-threads>Spinning Threads<a hidden class=anchor aria-hidden=true href=#spinning-threads>#</a></h5><p>The Go scheduler uses spinning threads to reduce latency:</p><ol><li>Some Ms may spin instead of going to sleep immediately</li><li>Spinning Ms check for new work frequently</li><li>This helps in quickly responding to newly runnable goroutines</li><li>The number of spinning Ms is limited to avoid wasting CPU</li></ol><p>Spinning states:</p><ul><li>Spinning looking for work</li><li>Spinning waiting for GRQ lock</li></ul><h4 id=runtime-hooks-and-tracing>Runtime Hooks and Tracing<a hidden class=anchor aria-hidden=true href=#runtime-hooks-and-tracing>#</a></h4><p>Go provides several hooks and tracing capabilities for advanced scheduling analysis:</p><ol><li><p><strong>Runtime Tracing</strong></p><ul><li>Enabled with <code>runtime/trace</code> package</li><li>Provides detailed information about goroutine scheduling, GC, and more</li></ul></li><li><p><strong>Scheduler Tracing</strong></p><ul><li>Enabled with <code>GODEBUG=schedtrace=X</code> environment variable</li><li>Prints scheduler state every X milliseconds</li></ul></li><li><p><strong>Execution Tracing</strong></p><ul><li>Uses <code>runtime.Trace()</code> and <code>runtime.StopTrace()</code> functions</li><li>Allows for custom tracing points in code</li></ul></li></ol><p>Example of using runtime tracing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;runtime/trace&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create a trace file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#e6db74>&#34;trace.out&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Start tracing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>Stop</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Your program logic here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Some work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for goroutines to finish
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>To analyze the trace:</p><pre tabindex=0><code>go tool trace trace.out
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/golang/>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>