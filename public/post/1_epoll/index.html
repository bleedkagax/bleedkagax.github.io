<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Epoll | Kaga Blog</title>
<meta name=keywords content="OperatingSystem"><meta name=description content="epoll (Linux): An Efficient I/O Multiplexing Mechanism
epoll operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike select and poll which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.
Key Features and Functionality
The core functionality revolves around three system calls:


epoll_create(size): Creates an epoll instance and returns an epoll file descriptor.  While size was initially used to hint at the number of file descriptors, modern kernels largely ignore it."><meta name=author content><link rel=canonical href=https://bleedkagax.github.io/post/1_epoll/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bleedkagax.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bleedkagax.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><link rel=mask-icon href=https://bleedkagax.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bleedkagax.github.io/post/1_epoll/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Epoll"><meta property="og:description" content="epoll (Linux): An Efficient I/O Multiplexing Mechanism
epoll operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike select and poll which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.
Key Features and Functionality
The core functionality revolves around three system calls:


epoll_create(size): Creates an epoll instance and returns an epoll file descriptor.  While size was initially used to hint at the number of file descriptors, modern kernels largely ignore it."><meta property="og:type" content="article"><meta property="og:url" content="https://bleedkagax.github.io/post/1_epoll/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-10-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Epoll"><meta name=twitter:description content="epoll (Linux): An Efficient I/O Multiplexing Mechanism
epoll operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike select and poll which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.
Key Features and Functionality
The core functionality revolves around three system calls:


epoll_create(size): Creates an epoll instance and returns an epoll file descriptor.  While size was initially used to hint at the number of file descriptors, modern kernels largely ignore it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bleedkagax.github.io/post/"},{"@type":"ListItem","position":2,"name":"Epoll","item":"https://bleedkagax.github.io/post/1_epoll/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Epoll","name":"Epoll","description":"epoll (Linux): An Efficient I/O Multiplexing Mechanism epoll operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike select and poll which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.\nKey Features and Functionality The core functionality revolves around three system calls:\nepoll_create(size): Creates an epoll instance and returns an epoll file descriptor. While size was initially used to hint at the number of file descriptors, modern kernels largely ignore it.\n","keywords":["OperatingSystem"],"articleBody":"epoll (Linux): An Efficient I/O Multiplexing Mechanism epoll operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike select and poll which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.\nKey Features and Functionality The core functionality revolves around three system calls:\nepoll_create(size): Creates an epoll instance and returns an epoll file descriptor. While size was initially used to hint at the number of file descriptors, modern kernels largely ignore it.\nepoll_ctl(epfd, op, fd, event): Manages the set of file descriptors monitored by the epoll instance (epfd). op specifies the operation (ADD, MODIFY, or DELETE), fd is the file descriptor to manage, and event defines the events of interest (read, write, error, etc.).\nepoll_wait(epfd, events, maxevents, timeout): Waits for events on the registered file descriptors. It blocks until at least one event occurs or a timeout expires. events is a pre-allocated array where epoll_wait populates information about the triggered events. maxevents specifies the maximum number of events to return.\nScalability and Efficiency epoll’s efficiency stems from its use of a kernel-level data structure (often a red-black tree) to manage monitored file descriptors. This allows it to handle a massive number of descriptors with minimal performance degradation, a significant advantage over select and poll, which suffer from performance bottlenecks as the number of descriptors grows.\nEdge-Triggered vs. Level-Triggered epoll offers two triggering modes:\nLevel-triggered: epoll_wait returns an event as long as the condition (e.g., data available for reading) persists. If the application doesn’t process the event immediately, epoll_wait will continue to return it.\nEdge-triggered: epoll_wait only returns an event when the condition transitions from false to true. This is more efficient but requires careful handling to ensure no events are missed. The application must process all available data in a single epoll_wait cycle.\nUse Cases epoll is extensively used in high-performance network servers and applications requiring efficient management of numerous concurrent connections or I/O operations. Its scalability and event-driven nature make it a crucial component in many modern network architectures.\n","wordCount":"347","inLanguage":"en","datePublished":"2024-10-03T00:00:00Z","dateModified":"2024-10-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bleedkagax.github.io/post/1_epoll/"},"publisher":{"@type":"Organization","name":"Kaga Blog","logo":{"@type":"ImageObject","url":"https://bleedkagax.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bleedkagax.github.io/ accesskey=h title="Kaga Blog (Alt + H)">Kaga Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bleedkagax.github.io/post/ title=Posts><span>Posts</span></a></li><li><a href=https://bleedkagax.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://bleedkagax.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://bleedkagax.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://bleedkagax.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Epoll</h1><div class=post-meta><span title='2024-10-03 00:00:00 +0000 UTC'>October 3, 2024</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#epoll-linux-an-efficient-io-multiplexing-mechanism aria-label="epoll (Linux): An Efficient I/O Multiplexing Mechanism">epoll (Linux): An Efficient I/O Multiplexing Mechanism</a><ul><li><a href=#key-features-and-functionality aria-label="Key Features and Functionality">Key Features and Functionality</a></li><li><a href=#scalability-and-efficiency aria-label="Scalability and Efficiency">Scalability and Efficiency</a></li><li><a href=#edge-triggered-vs-level-triggered aria-label="Edge-Triggered vs. Level-Triggered">Edge-Triggered vs. Level-Triggered</a></li><li><a href=#use-cases aria-label="Use Cases">Use Cases</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=epoll-linux-an-efficient-io-multiplexing-mechanism><code>epoll</code> (Linux): An Efficient I/O Multiplexing Mechanism<a hidden class=anchor aria-hidden=true href=#epoll-linux-an-efficient-io-multiplexing-mechanism>#</a></h1><p><code>epoll</code> operates on an event-driven model, meaning it only notifies the application when an event occurs on a specific file descriptor, unlike <code>select</code> and <code>poll</code> which poll all descriptors regardless of activity. This drastically reduces overhead, especially when managing numerous connections.</p><h2 id=key-features-and-functionality>Key Features and Functionality<a hidden class=anchor aria-hidden=true href=#key-features-and-functionality>#</a></h2><p>The core functionality revolves around three system calls:</p><ol><li><p><strong><code>epoll_create(size)</code>:</strong> Creates an <code>epoll</code> instance and returns an <code>epoll</code> file descriptor. While <code>size</code> was initially used to hint at the number of file descriptors, modern kernels largely ignore it.</p></li><li><p><strong><code>epoll_ctl(epfd, op, fd, event)</code>:</strong> Manages the set of file descriptors monitored by the <code>epoll</code> instance (<code>epfd</code>). <code>op</code> specifies the operation (ADD, MODIFY, or DELETE), <code>fd</code> is the file descriptor to manage, and <code>event</code> defines the events of interest (read, write, error, etc.).</p></li><li><p><strong><code>epoll_wait(epfd, events, maxevents, timeout)</code>:</strong> Waits for events on the registered file descriptors. It blocks until at least one event occurs or a timeout expires. <code>events</code> is a pre-allocated array where <code>epoll_wait</code> populates information about the triggered events. <code>maxevents</code> specifies the maximum number of events to return.</p></li></ol><h2 id=scalability-and-efficiency>Scalability and Efficiency<a hidden class=anchor aria-hidden=true href=#scalability-and-efficiency>#</a></h2><p><code>epoll</code>&rsquo;s efficiency stems from its use of a kernel-level data structure (often a red-black tree) to manage monitored file descriptors. This allows it to handle a massive number of descriptors with minimal performance degradation, a significant advantage over <code>select</code> and <code>poll</code>, which suffer from performance bottlenecks as the number of descriptors grows.</p><h2 id=edge-triggered-vs-level-triggered>Edge-Triggered vs. Level-Triggered<a hidden class=anchor aria-hidden=true href=#edge-triggered-vs-level-triggered>#</a></h2><p><code>epoll</code> offers two triggering modes:</p><ul><li><p><strong>Level-triggered:</strong> <code>epoll_wait</code> returns an event as long as the condition (e.g., data available for reading) persists. If the application doesn&rsquo;t process the event immediately, <code>epoll_wait</code> will continue to return it.</p></li><li><p><strong>Edge-triggered:</strong> <code>epoll_wait</code> only returns an event when the condition <em>transitions</em> from false to true. This is more efficient but requires careful handling to ensure no events are missed. The application must process all available data in a single <code>epoll_wait</code> cycle.</p></li></ul><h2 id=use-cases>Use Cases<a hidden class=anchor aria-hidden=true href=#use-cases>#</a></h2><p><code>epoll</code> is extensively used in high-performance network servers and applications requiring efficient management of numerous concurrent connections or I/O operations. Its scalability and event-driven nature make it a crucial component in many modern network architectures.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bleedkagax.github.io/tags/operatingsystem/>OperatingSystem</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bleedkagax.github.io/>Kaga Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>(function(){var e=document.querySelectorAll("pre > code.language-mermaid");e.forEach(function(e){var t,n=e.parentElement;if(!n)return;t=document.createElement("div"),t.className="mermaid",t.textContent=e.textContent||"",n.replaceWith(t)})})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>