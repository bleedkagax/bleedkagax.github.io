<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go's Sync - Kaga Blog</title>
<meta name=theme-color><meta name=description content="sync.Mutex
// Mutex provides mutual exclusion for shared resources.
type Mutex struct {
    state int32   // State of the mutex (locked/unlocked)
    sema  uint32  // Semaphore for blocking goroutines
}

// Lock acquires the mutex, blocking if necessary.
func (m *Mutex) Lock() {
    // Check if already locked; if so, block until unlocked.
}

// Unlock releases the mutex.
func (m *Mutex) Unlock() {
    // Update state and unblock waiting goroutines if any.
}
"><meta name=author content="Kaga Blog"><link rel="preload stylesheet" as=style href=https://bleedkagax.github.io/main.min.css><link rel=preload as=image href=https://bleedkagax.github.io/theme.png><script defer src=https://bleedkagax.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://bleedkagax.github.io/favicon.ico><link rel=apple-touch-icon href=https://bleedkagax.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.134.0"><meta itemprop=name content="Go's Sync"><meta itemprop=description content="sync.Mutex // Mutex provides mutual exclusion for shared resources. type Mutex struct { state int32 // State of the mutex (locked/unlocked) sema uint32 // Semaphore for blocking goroutines } // Lock acquires the mutex, blocking if necessary. func (m *Mutex) Lock() { // Check if already locked; if so, block until unlocked. } // Unlock releases the mutex. func (m *Mutex) Unlock() { // Update state and unblock waiting goroutines if any. } "><meta itemprop=datePublished content="2024-09-07T00:00:00+00:00"><meta itemprop=dateModified content="2024-09-07T00:00:00+00:00"><meta itemprop=wordCount content="810"><meta itemprop=keywords content="Golang"><meta property="og:url" content="https://bleedkagax.github.io/post/5_sync/"><meta property="og:site_name" content="Kaga Blog"><meta property="og:title" content="Go's Sync"><meta property="og:description" content="sync.Mutex // Mutex provides mutual exclusion for shared resources. type Mutex struct { state int32 // State of the mutex (locked/unlocked) sema uint32 // Semaphore for blocking goroutines } // Lock acquires the mutex, blocking if necessary. func (m *Mutex) Lock() { // Check if already locked; if so, block until unlocked. } // Unlock releases the mutex. func (m *Mutex) Unlock() { // Update state and unblock waiting goroutines if any. } "><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-07T00:00:00+00:00"><meta property="article:tag" content="Golang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go's Sync"><meta name=twitter:description content="sync.Mutex // Mutex provides mutual exclusion for shared resources. type Mutex struct { state int32 // State of the mutex (locked/unlocked) sema uint32 // Semaphore for blocking goroutines } // Lock acquires the mutex, blocking if necessary. func (m *Mutex) Lock() { // Check if already locked; if so, block until unlocked. } // Unlock releases the mutex. func (m *Mutex) Unlock() { // Update state and unblock waiting goroutines if any. } "><link rel=canonical href=https://bleedkagax.github.io/post/5_sync/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 ltr:mr-auto rtl:ml-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://bleedkagax.github.io/>Kaga Blog</a><div class="btn-dark text-[0] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 ltr:-mr-8 rtl:-ml-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-14><h1 class="!my-0 pb-2.5">Go's Sync</h1><div class="text-xs antialiased opacity-60"><time>Sep 7, 2024</time></div></header><section><h2 id=syncmutex><code>sync.Mutex</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Mutex provides mutual exclusion for shared resources.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Mutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>state</span> <span style=color:#66d9ef>int32</span>   <span style=color:#75715e>// State of the mutex (locked/unlocked)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sema</span>  <span style=color:#66d9ef>uint32</span>  <span style=color:#75715e>// Semaphore for blocking goroutines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lock acquires the mutex, blocking if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Lock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check if already locked; if so, block until unlocked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Unlock releases the mutex.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>) <span style=color:#a6e22e>Unlock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Update state and unblock waiting goroutines if any.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>Mechanism</strong>: Uses atomic operations to manage state and semaphore to block goroutines.</p><h2 id=syncrwmutex><code>sync.RWMutex</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// RWMutex allows multiple readers or one writer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RWMutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>       <span style=color:#a6e22e>Mutex</span>   <span style=color:#75715e>// Mutex for exclusive access by writers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>readers</span> <span style=color:#66d9ef>int32</span>   <span style=color:#75715e>// Count of active readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>readerSem</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// Semaphore for managing reader access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>writerSem</span> <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// Semaphore for managing writer access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// RLock acquires a read lock, allowing multiple concurrent readers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>RLock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Increment reader count; block if a writer is active.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// RUnlock releases a read lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>RUnlock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Decrement reader count and unblock if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lock acquires an exclusive write lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>Lock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Block all readers and wait for exclusive access.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Unlock releases the write lock.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rw</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RWMutex</span>) <span style=color:#a6e22e>Unlock</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Release exclusive access and notify waiting readers/writers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>Mechanism</strong>: Combines a mutex with counters and semaphores to manage read/write access efficiently.</p><h2 id=syncwaitgroup><code>sync.WaitGroup</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// WaitGroup waits for a collection of goroutines to finish executing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>WaitGroup</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noCopy</span> <span style=color:#a6e22e>noCopy</span>     <span style=color:#75715e>// Prevent copying of WaitGroup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>state1</span> [<span style=color:#ae81ff>1</span>]<span style=color:#66d9ef>uint32</span>  <span style=color:#75715e>// Atomic state tracking active goroutines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>done</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// Count of completed goroutines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sema</span>   <span style=color:#66d9ef>uint32</span>     <span style=color:#75715e>// Semaphore for blocking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add increments the WaitGroup counter by n.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Increment counter; block if necessary based on done count.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Done decrements the WaitGroup counter by one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Done</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Increment done count; signal if all goroutines are done.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait blocks until the WaitGroup counter is zero.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>WaitGroup</span>) <span style=color:#a6e22e>Wait</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Block until all added goroutines call Done().
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>Mechanism</strong>: Utilizes atomic operations and a semaphore to manage synchronization among multiple goroutines.</p><h2 id=synconce><code>sync.Once</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Once ensures that a function is executed only once.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Once</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>m</span>    <span style=color:#a6e22e>Mutex</span>   <span style=color:#75715e>// Mutex for synchronization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>done</span> <span style=color:#66d9ef>uint32</span>  <span style=color:#75715e>// Flag indicating if function has been called
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Do executes the function f only once.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Once</span>) <span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()          <span style=color:#75715e>// Lock to ensure exclusive access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>done</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {   <span style=color:#75715e>// Check if function has been executed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>f</span>()            <span style=color:#75715e>// Call the function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>done</span> = <span style=color:#ae81ff>1</span>    <span style=color:#75715e>// Mark as executed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()       <span style=color:#75715e>// Unlock after execution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>Mechanism</strong>: Uses a mutex to ensure that the wrapped function is executed only once, regardless of how many times <code>Do()</code> is called.</p><h2 id=synccond><code>sync.Cond</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Cond provides a way for goroutines to wait for conditions to be met.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Cond</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>noCopy</span> <span style=color:#a6e22e>noCopy</span>      <span style=color:#75715e>// Prevent copying of Cond
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>L</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>Mutex</span>      <span style=color:#75715e>// Locker that must be held when calling Wait or Signal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>notify</span> <span style=color:#a6e22e>notifyList</span>  <span style=color:#75715e>// List of waiting goroutines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait atomically releases the mutex and waits for notification.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Wait</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>L</span>.<span style=color:#a6e22e>Unlock</span>()       <span style=color:#75715e>// Unlock before waiting to avoid deadlock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Block until notified by Signal or Broadcast.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Signal wakes one waiting goroutine, if any.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Signal</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Notify one waiting goroutine to wake up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Broadcast wakes all waiting goroutines, if any.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Cond</span>) <span style=color:#a6e22e>Broadcast</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Notify all waiting goroutines to wake up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><strong>Mechanism</strong>: Uses an associated mutex to manage access and a notification system to wake up blocked goroutines based on conditions.</p><h2 id=syncmap><code>sync.Map</code></h2><h3 id=structure>Structure</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Map</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>mu</span>     <span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>read</span>   <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Value</span> <span style=color:#75715e>// readOnly
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>dirty</span>  <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>interface</span>{}]<span style=color:#f92672>*</span><span style=color:#a6e22e>entry</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>misses</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>readOnly</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>m</span>       <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>interface</span>{}]<span style=color:#f92672>*</span><span style=color:#a6e22e>entry</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>amended</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>entry</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// *interface{}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><strong><code>mu</code></strong>: A mutex used to protect access to <strong><code>read</code></strong> and <strong><code>dirty</code></strong>.</li><li><strong><code>read</code></strong>: A read-only data structure supporting concurrent reads using atomic operations. It stores a <strong><code>readOnly</code></strong> structure, which is a native map. The <strong><code>amended</code></strong> attribute marks whether the <strong><code>read</code></strong> and <strong><code>dirty</code></strong> data are consistent.</li><li><strong><code>dirty</code></strong>: A native map for reading and writing data, requiring locking to ensure data security.</li><li><strong><code>misses</code></strong>: A counter tracking how many times the read operation fails.</li><li><strong><code>entry</code></strong>: It contains a pointer <strong><code>p</code></strong> that points to the value stored for the element (key).</li></ul><h3 id=load>Load</h3><ol><li>Check <code>read</code> map first (lock-free)</li><li>If not found and <code>amended</code> is true, lock and check <code>dirty</code> map</li><li>Increment <code>misses</code> counter if needed</li></ol><h3 id=store>Store</h3><ol><li>Try to update existing entry in <code>read</code> map (lock-free)</li><li>If not possible, lock and update <code>dirty</code> map</li><li>If <code>amended</code> is false, copy <code>read</code> to <code>dirty</code> before updating</li></ol><h3 id=delete>Delete</h3><ol><li>Try to mark entry as deleted in <code>read</code> map (lock-free)</li><li>If not possible, lock and delete from <code>dirty</code> map</li></ol><h3 id=loadorstore>LoadOrStore</h3><p>Combines <code>Load</code> and <code>Store</code> operations efficiently</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 ltr:mr-1.5 rtl:ml-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://bleedkagax.github.io/tags/golang>Golang</a></footer><nav class="mt-24 flex overflow-hidden rounded-xl bg-black/[3%] text-lg !leading-[1.2] *:flex *:w-1/2 *:items-center *:p-5 *:font-medium *:no-underline dark:bg-white/[8%] [&>*:hover]:bg-black/[2%] dark:[&>*:hover]:bg-white/[3%]"><a class="ltr:pr-3 rtl:pl-3" href=https://bleedkagax.github.io/post/6_go_garbage_collection/><span class="ltr:mr-1.5 rtl:ml-1.5">←</span><span>Go Garbage Collection</span></a>
<a class="ltr:ml-auto rtl:mr-auto justify-end pl-3" href=https://bleedkagax.github.io/post/1_jaeger/><span>Jaeger</span><span class="ltr:ml-1.5 rtl:mr-1.5">→</span></a></nav><script type=module>
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid [&_svg]:block [&_svg]:m-auto">${e.innerHTML}</div>`})</script></article></main><footer class="mx-auto flex h-[4.5rem] max-w-[--w] items-center px-8 text-xs uppercase tracking-wider opacity-60"><div class=mr-auto>&copy; 2025
<a class=link href=https://bleedkagax.github.io/>Kaga Blog</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>